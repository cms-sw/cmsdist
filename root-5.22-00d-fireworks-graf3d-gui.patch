commit 2fcc79488e78a0aba4e223d2041bf202cef05cd1
Author: Giulio Eulisse <giulio.eulisse@cern.ch>
Date:   Sat Oct 9 11:15:40 2010 +0200

    ../CMSDIST/root-5.22-00d-fireworks-graf3d-gui.patch

diff --git a/graf3d/doc/v524/index.html b/graf3d/doc/v524/index.html
new file mode 100644
index 0000000..6ab4305
--- /dev/null
+++ b/graf3d/doc/v524/index.html
@@ -0,0 +1,60 @@
+<!-- DOCTYPE HTML SYSTEM><html><head><title>graf3d</title></head><body -->
+
+<br> 
+<hr> 
+<a name="graf3d"></a> 
+<h3>OpenGL</h3>
+
+<ul>
+
+<li> It is now possible to draw a histogram with the "GLBOX" in the
+GL-viewer.
+
+<li> New class <tt>TGLAnnotation</tt> - it allows display of
+annotation-text on top of displayed objects.
+
+The annotation can be created from the <tt>TGLViewer</tt> editor
+("Guides" tab). After that it can be dragged around the screen, edited
+or closed.
+
+<li> <tt>TGLAxisPainter</tt> - reimplemented to completely separate
+label and tick-mark positioning code from the rendering itself.
+
+<li> <tt>TGLSAViewer</tt> - when exporting an image properly take into
+account image extension if it was typed by the user.
+
+<li> <tt>TGLFont</tt> now uses the same font-naming scheme as the rest
+of ROOT (had to specify font-file names before).
+
+</ul>
+
+
+<!------------------------------------------------------------------------------>
+
+
+<br>
+<hr>
+<h3>Eve</h3>
+
+<ul>
+
+<li> <tt>TEveElement</tt> - add context-menu functions allowing the
+source-object to be printed, dumped or exported to CINT.
+
+<li> <tt>TEveTrack</tt> - added flag for locking of current
+track-points - the track will not be re-extrapolated automatically
+even when the extrapolation parameters are changed.
+
+<li> <tt>TEveTrack</tt> - removed ALICE specific <tt>ImportXyzz()</tt>
+functions for loading of kinematics, hits and clusters associated with
+a track. These were calling macros that were not available in ROOT.
+
+<li> Several improvements in rendering of coordinate axes
+in <tt>TEveCaloLego</tt> and <tt>TEveProjectionAxes</tt>.
+
+<li> New class <tt>TEveJetCone</tt> for display of jet-cones clipped
+to the calorimeter's inner surface.
+
+</ul>
+
+<!-- /body></html -->
diff --git a/graf3d/eve/Module.mk b/graf3d/eve/Module.mk
index 100e9f4..d000956 100644
--- a/graf3d/eve/Module.mk
+++ b/graf3d/eve/Module.mk
@@ -34,10 +34,10 @@ EVEH1     := TEveBrowser TEveChunkManager TEveCompound \
 
 EVEH2     := TEveArrow TEveBoxSet TEveCalo \
              TEveDigitSet TEveFrameBox TEveGeoNode TEveGeoShapeExtract \
-             TEveGridStepper TEveLegoEventHandler TEveLegoOverlay \
+             TEveGridStepper TEveLegoEventHandler \
              TEveLine TEvePointSet TEvePolygonSetProjected TEveQuadSet \
              TEveRGBAPalette TEveScalableStraightLineSet TEveStraightLineSet \
-             TEveText TEveTrack TEveTriangleSet 
+             TEveText TEveTrack TEveTriangleSet TEveJetCone
 
 EVEH1     := $(foreach stem, $(EVEH1), $(wildcard $(MODDIRI)/$(stem)*.h))
 EVEH2     := $(foreach stem, $(EVEH2), $(wildcard $(MODDIRI)/$(stem)*.h))
diff --git a/graf3d/eve/inc/LinkDef2.h b/graf3d/eve/inc/LinkDef2.h
index de3cfc5..42595b5 100644
--- a/graf3d/eve/inc/LinkDef2.h
+++ b/graf3d/eve/inc/LinkDef2.h
@@ -108,19 +108,23 @@
 #pragma link C++ class TEveCaloViz+;
 #pragma link C++ class TEveCaloVizEditor+;
 #pragma link C++ class TEveCalo3D+;
+#pragma link C++ class TEveCalo3DEditor+;
 #pragma link C++ class TEveCalo3DGL+;
 #pragma link C++ class TEveCalo2D+;
 #pragma link C++ class TEveCalo2DGL+;
 #pragma link C++ class TEveCaloLego+;
 #pragma link C++ class TEveCaloLegoEditor+;
 #pragma link C++ class TEveCaloLegoGL+;
+#pragma link C++ class TEveCaloLegoOverlay+;
 
 // TEveLegoEventHandler
 #pragma link C++ class TEveLegoEventHandler+;
 
-// TEveLegoOverlay
-#pragma link C++ class TEveLegoOverlay+;
 
+// TEveJetCone
+#pragma link C++ class TEveJetCone+;
+#pragma link C++ class TEveJetConeEditor+;
+#pragma link C++ class TEveJetConeGL+;
 
 //______________________________________________________________________________
 // Helper classes
diff --git a/graf3d/eve/inc/TEveBoxSet.h b/graf3d/eve/inc/TEveBoxSet.h
index 0c16e6f..8440fe6 100644
--- a/graf3d/eve/inc/TEveBoxSet.h
+++ b/graf3d/eve/inc/TEveBoxSet.h
@@ -62,7 +62,7 @@ protected:
    static Int_t SizeofAtom(EBoxType_e bt);
 
 public:
-   TEveBoxSet(const Text_t* n="TEveBoxSet", const Text_t* t="");
+   TEveBoxSet(const char* n="TEveBoxSet", const char* t="");
    virtual ~TEveBoxSet() {}
 
    void Reset(EBoxType_e boxType, Bool_t valIsCol, Int_t chunkSize);
diff --git a/graf3d/eve/inc/TEveCalo.h b/graf3d/eve/inc/TEveCalo.h
index fffaf09..7614941 100644
--- a/graf3d/eve/inc/TEveCalo.h
+++ b/graf3d/eve/inc/TEveCalo.h
@@ -67,7 +67,7 @@ protected:
    virtual void BuildCellIdCache() = 0;
 
 public:
-   TEveCaloViz(TEveCaloData* data=0, const Text_t* n="TEveCaloViz", const Text_t* t="");
+   TEveCaloViz(TEveCaloData* data=0, const char* n="TEveCaloViz", const char* t="");
 
    virtual ~TEveCaloViz();
 
@@ -157,16 +157,19 @@ protected:
    virtual void BuildCellIdCache();
 
 public:
-   TEveCalo3D(TEveCaloData* d=0, const Text_t* n="TEveCalo3D", const Text_t* t="xx");
+   TEveCalo3D(TEveCaloData* d=0, const char* n="TEveCalo3D", const char* t="xx");
    virtual ~TEveCalo3D() {}
    virtual void ComputeBBox();
 
-   virtual Bool_t CanEditMainColor() const  { return kTRUE; }
+   virtual Bool_t CanEditMainColor()        const { return kTRUE; }
    virtual Bool_t CanEditMainTransparency() const { return kTRUE; }
 
    void SetRnrFrame(Bool_t e, Bool_t b)         { fRnrEndCapFrame = e; fRnrBarrelFrame = b; }
    void GetRnrFrame(Bool_t &e, Bool_t &b) const { e = fRnrEndCapFrame; b = fRnrBarrelFrame; }
 
+   virtual void SetFrameTransparency(UChar_t x) { fFrameTransparency = x; }
+   UChar_t GetFrameTransparency() const { return fFrameTransparency; }
+
    ClassDef(TEveCalo3D, 0); // Class for 3D visualization of calorimeter event data.
 };
 
@@ -190,7 +193,7 @@ protected:
    virtual void BuildCellIdCache();
 
 public:
-   TEveCalo2D(const Text_t* n="TEveCalo2D", const Text_t* t="");
+   TEveCalo2D(const char* n="TEveCalo2D", const char* t="");
    virtual ~TEveCalo2D(){}
 
    virtual void SetProjection(TEveProjectionManager* proj, TEveProjectable* model);
@@ -246,7 +249,7 @@ protected:
    virtual void BuildCellIdCache();
 
 public:
-   TEveCaloLego(TEveCaloData* data=0, const Text_t* n="TEveCaloLego", const Text_t* t="");
+   TEveCaloLego(TEveCaloData* data=0, const char* n="TEveCaloLego", const char* t="");
 
    virtual ~TEveCaloLego(){}
 
diff --git a/graf3d/eve/inc/TEveCaloLegoGL.h b/graf3d/eve/inc/TEveCaloLegoGL.h
index f2e98f7..b2c3261 100644
--- a/graf3d/eve/inc/TEveCaloLegoGL.h
+++ b/graf3d/eve/inc/TEveCaloLegoGL.h
@@ -13,9 +13,13 @@
 #define ROOT_TEveCaloLegoGL
 
 #include "TGLObject.h"
-#include "TEveCaloData.h"
 #include "TGLIncludes.h"
 #include "TGLAxisPainter.h"
+
+#include "TEveCaloData.h"
+#include "TEveVSDStructs.h"
+#include "TEveCalo.h"
+
 #include <map>
 
 class TEveCaloLego;
@@ -28,34 +32,39 @@ private:
 
    mutable Float_t   fDataMax; // cached
 
-   mutable TAxis*    fEtaAxis;
-   mutable TAxis*    fPhiAxis;
-   mutable Int_t     fBinStep;
+   // axis
+   mutable TAxis    *fEtaAxis;
+   mutable TAxis    *fPhiAxis;
+   mutable TAxis    *fZAxis;
 
-   mutable TGLAxisAttrib    fXAxisAtt;
-   mutable TGLAxisAttrib    fYAxisAtt;
-   mutable TGLAxisAttrib    fZAxisAtt;
+   mutable TEveVector  fXAxisTitlePos;
+   mutable TEveVector  fYAxisTitlePos;
+   mutable TEveVector  fZAxisTitlePos;
+   mutable TEveVector  fBackPlaneXConst[2];
+   mutable TEveVector  fBackPlaneYConst[2];
 
-   mutable TGLAxisPainter   fAxisPainter;
-protected:
-   Int_t   GetGridStep(TGLRnrCtx &rnrCtx) const;
-   void    SetAxis(TAxis *orig, TAxis *curr) const;
+   mutable TGLAxisPainter fAxisPainter;
+   mutable Int_t          fBinStep;
 
-   Bool_t  PhiShiftInterval(Float_t &min, Float_t &max) const;
 
-   void    DrawZScales3D(TGLRnrCtx &rnrCtx, Float_t x0, Float_t x1, Float_t y0, Float_t y1) const;
-   void    DrawZAxis(TGLRnrCtx &rnrCtx, Float_t azX, Float_t azY) const;
+protected:
+   Int_t   GetGridStep(TGLRnrCtx &rnrCtx) const;
+   void    RebinAxis(TAxis *orig, TAxis *curr) const;
 
-   void    DrawXYScales(TGLRnrCtx &rnrCtx, Float_t x0, Float_t x1, Float_t y0, Float_t y1) const;
+   void    SetAxis3DTitlePos(TGLRnrCtx &rnrCtx, Float_t x0, Float_t x1, Float_t y0, Float_t y1) const;
+   void    DrawAxis3D(TGLRnrCtx &rnrCtx) const;
+   void    DrawAxis2D(TGLRnrCtx &rnrCtx) const;
    void    DrawHistBase(TGLRnrCtx &rnrCtx) const;
 
    void    DrawCells2D() const;
 
    void    DrawCells3D(TGLRnrCtx & rnrCtx) const;
-   void    MakeQuad(Float_t x, Float_t y, Float_t z,
-                    Float_t xw, Float_t yw, Float_t zh) const;
+   void    MakeQuad(Float_t x, Float_t y, Float_t z, Float_t xw, Float_t yw, Float_t zh) const;
    void    MakeDisplayList() const;
 
+   void    WrapTwoPi(Float_t &min, Float_t &max) const;
+
+   TEveCaloLego                     *fM;  // Model object.
    mutable Bool_t                    fDLCacheOK;
 
    typedef std::map<Int_t, UInt_t>           SliceDLMap_t;
@@ -64,15 +73,13 @@ protected:
    mutable SliceDLMap_t              fDLMap;
    mutable TEveCaloData::RebinData_t fRebinData;
 
-   mutable Bool_t           fCells3D;
-
-   TEveCaloLego            *fM;  // Model object.
+   mutable Bool_t                    fCells3D;
 
 public:
    TEveCaloLegoGL();
    virtual ~TEveCaloLegoGL();
 
-   virtual Bool_t SetModel(TObject* obj, const Option_t* opt=0);
+   virtual Bool_t SetModel(TObject* obj, const Option_t* opt = 0);
 
    virtual void   SetBBox();
 
@@ -80,11 +87,26 @@ public:
    virtual void   DLCachePurge();
 
    virtual void   DirectDraw(TGLRnrCtx & rnrCtx) const;
-
    virtual Bool_t SupportsSecondarySelect() const { return kTRUE; }
    virtual void   ProcessSelection(TGLRnrCtx & rnrCtx, TGLSelectRecord & rec);
 
    ClassDef(TEveCaloLegoGL, 0); // GL renderer class for TEveCaloLego.
 };
 
+//______________________________________________________________________________
+inline void TEveCaloLegoGL::WrapTwoPi(Float_t &min, Float_t &max) const
+{
+   //   static const Float_t pi  = TMath::Pi() + 1e-6;
+   if (fM->GetPhiMax()>TMath::Pi() && max<=fM->GetPhiMin())
+   {
+      min += TMath::TwoPi();
+      max += TMath::TwoPi();
+   }
+   else if (fM->GetPhiMin()<-TMath::Pi() && min>=fM->GetPhiMax())
+   {
+      min -= TMath::TwoPi();
+      max -= TMath::TwoPi();
+   }
+
+}
 #endif
diff --git a/graf3d/eve/inc/TEveCaloLegoOverlay.h b/graf3d/eve/inc/TEveCaloLegoOverlay.h
new file mode 100644
index 0000000..8dc7c9a
--- /dev/null
+++ b/graf3d/eve/inc/TEveCaloLegoOverlay.h
@@ -0,0 +1,84 @@
+// @(#)root/eve:$Id: root-5.22-00d-fireworks-graf3d-gui.patch,v 1.5 2010/10/09 09:42:53 eulisse Exp $
+// Author: Alja Mrak-Tadel 2007
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#ifndef ROOT_TEveCaloLegoOverlay
+#define ROOT_TEveCaloLegoOverlay
+
+#include "TGLCameraOverlay.h"
+#include "TEveElement.h"
+
+class TEveCaloLego;
+
+class TEveCaloLegoOverlay : public TGLCameraOverlay,
+                        public TEveElementList
+{
+private:
+   TEveCaloLegoOverlay(const TEveCaloLegoOverlay&);            // Not implemented
+   TEveCaloLegoOverlay& operator=(const TEveCaloLegoOverlay&); // Not implemented
+
+   void DrawSlider(TGLRnrCtx& rnrCtx);
+
+   Bool_t SetSliderVal(Event_t* event,TGLRnrCtx& rnrCtx );
+
+   TString        fHeaderTxt;
+   Bool_t         fHeaderSelected;
+
+protected:
+   TEveCaloLego*  fCalo;
+   TAxis         *fSliderAxis;
+
+   Color_t        fMainColor;
+
+   Bool_t         fShowCamera;
+   Bool_t         fShowPlane;
+
+   // plane-value
+   Float_t        fMenuW;
+   Float_t        fButtonW;
+   Float_t        fSliderH;    // slider height in % of viewport
+   Float_t        fSliderPosY; // y position of slider bottom up
+   Bool_t         fShowSlider;
+   Float_t        fSliderVal;
+
+   // event handling
+   Int_t           fActiveID;
+   Color_t         fActiveCol;
+
+   virtual  void   RenderPlaneInterface(TGLRnrCtx& rnrCtx);
+   virtual  void   RenderHeader(TGLRnrCtx& rnrCtx);
+
+public:
+   TEveCaloLegoOverlay();
+   virtual ~TEveCaloLegoOverlay(){}
+
+   // event handling
+   virtual  Bool_t MouseEnter(TGLOvlSelectRecord& selRec);
+   virtual  Bool_t Handle(TGLRnrCtx& rnrCtx, TGLOvlSelectRecord& selRec, Event_t* event);
+   virtual  void   MouseLeave();
+
+   //rendering
+   virtual  void   Render(TGLRnrCtx& rnrCtx);
+
+   TEveCaloLego* GetCaloLego() {return fCalo;}
+   void SetCaloLego(TEveCaloLego* c) {fCalo = c;}
+
+   void SetShowCamera (Bool_t x) { fShowCamera = x; }
+   Bool_t GetShowCamera() const { return fShowCamera; }
+   void SetShowPlane (Bool_t x) { fShowPlane = x; }
+   Bool_t GetShowPlane() const { return fShowPlane; }
+
+   void  SetHeaderTxt(const char *txt) {fHeaderTxt = txt; }
+   const char* GetHeaderTxt() const { return fHeaderTxt; }
+
+   ClassDef(TEveCaloLegoOverlay, 0); // GL-overaly control GUI for TEveCaloLego.
+};
+
+#endif
diff --git a/graf3d/eve/inc/TEveCaloVizEditor.h b/graf3d/eve/inc/TEveCaloVizEditor.h
index 402c577..aae4272 100644
--- a/graf3d/eve/inc/TEveCaloVizEditor.h
+++ b/graf3d/eve/inc/TEveCaloVizEditor.h
@@ -15,11 +15,13 @@
 #include "TGedFrame.h"
 
 class TEveCaloViz;
+class TEveCalo3D;
 class TGDoubleHSlider;
 class TEveGValuator;
 class TEveGDoubleValuator;
 class TGCheckButton;
 class TGRadioButton;
+class TGNumberEntry;
 
 class TGVerticalFrame;
 
@@ -33,6 +35,8 @@ private:
 protected:
    TEveCaloViz               *fM; // Model object.
 
+   TGNumberEntry             *fFrameTransparency;
+
    TGRadioButton             *fPlotE;
    TGRadioButton             *fPlotEt;
 
@@ -69,4 +73,27 @@ public:
    ClassDef(TEveCaloVizEditor, 0); // GUI editor for TEveCaloVizEditor.
 };
 
+/**************************************************************************/
+
+class TEveCalo3DEditor : public TGedFrame
+{
+private:
+   TEveCalo3DEditor(const TEveCalo3DEditor&);            // Not implemented
+   TEveCalo3DEditor& operator=(const TEveCalo3DEditor&); // Not implemented
+
+protected:
+   TEveCalo3D          *fM; // Model object.
+   TGNumberEntry       *fFrameTransparency;
+
+public:
+   TEveCalo3DEditor(const TGWindow* p=0, Int_t width=170, Int_t height=30,
+                     UInt_t options=kChildFrame, Pixel_t back=GetDefaultFrameBackground());
+   virtual ~TEveCalo3DEditor() {}
+
+   virtual void SetModel(TObject* obj);
+   void    DoFrameTransparency();
+
+   ClassDef(TEveCalo3DEditor, 0); // GUI editor for TEveCalo3DEditor.
+};
+
 #endif
diff --git a/graf3d/eve/inc/TEveCompound.h b/graf3d/eve/inc/TEveCompound.h
index 903a47b..736c3ae 100644
--- a/graf3d/eve/inc/TEveCompound.h
+++ b/graf3d/eve/inc/TEveCompound.h
@@ -31,7 +31,7 @@ protected:
    Short_t  fCompoundOpen; // If more than zero, tag new children as compound members.
 
 public:
-   TEveCompound(const Text_t* n="TEveCompound", const Text_t* t="",
+   TEveCompound(const char* n="TEveCompound", const char* t="",
                 Bool_t doColor=kTRUE);
    virtual ~TEveCompound() {}
 
diff --git a/graf3d/eve/inc/TEveDigitSet.h b/graf3d/eve/inc/TEveDigitSet.h
index 14d11e1..489d3d0 100644
--- a/graf3d/eve/inc/TEveDigitSet.h
+++ b/graf3d/eve/inc/TEveDigitSet.h
@@ -71,7 +71,7 @@ protected:
    void       ReleaseIds();
 
 public:
-   TEveDigitSet(const Text_t* n="TEveDigitSet", const Text_t* t="");
+   TEveDigitSet(const char* n="TEveDigitSet", const char* t="");
    virtual ~TEveDigitSet();
 
    virtual Bool_t CanEditMainColor() const { return kTRUE; }
diff --git a/graf3d/eve/inc/TEveElement.h b/graf3d/eve/inc/TEveElement.h
index cffe4e2..6daedf3 100644
--- a/graf3d/eve/inc/TEveElement.h
+++ b/graf3d/eve/inc/TEveElement.h
@@ -111,11 +111,11 @@ public:
    virtual TEveElement* CloneElementRecurse(Int_t level=0) const;
    virtual void         CloneChildrenRecurse(TEveElement* dest, Int_t level=0) const;
 
-   virtual const Text_t* GetElementName()  const;
-   virtual const Text_t* GetElementTitle() const;
-   virtual void SetElementName (const Text_t* name);
-   virtual void SetElementTitle(const Text_t* title);
-   virtual void SetElementNameTitle(const Text_t* name, const Text_t* title);
+   virtual const char* GetElementName()  const;
+   virtual const char* GetElementTitle() const;
+   virtual void SetElementName (const char* name);
+   virtual void SetElementTitle(const char* title);
+   virtual void SetElementNameTitle(const char* name, const char* title);
    virtual void NameTitleChanged();
 
    const TString& GetVizTag() const             { return fVizTag; }
@@ -211,8 +211,12 @@ public:
 
    virtual Int_t GetNItems() const { return fItems.size(); }
 
-   void         SpawnEditor();                  // *MENU*
-   virtual void ExportToCINT(Text_t* var_name); // *MENU*
+   void         SpawnEditor();                // *MENU*
+   virtual void ExportToCINT(char* var_name); // *MENU*
+
+   void    DumpSourceObject() const;                       // *MENU*
+   void    PrintSourceObject() const;                      // *MENU*
+   void    ExportSourceObjectToCINT(char* var_name) const; // *MENU*
 
    virtual Bool_t AcceptElement(TEveElement* el);
 
@@ -377,7 +381,7 @@ public:
    virtual TEveElementObjectPtr* CloneElement() const { return new TEveElementObjectPtr(*this); }
 
    virtual TObject* GetObject(const TEveException& eh="TEveElementObjectPtr::GetObject ") const;
-   virtual void     ExportToCINT(Text_t* var_name);
+   virtual void     ExportToCINT(char* var_name);
 
    Bool_t GetOwnObject() const   { return fOwnObject; }
    void   SetOwnObject(Bool_t o) { fOwnObject = o; }
@@ -402,23 +406,23 @@ protected:
    TClass   *fChildClass;  // Class of acceptable children, others are rejected.
 
 public:
-   TEveElementList(const Text_t* n="TEveElementList", const Text_t* t="",
+   TEveElementList(const char* n="TEveElementList", const char* t="",
                    Bool_t doColor=kFALSE);
    TEveElementList(const TEveElementList& e);
    virtual ~TEveElementList() {}
 
    virtual TEveElementList* CloneElement() const { return new TEveElementList(*this); }
 
-   virtual const Text_t* GetElementName()  const { return GetName();  }
-   virtual const Text_t* GetElementTitle() const { return GetTitle(); }
+   virtual const char* GetElementName()  const { return GetName();  }
+   virtual const char* GetElementTitle() const { return GetTitle(); }
 
-   virtual void SetElementName (const Text_t* name)
+   virtual void SetElementName (const char* name)
    { TNamed::SetName(name); NameTitleChanged(); }
 
-   virtual void SetElementTitle(const Text_t* title)
+   virtual void SetElementTitle(const char* title)
    { TNamed::SetTitle(title); NameTitleChanged(); }
 
-   virtual void SetElementNameTitle(const Text_t* name, const Text_t* title)
+   virtual void SetElementNameTitle(const char* name, const char* title)
    { TNamed::SetNameTitle(name, title); NameTitleChanged(); }
 
    virtual Bool_t CanEditMainColor() const { return fDoColor; }
diff --git a/graf3d/eve/inc/TEveEventManager.h b/graf3d/eve/inc/TEveEventManager.h
index 2ce79d0..9c6860b 100644
--- a/graf3d/eve/inc/TEveEventManager.h
+++ b/graf3d/eve/inc/TEveEventManager.h
@@ -22,7 +22,7 @@ protected:
    std::vector<TString>  fNewEventCommands;
 
 public:
-   TEveEventManager(const Text_t* n="TEveEventManager", const Text_t* t="");
+   TEveEventManager(const char* n="TEveEventManager", const char* t="");
    virtual ~TEveEventManager() {}
 
    std::vector<TString>& GetNewEventCommands() { return fNewEventCommands; }
diff --git a/graf3d/eve/inc/TEveGValuators.h b/graf3d/eve/inc/TEveGValuators.h
index 7dd100f..578f26b 100644
--- a/graf3d/eve/inc/TEveGValuators.h
+++ b/graf3d/eve/inc/TEveGValuators.h
@@ -96,7 +96,7 @@ public:
    void SetLimits(Float_t min, Float_t max, Int_t npos,
                   TGNumberFormat::EStyle nef=TGNumberFormat::kNESRealTwo);
 
-   void SetToolTip(const Text_t* tip);
+   void SetToolTip(const char* tip);
    void SetEnabled(Bool_t state);
 
    ClassDef(TEveGValuator, 0); // Composite GUI element for single value selection (supports label, number-entry and slider).
diff --git a/graf3d/eve/inc/TEveGeoNode.h b/graf3d/eve/inc/TEveGeoNode.h
index 6e2923e..e1a55c1 100644
--- a/graf3d/eve/inc/TEveGeoNode.h
+++ b/graf3d/eve/inc/TEveGeoNode.h
@@ -41,10 +41,10 @@ protected:
 public:
    TEveGeoNode(TGeoNode* node);
 
-   virtual const Text_t* GetName()  const;
-   virtual const Text_t* GetTitle() const;
-   virtual const Text_t* GetElementName()  const;
-   virtual const Text_t* GetElementTitle() const;
+   virtual const char* GetName()  const;
+   virtual const char* GetTitle() const;
+   virtual const char* GetElementName()  const;
+   virtual const char* GetElementTitle() const;
 
    TGeoNode* GetNode() const { return fNode; }
 
@@ -138,7 +138,7 @@ protected:
    TEveGeoShapeExtract* DumpShapeTree(TEveGeoShape* geon, TEveGeoShapeExtract* parent = 0);
 
 public:
-   TEveGeoShape(const Text_t* name="TEveGeoShape", const Text_t* title=0);
+   TEveGeoShape(const char* name="TEveGeoShape", const char* title=0);
    virtual ~TEveGeoShape();
 
    virtual Bool_t  CanEditMainColor()        const { return kTRUE; }
diff --git a/graf3d/eve/inc/TEveGeoShapeExtract.h b/graf3d/eve/inc/TEveGeoShapeExtract.h
index edde3c2..90241b4 100644
--- a/graf3d/eve/inc/TEveGeoShapeExtract.h
+++ b/graf3d/eve/inc/TEveGeoShapeExtract.h
@@ -31,7 +31,7 @@ protected:
    TList*      fElements;    // Children elements.
 
 public:
-   TEveGeoShapeExtract(const Text_t* n="TEveGeoShapeExtract", const Text_t* t=0);
+   TEveGeoShapeExtract(const char* n="TEveGeoShapeExtract", const char* t=0);
    ~TEveGeoShapeExtract();
 
    Bool_t HasElements();
diff --git a/graf3d/eve/inc/TEveJetCone.h b/graf3d/eve/inc/TEveJetCone.h
new file mode 100644
index 0000000..20d0e2e
--- /dev/null
+++ b/graf3d/eve/inc/TEveJetCone.h
@@ -0,0 +1,61 @@
+// @(#)root/eve:$Id: root-5.22-00d-fireworks-graf3d-gui.patch,v 1.5 2010/10/09 09:42:53 eulisse Exp $
+// Author: Matevz Tadel, Jochen Thaeder 2009
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#ifndef ROOT_TEveJetCone
+#define ROOT_TEveJetCone
+
+#include "TEveElement.h"
+#include "TEveVSDStructs.h"
+#include "TAttBBox.h"
+
+class TEveJetCone : public TEveElementList,
+                    public TAttBBox
+{
+   friend class TEveJetConeGL;
+
+private:
+   TEveJetCone(const TEveJetCone&);            // Not implemented
+   TEveJetCone& operator=(const TEveJetCone&); // Not implemented
+
+   void    FillTEveVectorFromEtaPhi( TEveVector &vec, const Float_t& eta, const Float_t& phi );
+   Float_t GetArcCosConeOpeningAngle( const TEveVector& axis, const TEveVector& contour );
+
+protected:
+   typedef std::vector<TEveVector>        vTEveVector_t;
+   typedef vTEveVector_t::iterator        vTEveVector_i;
+   typedef vTEveVector_t::const_iterator  vTEveVector_ci;
+
+   TEveVector      fApex;             // Apex of the cone, initialized to ( 0., 0., 0. )
+   vTEveVector_t   fBasePoints;       // List of contour points
+   TEveVector      fCylinderBorder;   // Border of Barrel/Cylinder to cut the cone
+   Float_t         fThetaC;           // Angle between axis and  the edge of top-side of cylinder
+
+public:
+   TEveJetCone(const Text_t* n="TEveJetCone", const Text_t* t="");
+   virtual ~TEveJetCone() {}
+
+   void SetApex(const TEveVector& a)                      { fApex = a; }  // Sets apex of cone
+   void SetCylinder( const Float_t& r, const Float_t& z ) {
+      fCylinderBorder.Set( r, 0.f, z ); fThetaC = fCylinderBorder.Theta(); } // Set border cylinder
+
+   Int_t AddCone( const Float_t& eta, const Float_t& phi, const Float_t& coneRadius, const Float_t& height = -1. );
+
+   virtual Bool_t  CanEditMainTransparency() const { return kTRUE; }
+
+   // For TAttBBox:
+   virtual void ComputeBBox();
+   // If painting is needed:
+   virtual void Paint(Option_t* option="");
+
+   ClassDef(TEveJetCone, 0); // Short description.
+};
+
+#endif
diff --git a/graf3d/eve/inc/TEveJetConeEditor.h b/graf3d/eve/inc/TEveJetConeEditor.h
new file mode 100644
index 0000000..95ae7e4
--- /dev/null
+++ b/graf3d/eve/inc/TEveJetConeEditor.h
@@ -0,0 +1,49 @@
+// @(#)root/eve:$Id: root-5.22-00d-fireworks-graf3d-gui.patch,v 1.5 2010/10/09 09:42:53 eulisse Exp $
+// Author: Matevz Tadel, Jochen Thaeder 2009
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#ifndef ROOT_TEveJetConeEditor
+#define ROOT_TEveJetConeEditor
+
+#include "TGedFrame.h"
+
+class TGButton;
+class TGCheckButton;
+class TGNumberEntry;
+class TGColorSelect;
+
+class TEveJetCone;
+
+class TEveJetConeEditor : public TGedFrame
+{
+private:
+   TEveJetConeEditor(const TEveJetConeEditor&);            // Not implemented
+   TEveJetConeEditor& operator=(const TEveJetConeEditor&); // Not implemented
+
+protected:
+   TEveJetCone            *fM; // Model object.
+
+   // Declare widgets
+   // TGSomeWidget*   fXYZZ;
+
+public:
+   TEveJetConeEditor(const TGWindow* p=0, Int_t width=170, Int_t height=30,
+                     UInt_t options=kChildFrame, Pixel_t back=GetDefaultFrameBackground());
+   virtual ~TEveJetConeEditor() {}
+
+   virtual void SetModel(TObject* obj);
+
+   // Declare callback/slot methods
+   // void DoXYZZ();
+
+   ClassDef(TEveJetConeEditor, 0); // GUI editor for TEveJetCone.
+};
+
+#endif
diff --git a/graf3d/eve/inc/TEveJetConeGL.h b/graf3d/eve/inc/TEveJetConeGL.h
new file mode 100644
index 0000000..81053ba
--- /dev/null
+++ b/graf3d/eve/inc/TEveJetConeGL.h
@@ -0,0 +1,47 @@
+// @(#)root/eve:$Id: root-5.22-00d-fireworks-graf3d-gui.patch,v 1.5 2010/10/09 09:42:53 eulisse Exp $
+// Author: Matevz Tadel, Jochen Thaeder 2009
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#ifndef ROOT_TEveJetConeGL
+#define ROOT_TEveJetConeGL
+
+#include "TGLObject.h"
+
+class TGLViewer;
+class TGLScene;
+
+class TEveJetCone;
+
+class TEveJetConeGL : public TGLObject
+{
+private:
+   TEveJetConeGL(const TEveJetConeGL&);            // Not implemented
+   TEveJetConeGL& operator=(const TEveJetConeGL&); // Not implemented
+
+protected:
+   TEveJetCone             *fM;  // Model object.
+
+public:
+   TEveJetConeGL();
+   virtual ~TEveJetConeGL() {}
+
+   virtual Bool_t SetModel(TObject* obj, const Option_t* opt=0);
+   virtual void   SetBBox();
+
+   virtual void DirectDraw(TGLRnrCtx & rnrCtx) const;
+
+   // To support two-level selection
+   // virtual Bool_t SupportsSecondarySelect() const { return kTRUE; }
+   // virtual void ProcessSelection(TGLRnrCtx & rnrCtx, TGLSelectRecord & rec);
+
+   ClassDef(TEveJetConeGL, 0); // GL renderer class for TEveJetCone.
+};
+
+#endif
diff --git a/graf3d/eve/inc/TEveLegoOverlay.h b/graf3d/eve/inc/TEveLegoOverlay.h
index 4d118a2..9743796 100644
--- a/graf3d/eve/inc/TEveLegoOverlay.h
+++ b/graf3d/eve/inc/TEveLegoOverlay.h
@@ -1,84 +1,2 @@
 // @(#)root/eve:$Id: root-5.22-00d-fireworks-graf3d-gui.patch,v 1.5 2010/10/09 09:42:53 eulisse Exp $
-// Author: Matevz Tadel 2007
-
-/*************************************************************************
- * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
- * All rights reserved.                                                  *
- *                                                                       *
- * For the licensing terms see $ROOTSYS/LICENSE.                         *
- * For the list of contributors see $ROOTSYS/README/CREDITS.             *
- *************************************************************************/
-
-#ifndef ROOT_TEveLegoOverlay
-#define ROOT_TEveLegoOverlay
-
-#include "TGLCameraOverlay.h"
-#include "TEveElement.h"
-#include "TGLAxisPainter.h"
-
-class TEveCaloLego;
-
-class TEveLegoOverlay : public TGLCameraOverlay,
-                        public TEveElementList
-{
-private:
-   TEveLegoOverlay(const TEveLegoOverlay&);            // Not implemented
-   TEveLegoOverlay& operator=(const TEveLegoOverlay&); // Not implemented
-
-   void DrawSlider(TGLRnrCtx& rnrCtx);
-
-   Bool_t SetSliderVal(Event_t* event,TGLRnrCtx& rnrCtx );
-
-   TString        fHeaderTxt;
-   Bool_t         fHeaderSelected;
-
-protected:
-   TEveCaloLego*  fCalo;
-
-   Color_t        fMainColor;
-
-   Bool_t         fShowCamera;
-   Bool_t         fShowPlane;
-
-   // plane-value
-   Float_t        fMenuW;
-   Float_t        fButtonW;
-   Float_t        fSliderH;    // slider height in % of viewport
-   Float_t        fSliderPosY; // y position of slider bottom up
-   Bool_t         fShowSlider;
-   Float_t        fSliderVal;
-
-   // event handling
-   Int_t           fActiveID;
-   Color_t         fActiveCol;
-
-   virtual  void   RenderPlaneInterface(TGLRnrCtx& rnrCtx);
-   virtual  void   RenderHeader(TGLRnrCtx& rnrCtx);
-
-public:
-   TEveLegoOverlay();
-   virtual ~TEveLegoOverlay(){}
-
-   // event handling
-   virtual  Bool_t MouseEnter(TGLOvlSelectRecord& selRec);
-   virtual  Bool_t Handle(TGLRnrCtx& rnrCtx, TGLOvlSelectRecord& selRec, Event_t* event);
-   virtual  void   MouseLeave();
-
-   //rendering
-   virtual  void   Render(TGLRnrCtx& rnrCtx);
-
-   TEveCaloLego* GetCaloLego() {return fCalo;}
-   void SetCaloLego(TEveCaloLego* c) {fCalo = c;}
-
-   void SetShowCamera (Bool_t x) { fShowCamera = x; }
-   Bool_t GetShowCamera() const { return fShowCamera; }
-   void SetShowPlane (Bool_t x) { fShowPlane = x; }
-   Bool_t GetShowPlane() const { return fShowPlane; }
-
-   void  SetHeaderTxt(const char *txt) {fHeaderTxt = txt; }
-   const char* GetHeaderTxt() const { return fHeaderTxt; }
-
-   ClassDef(TEveLegoOverlay, 0); // GL-overaly control GUI for TEveCaloLego.
-};
-
-#endif
+// Dummy file ... removed in ROOT trunk and fireworks branch.
diff --git a/graf3d/eve/inc/TEveLine.h b/graf3d/eve/inc/TEveLine.h
index 4cafc61..8aa2026 100644
--- a/graf3d/eve/inc/TEveLine.h
+++ b/graf3d/eve/inc/TEveLine.h
@@ -40,7 +40,7 @@ protected:
 
 public:
    TEveLine(Int_t n_points=0, ETreeVarType_e tv_type=kTVT_XYZ);
-   TEveLine(const Text_t* name, Int_t n_points=0, ETreeVarType_e tv_type=kTVT_XYZ);
+   TEveLine(const char* name, Int_t n_points=0, ETreeVarType_e tv_type=kTVT_XYZ);
    virtual ~TEveLine() {}
 
    virtual void SetLineColor(Color_t col)   { SetMainColor(col); }
diff --git a/graf3d/eve/inc/TEveManager.h b/graf3d/eve/inc/TEveManager.h
index 60b36fd..3e53a24 100644
--- a/graf3d/eve/inc/TEveManager.h
+++ b/graf3d/eve/inc/TEveManager.h
@@ -154,11 +154,11 @@ public:
    TGWindow*    GetMainWindow() const;
    TEveViewer*  GetDefaultViewer() const;
    TGLViewer*   GetDefaultGLViewer() const;
-   TEveViewer*  SpawnNewViewer(const Text_t* name, const Text_t* title="", Bool_t embed=kTRUE);
-   TEveScene*   SpawnNewScene(const Text_t* name, const Text_t* title="");
+   TEveViewer*  SpawnNewViewer(const char* name, const char* title="", Bool_t embed=kTRUE);
+   TEveScene*   SpawnNewScene(const char* name, const char* title="");
 
    TFolder*     GetMacroFolder() const { return fMacroFolder; }
-   TMacro*      GetMacro(const Text_t* name) const;
+   TMacro*      GetMacro(const char* name) const;
 
    void EditElement(TEveElement* element);
 
diff --git a/graf3d/eve/inc/TEveParamList.h b/graf3d/eve/inc/TEveParamList.h
index b08434e..7d23edd 100644
--- a/graf3d/eve/inc/TEveParamList.h
+++ b/graf3d/eve/inc/TEveParamList.h
@@ -79,7 +79,7 @@ protected:
    BoolConfigVec_t      fBoolParameters;
 
 public:
-   TEveParamList(const Text_t* n="TEveParamList", const Text_t* t="", Bool_t doColor=kFALSE);
+   TEveParamList(const char* n="TEveParamList", const char* t="", Bool_t doColor=kFALSE);
    virtual ~TEveParamList() {}
 
    void AddParameter(const FloatConfig_t& parameter) { fFloatParameters.push_back(parameter); }
diff --git a/graf3d/eve/inc/TEvePointSet.h b/graf3d/eve/inc/TEvePointSet.h
index f519c3e..ac09f0d 100644
--- a/graf3d/eve/inc/TEvePointSet.h
+++ b/graf3d/eve/inc/TEvePointSet.h
@@ -49,24 +49,26 @@ protected:
 
 public:
    TEvePointSet(Int_t n_points=0, ETreeVarType_e tv_type=kTVT_XYZ);
-   TEvePointSet(const Text_t* name, Int_t n_points=0, ETreeVarType_e tv_type=kTVT_XYZ);
+   TEvePointSet(const char* name, Int_t n_points=0, ETreeVarType_e tv_type=kTVT_XYZ);
    TEvePointSet(const TEvePointSet& e);
    virtual ~TEvePointSet();
 
    virtual TEvePointSet* CloneElement() const { return new TEvePointSet(*this); }
 
+   virtual void ClonePoints(const TEvePointSet& e);
+
    virtual void ComputeBBox();
 
    void  Reset(Int_t n_points=0, Int_t n_int_ids=0);
    Int_t GrowFor(Int_t n_points);
 
-   virtual const Text_t* GetTitle()         const { return fTitle; }
-   virtual const Text_t* GetElementName()   const { return TPointSet3D::GetName(); }
-   virtual const Text_t* GetElementTitle()  const { return fTitle; }
-   virtual void  SetElementName (const Text_t* n) { fName  = n; NameTitleChanged(); }
-   virtual void  SetTitle(const Text_t* t)        { fTitle = t; NameTitleChanged(); }
-   virtual void  SetElementTitle(const Text_t* t) { fTitle = t; NameTitleChanged(); }
-   virtual void  SetElementNameTitle(const Text_t* n, const Text_t* t)
+   virtual const char* GetTitle()         const { return fTitle; }
+   virtual const char* GetElementName()   const { return TPointSet3D::GetName(); }
+   virtual const char* GetElementTitle()  const { return fTitle; }
+   virtual void  SetElementName (const char* n) { fName  = n; NameTitleChanged(); }
+   virtual void  SetTitle(const char* t)        { fTitle = t; NameTitleChanged(); }
+   virtual void  SetElementTitle(const char* t) { fTitle = t; NameTitleChanged(); }
+   virtual void  SetElementNameTitle(const char* n, const char* t)
    { fName = n; fTitle = t; NameTitleChanged(); }
 
    Int_t  GetIntIdsPerPoint() const { return fIntIdsPerPoint; }
@@ -121,7 +123,7 @@ protected:
    TString      fQuantName;            //  Name of the separating quantity.
 
 public:
-   TEvePointSetArray(const Text_t* name="TEvePointSetArray", const Text_t* title="");
+   TEvePointSetArray(const char* name="TEvePointSetArray", const char* title="");
    virtual ~TEvePointSetArray();
 
    virtual void RemoveElementLocal(TEveElement* el);
@@ -135,7 +137,7 @@ public:
 
    virtual Int_t Size(Bool_t under=kFALSE, Bool_t over=kFALSE) const;
 
-   void   InitBins(const Text_t* quant_name, Int_t nbins, Double_t min, Double_t max);
+   void   InitBins(const char* quant_name, Int_t nbins, Double_t min, Double_t max);
    Bool_t Fill(Double_t x, Double_t y, Double_t z, Double_t quant);
    void   SetPointId(TObject* id);
    void   CloseBins();
diff --git a/graf3d/eve/inc/TEvePolygonSetProjected.h b/graf3d/eve/inc/TEvePolygonSetProjected.h
index 73e12f7..d6e7405 100644
--- a/graf3d/eve/inc/TEvePolygonSetProjected.h
+++ b/graf3d/eve/inc/TEvePolygonSetProjected.h
@@ -85,7 +85,7 @@ protected:
    Float_t      fLineWidth; // outline width of polygons
 
 public:
-   TEvePolygonSetProjected(const Text_t* n="TEvePolygonSetProjected", const Text_t* t="");
+   TEvePolygonSetProjected(const char* n="TEvePolygonSetProjected", const char* t="");
    virtual ~TEvePolygonSetProjected();
 
    virtual void    SetProjection(TEveProjectionManager* mng, TEveProjectable* model);
diff --git a/graf3d/eve/inc/TEveProjectionAxes.h b/graf3d/eve/inc/TEveProjectionAxes.h
index c4c4774..b485fe2 100644
--- a/graf3d/eve/inc/TEveProjectionAxes.h
+++ b/graf3d/eve/inc/TEveProjectionAxes.h
@@ -15,9 +15,9 @@
 #include "TNamed.h"
 #include "TAtt3D.h"
 #include "TAttBBox.h"
+#include "TAttAxis.h"
 
 #include "TEveElement.h"
-#include "TGLAxisPainter.h"
 
 class TEveProjectionManager;
 
@@ -25,52 +25,51 @@ class TEveProjectionAxes : public TEveElement,
                            public TNamed,
                            public TAtt3D,
                            public TAttBBox,
-                           public TGLAxisAttrib
+                           public TAttAxis
 {
    friend class TEveProjectionAxesGL;
 
 public:
-   enum ELabMode      { kPosition, kValue };
-   enum EAxesMode     { kHorizontal, kVertical, kAll};
+   enum ELabMode { kPosition, kValue };
+   enum EAxesMode { kHorizontal, kVertical, kAll};
 
 private:
    TEveProjectionAxes(const TEveProjectionAxes&);            // Not implemented
    TEveProjectionAxes& operator=(const TEveProjectionAxes&); // Not implemented
 
 protected:
-   TEveProjectionManager*  fManager;  // model object
+   TEveProjectionManager*  fManager;  // Model object.
 
-   Color_t         fColor;
+   Color_t fColor;                    // Main eve-element color.
 
-   ELabMode        fLabMode;       // tick-mark positioning
-   EAxesMode       fAxesMode;
+   ELabMode  fLabMode;                // Division of distorted space.
+   EAxesMode fAxesMode;               // Axis vertical/hotrizontal orientation.
 
-   Bool_t          fDrawCenter;  // draw center of distortion
-   Bool_t          fDrawOrigin;  // draw origin
+   Bool_t fDrawCenter;           // Draw center of distortion.
+   Bool_t fDrawOrigin;           // Draw origin.
 
 public:
    TEveProjectionAxes(TEveProjectionManager* m);
    virtual ~TEveProjectionAxes();
 
-   TEveProjectionManager* GetManager(){ return fManager; }
+   TEveProjectionManager* GetManager(){
+      return fManager;
+   }
 
-   void            SetLabMode(ELabMode x)   { fLabMode = x;     }
-   ELabMode        GetLabMode()   const     { return fLabMode;  }
-   void            SetAxesMode(EAxesMode x) { fAxesMode = x;    }
+   void            SetLabMode(ELabMode x)   { fLabMode = x; }
+   ELabMode        GetLabMode()   const     { return fLabMode;}
+   void            SetAxesMode(EAxesMode x) { fAxesMode = x; }
    EAxesMode       GetAxesMode()   const    { return fAxesMode; }
 
-   void            SetDrawCenter(Bool_t x){ fDrawCenter = x;    }
-   Bool_t          GetDrawCenter() const  { return fDrawCenter; }
-   void            SetDrawOrigin(Bool_t x){ fDrawOrigin = x;    }
-   Bool_t          GetDrawOrigin() const  { return fDrawOrigin; }
-
-   virtual Bool_t  CanEditMainColor() const { return kTRUE; }
+   void            SetDrawCenter(Bool_t x)   { fDrawCenter = x; }
+   Bool_t          GetDrawCenter() const     { return fDrawCenter; }
+   void            SetDrawOrigin(Bool_t x)   { fDrawOrigin = x; }
+   Bool_t          GetDrawOrigin() const     { return fDrawOrigin; }
 
+   virtual Bool_t  CanEditMainColor() const  { return kTRUE;}
    virtual void    Paint(Option_t* option="");
-
    virtual void    ComputeBBox();
-
-   virtual const TGPicture* GetListTreeIcon(Bool_t open=kFALSE);
+   virtual const   TGPicture* GetListTreeIcon(Bool_t open=kFALSE);
 
    ClassDef(TEveProjectionAxes, 1); // Class to draw scales in non-linear projections.
 };
diff --git a/graf3d/eve/inc/TEveProjectionAxesEditor.h b/graf3d/eve/inc/TEveProjectionAxesEditor.h
index 1e04bc1..4cab687 100644
--- a/graf3d/eve/inc/TEveProjectionAxesEditor.h
+++ b/graf3d/eve/inc/TEveProjectionAxesEditor.h
@@ -31,7 +31,6 @@ protected:
 
    TGComboBox      *fLabMode;
    TGComboBox      *fAxesMode;
-   TEveGValuator   *fNdivisions;         // tick-mark number widget
 
    TGVerticalFrame *fCenterFrame;  // Parent frame for Center tab.
    TGCheckButton   *fDrawCenter;   // draw center widget
@@ -48,7 +47,6 @@ public:
 
    void DoLabMode(Int_t type);
    void DoAxesMode(Int_t type);
-   void DoNdivisions();
 
    void DoDrawCenter();
    void DoDrawOrigin();
diff --git a/graf3d/eve/inc/TEveProjectionAxesGL.h b/graf3d/eve/inc/TEveProjectionAxesGL.h
index ac3e78b..e6d969d 100644
--- a/graf3d/eve/inc/TEveProjectionAxesGL.h
+++ b/graf3d/eve/inc/TEveProjectionAxesGL.h
@@ -14,11 +14,9 @@
 
 #include "TGLObject.h"
 #include "TGLAxisPainter.h"
-#include <vector>
 
 class TEveProjectionAxes;
 class TEveProjection;
-class TGLFont;
 
 class TEveProjectionAxesGL : public TGLObject
 {
@@ -26,36 +24,27 @@ private:
    TEveProjectionAxesGL(const TEveProjectionAxesGL&);            // Not implemented
    TEveProjectionAxesGL& operator=(const TEveProjectionAxesGL&); // Not implemented
 
-   typedef std::pair<Float_t, Float_t>    Lab_t; // tick-mark <pos, value> pair
-   typedef std::vector<Lab_t>             LabVec_t;
-   typedef std::vector<Float_t>  TMVec_t; // vector od tick lines
-
-   mutable LabVec_t  fLabVec;    // list of tick-mark position-value pairs
-   mutable TMVec_t   fTickMarks;  // list of tick-mark position-value pairs
-
-   mutable TGLAxisPainter     fAxisPainter;
-   mutable TGLAxisAttrib      fAxisAtt;
-   void               DrawScales(Bool_t horizontal, TGLFont& font, Float_t tms, Float_t dtw) const;
-
-   Bool_t               GetRange(Int_t ax, Float_t frustMin, Float_t frustMax, Float_t& start, Float_t& en) const;
-   void               SplitInterval(Float_t x1, Float_t x2, Int_t axis, Int_t nLabels) const;
-   void               SplitIntervalByPos(Float_t min, Float_t max, Int_t axis, Int_t nLab)const;
-   void               SplitIntervalByVal(Float_t min, Float_t max, Int_t axis, Int_t nLab)const;
-
+   void                 GetRange(Int_t ax, Float_t frustMin, Float_t frustMax, Float_t& start, Float_t& en) const;
+   void                 SplitInterval(Float_t x1, Float_t x2, Int_t axis) const;
+   void                 SplitIntervalByPos(Float_t min, Float_t max, Int_t axis)const;
+   void                 SplitIntervalByVal(Float_t min, Float_t max, Int_t axis)const;
+   void                 FilterOverlappingLabels(Int_t idx, Float_t ref) const;
 protected:
-   TEveProjectionAxes     *fM;  // model object.
-   mutable TEveProjection *fProjection; // cached model projection
+   TEveProjectionAxes     *fM;          // Model object.
+   mutable TEveProjection *fProjection; // Cached model projection
+   mutable TGLAxisPainter  fAxisPainter;
 
 public:
    TEveProjectionAxesGL();
    virtual ~TEveProjectionAxesGL() {}
 
-   virtual Bool_t  SetModel(TObject* obj, const Option_t* opt=0);
+   virtual Bool_t  SetModel(TObject* obj, const Option_t* opt = 0);
    virtual void    SetBBox();
    virtual void    DirectDraw(TGLRnrCtx & rnrCtx) const;
 
-   Bool_t IgnoreSizeForOfInterest() const { return kTRUE;}
-
+   Bool_t IgnoreSizeForOfInterest() const {
+      return kTRUE;
+   }
 
    ClassDef(TEveProjectionAxesGL, 0); // GL renderer class for TEveProjectionAxes.
 };
diff --git a/graf3d/eve/inc/TEveQuadSet.h b/graf3d/eve/inc/TEveQuadSet.h
index 334b04b..f4cc772 100644
--- a/graf3d/eve/inc/TEveQuadSet.h
+++ b/graf3d/eve/inc/TEveQuadSet.h
@@ -86,9 +86,9 @@ protected:
    static Int_t SizeofAtom(EQuadType_e qt);
 
 public:
-   TEveQuadSet(const Text_t* n="TEveQuadSet", const Text_t* t="");
+   TEveQuadSet(const char* n="TEveQuadSet", const char* t="");
    TEveQuadSet(EQuadType_e quadType, Bool_t valIsCol, Int_t chunkSize,
-               const Text_t* n="TEveQuadSet", const Text_t* t="");
+               const char* n="TEveQuadSet", const char* t="");
    virtual ~TEveQuadSet() {}
 
    void Reset(EQuadType_e quadType, Bool_t valIsCol, Int_t chunkSize);
diff --git a/graf3d/eve/inc/TEveScalableStraightLineSet.h b/graf3d/eve/inc/TEveScalableStraightLineSet.h
index 9ddac00..950f2f7 100644
--- a/graf3d/eve/inc/TEveScalableStraightLineSet.h
+++ b/graf3d/eve/inc/TEveScalableStraightLineSet.h
@@ -25,7 +25,7 @@ protected:
    Float_t       fScaleCenter[3];
 
 public:
-   TEveScalableStraightLineSet(const Text_t* n="ScalableStraightLineSet", const Text_t* t="");
+   TEveScalableStraightLineSet(const char* n="ScalableStraightLineSet", const char* t="");
    virtual ~TEveScalableStraightLineSet() {}
 
    void SetScaleCenter(Float_t x, Float_t y, Float_t z);
diff --git a/graf3d/eve/inc/TEveScene.h b/graf3d/eve/inc/TEveScene.h
index 22a4d94..414fd35 100644
--- a/graf3d/eve/inc/TEveScene.h
+++ b/graf3d/eve/inc/TEveScene.h
@@ -36,7 +36,7 @@ protected:
    Bool_t       fSmartRefresh;
 
 public:
-   TEveScene(const Text_t* n="TEveScene", const Text_t* t="");
+   TEveScene(const char* n="TEveScene", const char* t="");
    virtual ~TEveScene();
 
    virtual void CollectSceneParents(List_t& scenes);
@@ -48,7 +48,7 @@ public:
    TGLScenePad* GetGLScene() const { return fGLScene; }
    void SetGLScene(TGLScenePad* s) { fGLScene = s; }
 
-   virtual void SetName(const Text_t* n);
+   virtual void SetName(const char* n);
    virtual void Paint(Option_t* option = "");
 
    void DestroyElementRenderers(TEveElement* element);
@@ -73,7 +73,7 @@ private:
 protected:
 
 public:
-   TEveSceneList(const Text_t* n="TEveSceneList", const Text_t* t="");
+   TEveSceneList(const char* n="TEveSceneList", const char* t="");
    virtual ~TEveSceneList() {}
 
    void DestroyScenes();
diff --git a/graf3d/eve/inc/TEveSelection.h b/graf3d/eve/inc/TEveSelection.h
index 314ffd9..651f694 100644
--- a/graf3d/eve/inc/TEveSelection.h
+++ b/graf3d/eve/inc/TEveSelection.h
@@ -54,7 +54,7 @@ protected:
    void DoElementUnselect(SelMap_i entry);
 
 public:
-   TEveSelection(const Text_t* n="TEveSelection", const Text_t* t="");
+   TEveSelection(const char* n="TEveSelection", const char* t="");
    virtual ~TEveSelection() {}
 
    void SetHighlightMode();
diff --git a/graf3d/eve/inc/TEveStraightLineSet.h b/graf3d/eve/inc/TEveStraightLineSet.h
index 4b7797a..24df2b7 100644
--- a/graf3d/eve/inc/TEveStraightLineSet.h
+++ b/graf3d/eve/inc/TEveStraightLineSet.h
@@ -77,10 +77,12 @@ protected:
    Bool_t            fRnrMarkers;
    Bool_t            fRnrLines;
 
+   Bool_t            fDepthTest;
+
    Line_t*           fLastLine; //!
 
 public:
-   TEveStraightLineSet(const Text_t* n="StraightLineSet", const Text_t* t="");
+   TEveStraightLineSet(const char* n="StraightLineSet", const char* t="");
    virtual ~TEveStraightLineSet() {}
 
    virtual void SetLineColor(Color_t col) { SetMainColor(col); }
@@ -93,10 +95,12 @@ public:
 
    virtual Bool_t GetRnrMarkers() { return fRnrMarkers; }
    virtual Bool_t GetRnrLines()   { return fRnrLines;   }
+   virtual Bool_t GetDepthTest()  { return fDepthTest;   }
 
    virtual void SetRnrMarkers(Bool_t x) { fRnrMarkers = x; }
    virtual void SetRnrLines(Bool_t x)   { fRnrLines   = x; }
-
+   virtual void SetDepthTest(Bool_t x)  { fDepthTest   = x; }
+   
    virtual void CopyVizParams(const TEveElement* el);
    virtual void WriteVizParams(ostream& out, const TString& var);
 
diff --git a/graf3d/eve/inc/TEveStraightLineSetGL.h b/graf3d/eve/inc/TEveStraightLineSetGL.h
index 248e71b..6066ec7 100644
--- a/graf3d/eve/inc/TEveStraightLineSetGL.h
+++ b/graf3d/eve/inc/TEveStraightLineSetGL.h
@@ -34,6 +34,7 @@ public:
 
    virtual Bool_t SetModel(TObject* obj, const Option_t* opt=0);
    virtual void   SetBBox();
+   virtual void   Draw(TGLRnrCtx& rnrCtx) const;
    virtual void   DirectDraw(TGLRnrCtx& rnrCtx) const;
 
    // To support two-level selectionvirtual
diff --git a/graf3d/eve/inc/TEveText.h b/graf3d/eve/inc/TEveText.h
index 47cc22e..cb3f5ee 100644
--- a/graf3d/eve/inc/TEveText.h
+++ b/graf3d/eve/inc/TEveText.h
@@ -42,7 +42,7 @@ protected:
 
 
 public:
-   TEveText(const Text_t* txt="");
+   TEveText(const char* txt="");
    virtual ~TEveText() {}
 
    Int_t   GetFontSize() const { return fFontSize; }
@@ -53,8 +53,8 @@ public:
    void    SetFontFile(const char* name);
    void    SetFontMode(Int_t mode);
 
-   const   Text_t* GetText() const  { return fText.Data(); }
-   void    SetText(const Text_t* t) { fText = t; }
+   const   char* GetText() const  { return fText.Data(); }
+   void    SetText(const char* t) { fText = t; }
 
    Bool_t  GetLighting() const      { return fLighting; }
    void    SetLighting(Bool_t isOn) { fLighting = isOn; }
diff --git a/graf3d/eve/inc/TEveTextEditor.h b/graf3d/eve/inc/TEveTextEditor.h
index 210904c..67380ec 100644
--- a/graf3d/eve/inc/TEveTextEditor.h
+++ b/graf3d/eve/inc/TEveTextEditor.h
@@ -48,7 +48,7 @@ public:
 
    virtual void SetModel(TObject* obj);
 
-   void DoText(const Text_t*);
+   void DoText(const char*);
 
    void DoFontSize();
    void DoFontFile();
diff --git a/graf3d/eve/inc/TEveTrack.h b/graf3d/eve/inc/TEveTrack.h
index cb24234..0765dd5 100644
--- a/graf3d/eve/inc/TEveTrack.h
+++ b/graf3d/eve/inc/TEveTrack.h
@@ -49,6 +49,7 @@ protected:
    Int_t              fCharge;     // Charge in units of e0
    Int_t              fLabel;      // Simulation label
    Int_t              fIndex;      // Reconstruction index
+   Bool_t             fLockPoints; // Lock points that are currently in - do nothing in MakeTrack().
    vPathMark_t        fPathMarks;  // TEveVector of known points along the track
 
    TEveTrackPropagator *fPropagator;   // Pointer to shared render-style
@@ -80,32 +81,26 @@ public:
    const TEveVector& GetMomentum()    const { return fP;    }
    const TEveVector& GetEndMomentum() const { return fPEnd; }
 
-   Int_t GetPdg()    const   { return fPdg;   }
-   void  SetPdg(Int_t pdg)    { fPdg = pdg;    }
-   Int_t GetCharge() const   { return fCharge; }
-   void  SetCharge(Int_t chg) { fCharge = chg; }
-   Int_t GetLabel()  const   { return fLabel; }
-   void  SetLabel(Int_t lbl) { fLabel = lbl;  }
-   Int_t GetIndex()  const   { return fIndex; }
-   void  SetIndex(Int_t idx) { fIndex = idx;  }
+   Int_t GetPdg()    const    { return fPdg;    }
+   void  SetPdg(Int_t pdg)    { fPdg = pdg;     }
+   Int_t GetCharge() const    { return fCharge; }
+   void  SetCharge(Int_t chg) { fCharge = chg;  }
+   Int_t GetLabel()  const    { return fLabel;  }
+   void  SetLabel(Int_t lbl)  { fLabel = lbl;   }
+   Int_t GetIndex()  const    { return fIndex;  }
+   void  SetIndex(Int_t idx)  { fIndex = idx;   }
 
    void  AddPathMark(const TEvePathMark& pm) { fPathMarks.push_back(pm); }
    void  SortPathMarksByTime();
          vPathMark_t& RefPathMarks()       { return fPathMarks; }
    const vPathMark_t& RefPathMarks() const { return fPathMarks; }
 
-   //--------------------------------
+   void  PrintPathMarks(); // *MENU*
 
-   void ImportHits();              // *MENU*
-   void ImportClusters();          // *MENU*
-   void ImportClustersFromIndex(); // *MENU*
-   void ImportKine();              // *MENU*
-   void ImportKineWithArgs(Bool_t importMother=kTRUE, Bool_t impDaugters=kTRUE,
-                           Bool_t colorPdg    =kTRUE, Bool_t recurse    =kTRUE); // *MENU*
-   void PrintKineStack();          // *MENU*
-   void PrintPathMarks();          // *MENU*
+   void   SetLockPoints(Bool_t l) { fLockPoints = l;    }
+   Bool_t GetLockPoints()   const { return fLockPoints; }
 
-   //--------------------------------
+   //-------------------------------------------------------------------
 
    virtual void SecSelected(TEveTrack*); // *SIGNAL*
    virtual void SetLineStyle(Style_t lstyle);
@@ -164,7 +159,7 @@ protected:
 
 public:
    TEveTrackList(TEveTrackPropagator* rs=0);
-   TEveTrackList(const Text_t* name, TEveTrackPropagator* rs=0);
+   TEveTrackList(const char* name, TEveTrackPropagator* rs=0);
    virtual ~TEveTrackList();
 
    void  MakeTracks(Bool_t recurse=kTRUE);
@@ -213,14 +208,11 @@ public:
    Float_t GetMaxP()  const { return fMaxP;  }
    Float_t GetLimP()  const { return fLimP;  }
 
-   //--------------------------------
+   //-------------------------------------------------------------------
 
    TEveTrack* FindTrackByLabel(Int_t label); // *MENU*
    TEveTrack* FindTrackByIndex(Int_t index); // *MENU*
 
-   void ImportHits();     // *MENU*
-   void ImportClusters(); // *MENU*
-
    virtual void CopyVizParams(const TEveElement* el);
    virtual void WriteVizParams(ostream& out, const TString& var);
 
diff --git a/graf3d/eve/inc/TEveTrackPropagator.h b/graf3d/eve/inc/TEveTrackPropagator.h
index a80c09c..f7d0bcf 100644
--- a/graf3d/eve/inc/TEveTrackPropagator.h
+++ b/graf3d/eve/inc/TEveTrackPropagator.h
@@ -45,8 +45,6 @@ public:
 
    virtual TEveVector GetField(const TEveVector &v) const { return GetField(v.fX, v.fY, v.fZ);}
    virtual TEveVector GetField(Float_t x, Float_t y, Float_t z) const = 0;
-  
-   virtual Float_t    GetMaxFieldMag() const = 0;
 
    ClassDef(TEveMagField, 0); // Abstract interface to magnetic field
 };
@@ -62,15 +60,13 @@ protected:
    TEveVector fB;
 
 public:
- TEveMagFieldConst(Float_t x, Float_t y, Float_t z) : TEveMagField(), fB(x, y, z)
+   TEveMagFieldConst(Float_t x, Float_t y, Float_t z) : TEveMagField(), fB(x, y, z)
    { fFieldConstant = kTRUE; }
    virtual ~TEveMagFieldConst() {}
 
    using   TEveMagField::GetField;
    virtual TEveVector GetField(Float_t /*x*/, Float_t /*y*/, Float_t /*z*/) const { return fB; }
 
-   virtual Float_t    GetMaxFieldMag() const { return fB.Mag(); }
-
    ClassDef(TEveMagFieldConst, 0); // Interface to constant magnetic field.
 };
 
@@ -87,7 +83,7 @@ protected:
    Float_t    fR2;
 
 public:
-   TEveMagFieldDuo(Float_t r, Float_t bIn, Float_t bOut) : TEveMagField(), 
+   TEveMagFieldDuo(Float_t r, Float_t bIn, Float_t bOut) : TEveMagField(),
      fBIn(0,0,bIn), fBOut(0,0,bOut), fR2(r*r)
    {
       fFieldConstant = kFALSE;
@@ -98,8 +94,6 @@ public:
    virtual TEveVector GetField(Float_t x, Float_t y, Float_t /*z*/) const
    { return  ((x*x+y*y)<fR2) ? fBIn : fBOut; }
 
-   virtual Float_t    GetMaxFieldMag() const { return TMath::Max(fBIn.Mag(), fBOut.Mag()); }
-
    ClassDef(TEveMagFieldDuo, 0); // Interface to magnetic field with two different values depending of radius.
 };
 
@@ -119,6 +113,8 @@ public:
       Int_t   fCharge;   // Charge of tracked particle.
       Float_t fMinAng;   // Minimal angular step between two helix points.
       Float_t fDelta;    // Maximal error at the mid-point of the line connecting two helix points.
+      Float_t fMaxStep;  // Maximum allowed step size.
+      Float_t fCurrentStep;
 
       Float_t fPhi;      // Accumulated angle to check fMaxOrbs by propagator.
       Bool_t  fValid;    // Corner case pT~0 or B~0, possible in variable mag field.
@@ -137,18 +133,18 @@ public:
       TEveVector fPt, fPl;  // Transverse and longitudinal momentum.
       Float_t fPtMag;       // Magnitude of pT
       Float_t fPlDir;       // Momentum parallel to mag field.
-      Float_t fTStep;       // Transverse step arc-length in cm.
+      Float_t fLStep;       // Transverse step arc-length in cm.
 
       // ----------------------------------------------------------------
 
       Helix_t();
 
-      void UpdateHelix(const TEveVector & p, const TEveVector& b, Bool_t fullUpdate, Float_t fraction = -1);
-      void UpdateRG   (const TEveVector & p, const TEveVector& b, Float_t bMax = -1, Float_t maxStep = -1);
+      void UpdateHelix(const TEveVector & p, const TEveVector& b, Bool_t fullUpdate);
+      void UpdateRK   (const TEveVector & p, const TEveVector& b);
       void Step  (const TEveVector4& v, const TEveVector& p, TEveVector4& vOut, TEveVector& pOut);
 
-      Float_t GetStep()  { return fTStep * TMath::Sqrt(1 + fLam*fLam); }
-      Float_t GetStep2() { return fTStep * fTStep * (1 + fLam*fLam);   }
+      Float_t GetStep()  { return fLStep * TMath::Sqrt(1 + fLam*fLam); }
+      Float_t GetStep2() { return fLStep * fLStep * (1 + fLam*fLam);   }
    };
 
    enum EStepper_e    { kHelix, kRungeKutta };
@@ -157,7 +153,7 @@ private:
    TEveTrackPropagator& operator=(const TEveTrackPropagator&); // Not implemented
 
 protected:
-   EStepper_e              fStepper; 
+   EStepper_e               fStepper;
 
    TEveMagField*            fMagFieldObj;
 
@@ -168,8 +164,6 @@ protected:
    // Helix limits
    Float_t                  fMaxOrbs;       // Maximal angular path of tracks' orbits (1 ~ 2Pi).
 
-   Float_t                  fMaxStepRG;     // Maximum step size in stepper RungeKuta.
-
    // Path-mark / first-vertex control
    Bool_t                   fEditPathMarks; // Show widgets for path-mark control in GUI editor.
    Bool_t                   fFitDaughters;  // Pass through daughter creation points when extrapolating a track.
@@ -192,7 +186,7 @@ protected:
    Helix_t                  fH;             // Helix.
 
    void    RebuildTracks();
-   void    Step(TEveVector4 &v, TEveVector &p, TEveVector4 &vOut, TEveVector &pOut, Float_t fraction);
+   void    Step(TEveVector4 &v, TEveVector &p, TEveVector4 &vOut, TEveVector &pOut);
 
    Bool_t  LoopToVertex(TEveVector& v, TEveVector& p);
    void    LoopToBounds(TEveVector& p);
@@ -210,7 +204,7 @@ protected:
    Bool_t PointOverVertex(const TEveVector4& v0, const TEveVector4& v);
 
 public:
-   TEveTrackPropagator(const Text_t* n="TEveTrackPropagator", const Text_t* t="",
+   TEveTrackPropagator(const char* n="TEveTrackPropagator", const char* t="",
                        TEveMagField* field=0);
    virtual ~TEveTrackPropagator();
 
@@ -242,6 +236,7 @@ public:
    void   SetMaxOrbs(Float_t x);
    void   SetMinAng(Float_t x);
    void   SetDelta(Float_t x);
+   void   SetMaxStep(Float_t x);
 
    void   SetEditPathMarks(Bool_t x) { fEditPathMarks = x; }
    void   SetRnrDaughters(Bool_t x);
@@ -264,6 +259,7 @@ public:
    Float_t GetMaxOrbs()  const { return fMaxOrbs;  }
    Float_t GetMinAng()   const { return fH.fMinAng;   }
    Float_t GetDelta()    const { return fH.fDelta;    }
+   Float_t GetMaxStep()  const { return fH.fMaxStep;  }
 
    Bool_t  GetEditPathMarks() const { return fEditPathMarks; }
    Bool_t  GetRnrDaughters()  const { return fRnrDaughters;  }
diff --git a/graf3d/eve/inc/TEveTrans.h b/graf3d/eve/inc/TEveTrans.h
index 5d5705a..d6578c0 100644
--- a/graf3d/eve/inc/TEveTrans.h
+++ b/graf3d/eve/inc/TEveTrans.h
@@ -127,7 +127,7 @@ public:
    // Cardan angle interface
 
    void SetRotByAngles(Float_t a1, Float_t a2, Float_t a3);
-   void SetRotByAnyAngles(Float_t a1, Float_t a2, Float_t a3, const Text_t* pat);
+   void SetRotByAnyAngles(Float_t a1, Float_t a2, Float_t a3, const char* pat);
    void GetRotAngles(Float_t* x) const;
 
    // Scaling
diff --git a/graf3d/eve/inc/TEveTreeTools.h b/graf3d/eve/inc/TEveTreeTools.h
index 926419e..64fa17b 100644
--- a/graf3d/eve/inc/TEveTreeTools.h
+++ b/graf3d/eve/inc/TEveTreeTools.h
@@ -28,7 +28,7 @@ protected:
    TEventList* fEvList;
    TList       fInput;
 public:
-   TEveSelectorToEventList(TEventList* evl, const Text_t* sel);
+   TEveSelectorToEventList(TEventList* evl, const char* sel);
 
    virtual Int_t  Version() const { return 1; }
    virtual Bool_t Process(Long64_t entry);
@@ -82,11 +82,11 @@ protected:
 
 public:
    TEvePointSelector(TTree* t=0, TEvePointSelectorConsumer* c=0,
-                     const Text_t* vexp="", const Text_t* sel="");
+                     const char* vexp="", const char* sel="");
    virtual ~TEvePointSelector() {}
 
-   virtual Long64_t Select(const Text_t* selection=0);
-   virtual Long64_t Select(TTree* t, const Text_t* selection=0);
+   virtual Long64_t Select(const char* selection=0);
+   virtual Long64_t Select(TTree* t, const char* selection=0);
    virtual void  TakeAction();
 
 
@@ -96,14 +96,14 @@ public:
    TEvePointSelectorConsumer* GetConsumer() const { return fConsumer; }
    void SetConsumer(TEvePointSelectorConsumer* c) { fConsumer = c; }
 
-   const Text_t* GetVarexp() const { return fVarexp; }
-   void SetVarexp(const Text_t* v) { fVarexp = v; }
+   const char* GetVarexp() const { return fVarexp; }
+   void SetVarexp(const char* v) { fVarexp = v; }
 
-   const Text_t* GetSelection() const { return fSelection; }
-   void SetSelection(const Text_t* s) { fSelection = s; }
+   const char* GetSelection() const { return fSelection; }
+   void SetSelection(const char* s) { fSelection = s; }
 
-   const Text_t* GetSubIdExp() const { return fSubIdExp; }
-   void SetSubIdExp(const Text_t* s) { fSubIdExp = s; }
+   const char* GetSubIdExp() const { return fSubIdExp; }
+   void SetSubIdExp(const char* s) { fSubIdExp = s; }
 
    Int_t GetSubIdNum() const { return fSubIdNum; }
 
diff --git a/graf3d/eve/inc/TEveUtil.h b/graf3d/eve/inc/TEveUtil.h
index 09f7a7e..2e07e6b 100644
--- a/graf3d/eve/inc/TEveUtil.h
+++ b/graf3d/eve/inc/TEveUtil.h
@@ -44,10 +44,10 @@ public:
    static void   SetupEnvironment();
    static void   SetupGUI();
 
-   static Bool_t CheckMacro(const Text_t* mac);
-   static void   AssertMacro(const Text_t* mac);
-   static void   Macro(const Text_t* mac);
-   static void   LoadMacro(const Text_t* mac);
+   static Bool_t CheckMacro(const char* mac);
+   static void   AssertMacro(const char* mac);
+   static void   Macro(const char* mac);
+   static void   LoadMacro(const char* mac);
 
    // Color management
 
@@ -55,7 +55,7 @@ public:
    static void     ColorFromIdx(Color_t ci, UChar_t col[4], UChar_t transparency);
    static void     ColorFromIdx(Float_t f1, Color_t c1, Float_t f2, Color_t c2,
                                 UChar_t col[4], Bool_t alpha=kTRUE);
-   static Color_t* FindColorVar(TObject* obj, const Text_t* varname);
+   static Color_t* FindColorVar(TObject* obj, const char* varname);
 
    static void     SetColorBrightness(Float_t value, Bool_t full_redraw=kFALSE);
 
diff --git a/graf3d/eve/inc/TEveVSD.h b/graf3d/eve/inc/TEveVSD.h
index cad0d82..482d1fc 100644
--- a/graf3d/eve/inc/TEveVSD.h
+++ b/graf3d/eve/inc/TEveVSD.h
@@ -47,7 +47,7 @@ public:
    TEveMCRecCrossRef  fGI, *fpGI;   //!
 
 public:
-   TEveVSD(const Text_t* name="TEveVSD", const Text_t* title="");
+   TEveVSD(const char* name="TEveVSD", const char* title="");
 
    virtual void SetDirectory(TDirectory* dir);
 
@@ -60,8 +60,8 @@ public:
    virtual void WriteTrees();
    virtual void LoadTrees();
 
-   virtual void LoadVSD(const Text_t* vsd_file_name,
-                        const Text_t* dir_name="Event0");
+   virtual void LoadVSD(const char* vsd_file_name,
+                        const char* dir_name="Event0");
 
    static void DisableTObjectStreamersForVSDStruct();
 
diff --git a/graf3d/eve/inc/TEveVSDStructs.h b/graf3d/eve/inc/TEveVSDStructs.h
index 5656568..7f54c71 100644
--- a/graf3d/eve/inc/TEveVSDStructs.h
+++ b/graf3d/eve/inc/TEveVSDStructs.h
@@ -326,15 +326,31 @@ public:
 // TEveRecKink
 /******************************************************************************/
 
-class TEveRecKink : public TEveRecTrack
+class TEveRecKink : public TObject
 {
 public:
-   Int_t       fLabelSec;  // Label of the secondary track
-   TEveVector  fVEnd;      // End vertex: last point on the primary track
-   TEveVector  fVKink;     // Kink vertex: reconstructed position of the kink
-   TEveVector  fPSec;      // Momentum of secondary track
 
-   TEveRecKink() : TEveRecTrack(), fLabelSec(0), fVEnd(), fVKink(), fPSec() {}
+   TEveVector  fVKink;          // Kink vertex: reconstructed position of the kink
+   TEveVector  fPMother;        // Momentum of the mother track
+   TEveVector  fVMother;        // Vertex of the mother track
+   TEveVector  fPDaughter;      // Momentum of the daughter track
+   TEveVector  fVDaughter;      // Vertex of the daughter track
+   Double32_t  fKinkAngle[3];   // three angles
+   Int_t       fSign;           // sign of the track
+   Int_t       fStatus;         // Status as exported from reconstruction
+
+   // Data from simulation
+   Int_t       fKinkLabel[2];   // Labels of the mother and daughter tracks
+   Int_t       fKinkIndex[2];   // Indices of the mother and daughter tracks
+   Int_t       fKinkPdg[2];     // PDG code of mother and daughter.
+
+   TEveRecKink() : fVKink(), fPMother(), fVMother(), fPDaughter(), fVDaughter(), fSign(0), fStatus(0)
+   {
+     fKinkAngle[0] = fKinkAngle[1] = fKinkAngle[2] = 0;
+     fKinkLabel[0] = fKinkLabel[1] = 0;
+     fKinkIndex[0] = fKinkIndex[1] = 0;
+     fKinkPdg[0]   = fKinkPdg[1]   = 0;
+   }
    virtual ~TEveRecKink() {}
 
    ClassDef(TEveRecKink, 1); // Reconstructed kink (also used in VSD).
diff --git a/graf3d/eve/inc/TEveViewer.h b/graf3d/eve/inc/TEveViewer.h
index bd3cac8..4263ceb 100644
--- a/graf3d/eve/inc/TEveViewer.h
+++ b/graf3d/eve/inc/TEveViewer.h
@@ -18,6 +18,8 @@
 class TGWindow;
 class TGedEditor;
 class TGLViewer;
+class TGLSAViewer;
+class TGLEmbeddedViewer;
 class TGLPhysicalShape;
 
 class TEveScene;
@@ -37,7 +39,7 @@ protected:
    TGFrame   *fGLViewerFrame;
 
 public:
-   TEveViewer(const Text_t* n="TEveViewer", const Text_t* t="");
+   TEveViewer(const char* n="TEveViewer", const char* t="");
    virtual ~TEveViewer();
 
    virtual void PreUndock();
@@ -45,8 +47,10 @@ public:
 
    TGLViewer* GetGLViewer() const { return fGLViewer; }
    void SetGLViewer(TGLViewer* viewer, TGFrame* frame);
-   void SpawnGLViewer(TGedEditor* ged);
-   void SpawnGLEmbeddedViewer(Int_t border=0);
+
+   TGLSAViewer*       SpawnGLViewer(TGedEditor* ged);
+   TGLEmbeddedViewer* SpawnGLEmbeddedViewer(Int_t border=0);
+
    void Redraw(Bool_t resetCameras=kFALSE);
 
    virtual void AddScene(TEveScene* scene);
@@ -78,7 +82,7 @@ protected:
    Bool_t       fShowTooltip;
 
 public:
-   TEveViewerList(const Text_t* n="TEveViewerList", const Text_t* t="");
+   TEveViewerList(const char* n="TEveViewerList", const char* t="");
    virtual ~TEveViewerList() {}
 
    virtual void AddElement(TEveElement* el);
@@ -91,6 +95,7 @@ public:
 
    void RepaintChangedViewers(Bool_t resetCameras, Bool_t dropLogicals);
    void RepaintAllViewers(Bool_t resetCameras, Bool_t dropLogicals);
+   void DeleteAnnotations();
 
    void SceneDestructing(TEveScene* scene);
 
diff --git a/graf3d/eve/inc/TEveWindow.h b/graf3d/eve/inc/TEveWindow.h
index a2a1817..0191bd9 100644
--- a/graf3d/eve/inc/TEveWindow.h
+++ b/graf3d/eve/inc/TEveWindow.h
@@ -41,18 +41,26 @@ class TEveCompositeFrame : public TGCompositeFrame
    friend class TEveWindow;
    friend class TEveWindowManager;
 
+public:
+   typedef TGFrame* (*IconBarCreator_foo)(TEveCompositeFrame*, TGCompositeFrame*, Int_t);
+
 private:
    TEveCompositeFrame(const TEveCompositeFrame&);            // Not implemented
    TEveCompositeFrame& operator=(const TEveCompositeFrame&); // Not implemented
 
+   static IconBarCreator_foo fgIconBarCreator;
+   static UInt_t             fgTopFrameHeight;
+   static UInt_t             fgMiniBarHeight;
+   static Bool_t             fgAllowTopFrameCollapse;
+
 protected:
    TGCompositeFrame  *fTopFrame;
    TGTextButton      *fToggleBar;
    TGTextButton      *fTitleBar;
-   TGTextButton      *fIconBar;
+   TGFrame           *fIconBar;
    TGLayoutHints     *fEveWindowLH;
 
-   TGButton          *fMiniBar;
+   TGFrame           *fMiniBar;
 
    TEveElement       *fEveParent;
    TEveWindow        *fEveWindow;
@@ -83,12 +91,15 @@ public:
    virtual void HideAllDecorations();
    virtual void ShowNormalDecorations();
 
-   void ReplaceIconBox(TGFrame* icon_box);
-
    void ActionPressed();
    void FlipTitleBarState();
    void TitleBarClicked();
 
+   static void SetupFrameMarkup(IconBarCreator_foo creator,
+                                UInt_t top_frame_height   = 14,
+                                UInt_t mini_bar_height    = 4,
+                                Bool_t allow_top_collapse = kTRUE);
+
    ClassDef(TEveCompositeFrame, 0); // Composite frame containing eve-window-controls and eve-windows.
 };
 
@@ -215,7 +226,7 @@ protected:
    virtual void PreDeleteElement();
 
 public:
-   TEveWindow(const Text_t* n="TEveWindow", const Text_t* t="");
+   TEveWindow(const char* n="TEveWindow", const char* t="");
    virtual ~TEveWindow();
 
    virtual void NameTitleChanged();
@@ -297,7 +308,7 @@ protected:
    virtual void SetCurrent(Bool_t curr);
 
 public:
-   TEveWindowSlot(const Text_t* n="TEveWindowSlot", const Text_t* t="");
+   TEveWindowSlot(const char* n="TEveWindowSlot", const char* t="");
    virtual ~TEveWindowSlot();
 
    virtual TGFrame* GetGUIFrame();
@@ -308,7 +319,7 @@ public:
    TEveWindowFrame*  MakeFrame(TGFrame* frame=0);
 
    TGCompositeFrame* StartEmbedding();
-   TEveWindowFrame*  StopEmbedding(const Text_t* name=0);
+   TEveWindowFrame*  StopEmbedding(const char* name=0);
 
    ClassDef(TEveWindowSlot, 0); // An unoccupied eve-window slot.
 };
@@ -328,7 +339,7 @@ protected:
    TGFrame         *fGUIFrame;
 
 public:
-   TEveWindowFrame(TGFrame* frame, const Text_t* n="TEveWindowFrame", const Text_t* t="");
+   TEveWindowFrame(TGFrame* frame, const char* n="TEveWindowFrame", const char* t="");
    virtual ~TEveWindowFrame();
 
    virtual TGFrame* GetGUIFrame() { return fGUIFrame; }
@@ -353,7 +364,7 @@ protected:
    TGPack          *fPack;
 
 public:
-   TEveWindowPack(TGPack* p, const Text_t* n="TEveWindowPack", const Text_t* t="");
+   TEveWindowPack(TGPack* p, const char* n="TEveWindowPack", const char* t="");
    virtual ~TEveWindowPack();
 
    virtual TGFrame*        GetGUIFrame();
@@ -387,7 +398,7 @@ protected:
    TGTab           *fTab;
 
 public:
-   TEveWindowTab(TGTab* tab, const Text_t* n="TEveWindowTab", const Text_t* t="");
+   TEveWindowTab(TGTab* tab, const char* n="TEveWindowTab", const char* t="");
    virtual ~TEveWindowTab();
 
    virtual TGFrame*        GetGUIFrame();
diff --git a/graf3d/eve/inc/TEveWindowManager.h b/graf3d/eve/inc/TEveWindowManager.h
index 86fdb6b..4031d9f 100644
--- a/graf3d/eve/inc/TEveWindowManager.h
+++ b/graf3d/eve/inc/TEveWindowManager.h
@@ -32,7 +32,7 @@ protected:
    void DestroyWindowRecursively(TEveWindow* window);
 
 public:
-   TEveWindowManager(const Text_t* n="TEveWindowManager", const Text_t* t="");
+   TEveWindowManager(const char* n="TEveWindowManager", const char* t="");
    virtual ~TEveWindowManager();
 
    void SelectWindow(TEveWindow* w);
diff --git a/graf3d/eve/src/TEveBoxSet.cxx b/graf3d/eve/src/TEveBoxSet.cxx
index 04b2288..7705b26 100644
--- a/graf3d/eve/src/TEveBoxSet.cxx
+++ b/graf3d/eve/src/TEveBoxSet.cxx
@@ -47,7 +47,7 @@
 ClassImp(TEveBoxSet);
 
 //______________________________________________________________________________
-TEveBoxSet::TEveBoxSet(const Text_t* n, const Text_t* t) :
+TEveBoxSet::TEveBoxSet(const char* n, const char* t) :
    TEveDigitSet  (n, t),
 
    fBoxType      (kBT_Undef),
diff --git a/graf3d/eve/src/TEveCalo.cxx b/graf3d/eve/src/TEveCalo.cxx
index c2f65c1..2c6cc5f 100644
--- a/graf3d/eve/src/TEveCalo.cxx
+++ b/graf3d/eve/src/TEveCalo.cxx
@@ -42,7 +42,7 @@
 ClassImp(TEveCaloViz);
 
 //______________________________________________________________________________
-TEveCaloViz::TEveCaloViz(TEveCaloData* data, const Text_t* n, const Text_t* t) :
+TEveCaloViz::TEveCaloViz(TEveCaloData* data, const char* n, const char* t) :
    TEveElement(),
    TNamed(n, t),
    TEveProjectable(),
@@ -83,7 +83,7 @@ TEveCaloViz::~TEveCaloViz()
    // Destructor.
 
    if (fPalette) fPalette->DecRefCount();
-   if (fData) fData->DecRefCount();
+   if (fData) fData->DecRefCount(this);
 }
 
 //______________________________________________________________________________
@@ -134,10 +134,11 @@ void TEveCaloViz::SetPlotEt(Bool_t isEt)
 {
    // Set E/Et plot.
 
-  fPlotEt=isEt;
-  fPalette->SetLimits(0, TMath::CeilNint(fData->GetMaxVal(fPlotEt)));
+   fPlotEt=isEt;
+   if (fPalette)
+      fPalette->SetLimits(0, TMath::CeilNint(fData->GetMaxVal(fPlotEt)));
 
-  InvalidateCellIdCache();
+   InvalidateCellIdCache();
 }
 
 //______________________________________________________________________________
@@ -374,17 +375,17 @@ void TEveCaloViz::SetupColorHeight(Float_t value, Int_t slice, Float_t& outH) co
 ClassImp(TEveCalo3D);
 
 
-TEveCalo3D::TEveCalo3D(TEveCaloData* d, const Text_t* n, const Text_t* t): 
+TEveCalo3D::TEveCalo3D(TEveCaloData* d, const char* n, const char* t): 
    TEveCaloViz(d, n, t),
-   fRnrEndCapFrame(kTRUE),
-   fRnrBarrelFrame(kTRUE)
+
+   fRnrEndCapFrame    (kTRUE),
+   fRnrBarrelFrame    (kTRUE),
+   fFrameColor        (kGray+1),
+   fFrameTransparency (80)
 {
 
    // Constructor.
 
-   fFrameColor = kGray+1;
-   fMainTransparency= 50;
-
    fMainColorPtr = &fFrameColor;
 }
 
@@ -429,7 +430,7 @@ void TEveCalo3D::ComputeBBox()
 ClassImp(TEveCalo2D);
 
 //______________________________________________________________________________
-TEveCalo2D::TEveCalo2D(const Text_t* n, const Text_t* t):
+TEveCalo2D::TEveCalo2D(const char* n, const char* t):
    TEveCaloViz(0, n, t),
    TEveProjected(),
    fOldProjectionType(TEveProjection::kPT_Unknown)
@@ -574,7 +575,7 @@ void TEveCalo2D::ComputeBBox()
 ClassImp(TEveCaloLego);
 
 //______________________________________________________________________________
-TEveCaloLego::TEveCaloLego(TEveCaloData* d, const Text_t* n, const Text_t* t):
+TEveCaloLego::TEveCaloLego(TEveCaloData* d, const char* n, const char* t):
    TEveCaloViz(d, n, t),
 
    fTopViewUseMaxColor(kTRUE),
@@ -634,34 +635,35 @@ void TEveCaloLego::ComputeBBox()
 
    // Float_t[6] X(min,max), Y(min,max), Z(min,max)
 
-   if (fData)
-   {
-      Float_t ex = 1.2;
 
-      Float_t a = 0.5*ex;
+   Float_t ex = 1.2;
 
-      fBBox[0] = -a;
-      fBBox[1] =  a;
-      fBBox[2] = -a;
-      fBBox[3] =  a;
+   Float_t a = 0.5*ex;
 
-      // scaling is relative to shortest XY axis
-      Double_t em, eM, pm, pM;
-      fData->GetEtaLimits(em, eM);
-      fData->GetPhiLimits(pm, pM);
-      Double_t r = (eM-em)/(pM-pm);
-      if (r<1)
-      {
-         fBBox[2] /= r;
-         fBBox[3] /= r;
-      }
-      else
-      {
-         fBBox[0] *= r;
-         fBBox[1] *= r;
-      }
+   fBBox[0] = -a;
+   fBBox[1] =  a;
+   fBBox[2] = -a;
+   fBBox[3] =  a;
 
-      fBBox[4] =  fMaxTowerH*(1-ex);
-      fBBox[5] =  fMaxTowerH*ex;
+   // scaling is relative to shortest XY axis
+   Double_t em, eM, pm, pM;
+   fData->GetEtaLimits(em, eM);
+   fData->GetPhiLimits(pm, pM);
+   Double_t r = (eM-em)/(pM-pm);
+   if (r<1)
+   {
+      fBBox[2] /= r;
+      fBBox[3] /= r;
+   }
+   else
+   {
+      fBBox[0] *= r;
+      fBBox[1] *= r;
    }
+
+   fBBox[4] =  0;
+   if (fScaleAbs)
+      fBBox[5] = fMaxTowerH;
+   else 
+      fBBox[5] = 1;
 }
diff --git a/graf3d/eve/src/TEveCalo3DGL.cxx b/graf3d/eve/src/TEveCalo3DGL.cxx
index 789adb5..b82d96b 100644
--- a/graf3d/eve/src/TEveCalo3DGL.cxx
+++ b/graf3d/eve/src/TEveCalo3DGL.cxx
@@ -260,6 +260,19 @@ void TEveCalo3DGL::RenderGrid(TGLRnrCtx & rnrCtx) const
 
    if (rnrCtx.Highlight() || rnrCtx.Selection()) return;
 
+   Bool_t transparent_p = fM->fFrameTransparency > 0;
+
+   if (transparent_p)
+   {
+      TGLUtil::ColorTransparency(fM->fFrameColor, fM->fFrameTransparency);
+
+      glPushAttrib(GL_ENABLE_BIT | GL_DEPTH_BUFFER_BIT);
+
+      glDepthMask(GL_FALSE);
+      glEnable(GL_BLEND);
+      glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+   }
+
    TGLCapabilitySwitch lights_off(GL_LIGHTING, kFALSE);
 
    glBegin(GL_LINES);
@@ -279,6 +292,13 @@ void TEveCalo3DGL::RenderGrid(TGLRnrCtx & rnrCtx) const
    }
 
    glEnd();
+
+   if (transparent_p)
+   {
+      glPopAttrib();
+
+      TGLUtil::ColorTransparency(fM->fFrameColor, fM->fMainTransparency);
+   }
 }
 
 //______________________________________________________________________________
diff --git a/graf3d/eve/src/TEveCaloLegoGL.cxx b/graf3d/eve/src/TEveCaloLegoGL.cxx
index 0e90d3e..66c7dd0 100644
--- a/graf3d/eve/src/TEveCaloLegoGL.cxx
+++ b/graf3d/eve/src/TEveCaloLegoGL.cxx
@@ -9,24 +9,22 @@
  * For the list of contributors see $ROOTSYS/README/CREDITS.             *
  *************************************************************************/
 
-#include "TEveCaloLegoGL.h"
-#include "TEveCalo.h"
-#include "TEveRGBAPalette.h"
-
-#include "TGLIncludes.h"
+#include "TAxis.h"
+#include "TH2.h"
+#include "THLimitsFinder.h"
 
 #include "TGLRnrCtx.h"
 #include "TGLSelectRecord.h"
 #include "TGLScene.h"
 #include "TGLCamera.h"
-#include "TGLContext.h"
 #include "TGLUtil.h"
 
-#include "TAxis.h"
-#include "TObjString.h"
 
-#include "TH2.h"
-#include "THLimitsFinder.h"
+#include "TEveCaloLegoGL.h"
+#include "TEveCalo.h"
+#include "TEveRGBAPalette.h"
+
+#include <algorithm>
 
 //______________________________________________________________________________
 // OpenGL renderer class for TEveCaloLego.
@@ -36,49 +34,39 @@ ClassImp(TEveCaloLegoGL);
 
 //______________________________________________________________________________
 TEveCaloLegoGL::TEveCaloLegoGL() :
-   TGLObject(),
-
-   fDataMax(0),
+      TGLObject(),
 
-   fEtaAxis(0),
-   fPhiAxis(0),
-   fBinStep(1),
+      fDataMax(0),
 
-   fXAxisAtt(),
-   fYAxisAtt(),
-   fZAxisAtt(),
-   fAxisPainter(),
+      fEtaAxis(0),
+      fPhiAxis(0),
+      fZAxis(0),
+      fBinStep(1),
 
-   fDLCacheOK(kFALSE),
-   fCells3D(kTRUE),
-   fM(0)
+      fM(0),
+      fDLCacheOK(kFALSE),
+      fCells3D(kTRUE)
 {
    // Constructor.
 
    fDLCache = kFALSE;
 
-   // modes for different levels of zoom in/out.
+   // need to set dummy parent, else loose settings in rebin
 
-   fXAxisAtt.SetTMNDim(2);
-   fXAxisAtt.SetTextAlign(TGLFont::kCenterDown);
-   fXAxisAtt.SetNdivisions(710);
-   fXAxisAtt.SetLabelSize(0.03);
-   fXAxisAtt.SetTitleSize(0.03);
+   // X axis
+   fEtaAxis = new TAxis();
 
-   fYAxisAtt = fXAxisAtt;
-   fYAxisAtt.RefDir().Set(0., 1., 0.);
-   fYAxisAtt.SetNdivisions(510);
+   // Y axis
+   fPhiAxis = new TAxis();
 
-   fZAxisAtt.RefDir().Set(0., 0., 1.);
-   fZAxisAtt.SetTextAlign(TGLFont::kLeft);
-   fZAxisAtt.SetRelativeFontSize(kTRUE);
-   fZAxisAtt.SetLabelSize(0.03);
-   fZAxisAtt.SetTitle("Et");
-   fZAxisAtt.SetTitleUnits("GeV");
-   fZAxisAtt.SetTitleSize(0.03);
+   // fZAxis
+   fZAxis = new TAxis();
+   fZAxis->SetLabelSize(0.05);
+   fZAxis->SetTitleSize(0.05);
+   fZAxis->SetTickLength(1);
+   fZAxis->SetLabelOffset(0.5);
 
-   fEtaAxis = new TAxis();
-   fPhiAxis = new TAxis();
+    fAxisPainter.SetFontMode(TGLFont::kPixmap);
 }
 
 //______________________________________________________________________________
@@ -87,6 +75,10 @@ TEveCaloLegoGL::~TEveCaloLegoGL()
    // Destructor.
 
    DLCachePurge();
+
+   delete fEtaAxis;
+   delete fPhiAxis;
+   delete fZAxis;
 }
 
 //______________________________________________________________________________
@@ -98,6 +90,7 @@ Bool_t TEveCaloLegoGL::SetModel(TObject* obj, const Option_t* /*opt*/)
       fM = dynamic_cast<TEveCaloLego*>(obj);
       return kTRUE;
    }
+
    return kFALSE;
 }
 
@@ -125,12 +118,9 @@ void TEveCaloLegoGL::DLCachePurge()
 {
    // Unregister all display-lists.
 
-   if ( ! fDLMap.empty())
-   {
-      for (SliceDLMap_i i = fDLMap.begin(); i != fDLMap.end(); ++i)
-      {
-         if (i->second)
-         {
+   if (! fDLMap.empty()) {
+      for (SliceDLMap_i i = fDLMap.begin(); i != fDLMap.end(); ++i) {
+         if (i->second) {
             PurgeDLRange(i->second, 1);
             i->second = 0;
          }
@@ -140,25 +130,8 @@ void TEveCaloLegoGL::DLCachePurge()
 }
 
 //______________________________________________________________________________
-Bool_t TEveCaloLegoGL::PhiShiftInterval(Float_t &min, Float_t &max) const
-{
-   if (fM->GetPhiMax()>TMath::Pi() && max<=fM->GetPhiMin())
-   {
-      min += TMath::TwoPi();
-      max += TMath::TwoPi();
-   }
-   else if (fM->GetPhiMin()<-TMath::Pi() && min>=fM->GetPhiMax())
-   {
-      min -= TMath::TwoPi();
-      max -= TMath::TwoPi();
-   }
-
-   return min>=fM->GetPhiMin() && max<=fM->GetPhiMax();
-}
-
-//______________________________________________________________________________
 void TEveCaloLegoGL::MakeQuad(Float_t x1, Float_t y1, Float_t z1,
-                              Float_t xw, Float_t yw, Float_t h) const
+      Float_t xw, Float_t yw, Float_t h) const
 {
    // Draw an axis-aligned box using quads.
 
@@ -174,15 +147,15 @@ void TEveCaloLegoGL::MakeQuad(Float_t x1, Float_t y1, Float_t z1,
    //    1-------0
    //
 
-   Float_t x2 = x1+xw;
-   Float_t y2 = y1+yw;
-   Float_t z2 = z1+h;
+   Float_t x2 = x1 + xw;
+   Float_t y2 = y1 + yw;
+   Float_t z2 = z1 + h;
 
-   if (x1<fM->GetEtaMin()) x1= fM->GetEtaMin();
-   if (x2>fM->GetEtaMax()) x2= fM->GetEtaMax();
+   if (x1 < fM->GetEtaMin()) x1 = fM->GetEtaMin();
+   if (x2 > fM->GetEtaMax()) x2 = fM->GetEtaMax();
 
-   if (y1<fM->GetPhiMin()) y1= fM->GetPhiMin();
-   if (y2>fM->GetPhiMax()) y2= fM->GetPhiMax();
+   if (y1 < fM->GetPhiMin()) y1 = fM->GetPhiMin();
+   if (y2 > fM->GetPhiMax()) y2 = fM->GetPhiMax();
 
    glBegin(GL_QUADS);
    {
@@ -264,7 +237,7 @@ void TEveCaloLegoGL::MakeDisplayList() const
 
                   y0 = fPhiAxis->GetBinLowEdge(j);
                   y1 = fPhiAxis->GetBinUpEdge(j);
-                  if (PhiShiftInterval(y0, y1))
+                  WrapTwoPi(y0, y1);
                   {
                      glLoadName(bin);
                      MakeQuad(fEtaAxis->GetBinLowEdge(i), y0, offset,
@@ -277,34 +250,29 @@ void TEveCaloLegoGL::MakeDisplayList() const
          glEndList();
       }
    }
-   else
-   {
+   else {
       TEveCaloData::CellData_t cellData;
       Int_t   prevTower = 0;
       Float_t offset = 0;
 
       // ids in eta phi rng
       Int_t nSlices = fM->fData->GetNSlices();
-      for (Int_t s = 0; s < nSlices; ++s)
-      {
+      for (Int_t s = 0; s < nSlices; ++s) {
          if (fDLMap.empty() || fDLMap[s] == 0)
             fDLMap[s] = glGenLists(1);
          glNewList(fDLMap[s], GL_COMPILE);
 
-         for (UInt_t i = 0; i < fM->fCellList.size(); ++i)
-         {
+         for (UInt_t i = 0; i < fM->fCellList.size(); ++i) {
             if (fM->fCellList[i].fSlice > s) continue;
-            if (fM->fCellList[i].fTower != prevTower)
-            {
+            if (fM->fCellList[i].fTower != prevTower) {
                offset = 0;
                prevTower = fM->fCellList[i].fTower;
             }
 
             fM->fData->GetCellData(fM->fCellList[i], cellData);
-            if (s == fM->fCellList[i].fSlice)
-            {
+            if (s == fM->fCellList[i].fSlice) {
                glLoadName(i);
-               PhiShiftInterval(cellData.fPhiMin, cellData.fPhiMax);
+               WrapTwoPi(cellData.fPhiMin, cellData.fPhiMax);
                MakeQuad(cellData.EtaMin(), cellData.PhiMin(), offset,
                         cellData.EtaDelta(), cellData.PhiDelta(), cellData.Value(fM->fPlotEt));
             }
@@ -313,319 +281,365 @@ void TEveCaloLegoGL::MakeDisplayList() const
          glEndList();
       }
    }
-   fDLCacheOK=kTRUE;
+   fDLCacheOK = kTRUE;
 }
 
 //______________________________________________________________________________
-void TEveCaloLegoGL::DrawZAxis(TGLRnrCtx &rnrCtx, Float_t azX, Float_t azY) const
+void TEveCaloLegoGL::SetAxis3DTitlePos(TGLRnrCtx &rnrCtx, Float_t x0, Float_t x1, Float_t y0, Float_t y1) const
 {
-   // Draw Z axis at given xy position;
-
-   glPushMatrix();
-   glTranslatef(azX,  azY, 0);
-
-   // tick mark projected vector is in x dimension
-   TGLMatrix modview;
-   glGetDoublev(GL_MODELVIEW_MATRIX, modview.Arr());
-   TGLVertex3 worldRef(azX, azY, fDataMax*0.5);
-
-   fZAxisAtt.SetAxisColor(fM->fGridColor);
-   fZAxisAtt.SetLabelColor(fM->fFontColor);
-   fZAxisAtt.SetTitleColor(fM->fFontColor);
-   fZAxisAtt.SetRng(0, fDataMax);
-   fZAxisAtt.SetNdivisions( fM->fNZSteps*100+10);
-   fZAxisAtt.RefTMOff(0) = rnrCtx.RefCamera().ViewportDeltaToWorld(worldRef, -10, 0, &modview);
-   fZAxisAtt.RefTitlePos().Set(0, 0, fDataMax*1.05);
-   fAxisPainter.Paint(rnrCtx, fZAxisAtt);
-
-   glPopMatrix();
-}
-
-//______________________________________________________________________________
-void TEveCaloLegoGL::DrawZScales3D(TGLRnrCtx & rnrCtx,
-                                   Float_t x0, Float_t x1,
-                                   Float_t y0, Float_t y1) const
-{
-   // Draw z-axis at the appropriate grid corner-point including
-   // tick-marks and labels.
-
-   // corner points projected
    const GLdouble *pm = rnrCtx.RefCamera().RefLastNoPickProjM().CArr();
    GLdouble mm[16];
    GLint    vp[4];
    glGetDoublev(GL_MODELVIEW_MATRIX,  mm);
    glGetIntegerv(GL_VIEWPORT, vp);
-   GLdouble x[4];
-   GLdouble y[4];
-   GLdouble z[4];
-   gluProject(x0, y0, 0, mm, pm, vp, &x[0], &y[0], &z[0]);
-   gluProject(x1, y0, 0, mm, pm, vp, &x[1], &y[1], &z[1]);
-   gluProject(x1, y1, 0, mm, pm, vp, &x[2], &y[2], &z[2]);
-   gluProject(x0, y1, 0, mm, pm, vp, &x[3], &y[3], &z[3]);
+   GLdouble projX[4], projY[4], projZ[4];
 
+   GLdouble cornerX[4];
+   GLdouble cornerY[4];
+   cornerX[0] = x0; cornerY[0] = y0;
+   cornerX[1] = x1; cornerY[1] = y0;
+   cornerX[2] = x1; cornerY[2] = y1;
+   cornerX[3] = x0; cornerY[3] = y1;
 
-   /**************************************************************************/
+   gluProject(cornerX[0], cornerY[0], 0, mm, pm, vp, &projX[0], &projY[0], &projZ[0]);
+   gluProject(cornerX[1], cornerY[1], 0, mm, pm, vp, &projX[1], &projY[1], &projZ[1]);
+   gluProject(cornerX[2], cornerY[2], 0, mm, pm, vp, &projX[2], &projY[2], &projZ[2]);
+   gluProject(cornerX[3], cornerY[3], 0, mm, pm, vp, &projX[3], &projY[3], &projZ[3]);
 
-   // get pos of z axis (left most corner)
 
+   // Z axis location (left most corner)
+   //
    Int_t idxLeft = 0;
-   Float_t xt = x[0];
-   for (Int_t i = 1; i < 4; ++i)
-   {
-      if (x[i] < xt)
-      {
-         xt  = x[i];
+   Float_t xt = projX[0];
+   for (Int_t i = 1; i < 4; ++i) {
+      if (projX[i] < xt) {
+         xt  = projX[i];
          idxLeft = i;
       }
    }
+   fZAxisTitlePos.Set(cornerX[idxLeft], cornerY[idxLeft], fDataMax* 1.05);
 
-   Float_t azX  = 0, azY  = 0;
-   switch(idxLeft)
-   {
+
+   // XY axis location (closest to eye) first
+   //
+   Float_t zt = 1.f;
+   Float_t zMin = 0.f;
+   Int_t idxFront = 0;
+   for (Int_t i = 0; i < 4; ++i) {
+      if (projZ[i] < zt) {
+         zt  = projZ[i];
+         idxFront = i;
+      }
+      if (projZ[i] > zMin) zMin = projZ[i];
+   }
+
+
+   Int_t xyIdx = idxFront;
+   if (zMin - zt < 1e-2) xyIdx = 0; // avoid flipping in front view
+
+
+   switch (xyIdx) {
       case 0:
-         azX  =  x0;      azY  =  y0;
+         fXAxisTitlePos.fX = x1;
+         fXAxisTitlePos.fY = y0;
+         fYAxisTitlePos.fX = x0;
+         fYAxisTitlePos.fY = y1;
          break;
       case 1:
-         azX  =  x1;      azY  =  y0;
+         fXAxisTitlePos.fX = x0;
+         fXAxisTitlePos.fY = y0;
+         fYAxisTitlePos.fX = x1;
+         fYAxisTitlePos.fY = y1;
          break;
       case 2:
-         azX  =  x1;      azY  =  y1;
+         fXAxisTitlePos.fX = x0;
+         fXAxisTitlePos.fY = y1;
+         fYAxisTitlePos.fX = x1;
+         fYAxisTitlePos.fY = y0;
          break;
       case 3:
-         azX  =  x0;      azY  =  y1;
+         fXAxisTitlePos.fX = x1;
+         fXAxisTitlePos.fY = y1;
+         fYAxisTitlePos.fX = x0;
+         fYAxisTitlePos.fY = y0;
          break;
    }
 
-   /**************************************************************************/
-   // z axis body
+   // move title 5% over the axis length
+   Float_t off = 0.05;
+   Float_t tOffX = (x1-x0) * off; if (fYAxisTitlePos.fX > x0) tOffX = -tOffX;
+   Float_t tOffY = (y1-y0) * off; if (fXAxisTitlePos.fY > y0) tOffY = -tOffY;
+   fXAxisTitlePos.fX += tOffX;
+   fYAxisTitlePos.fY += tOffY;
 
-   TGLUtil::Color(fM->fGridColor);
 
+   // frame box
+   //
    if (fM->fBoxMode)
    {
-      // get corner closest to eye, excluding left corner
-      Double_t zt = 1.f;
-      Int_t idxDepth = 0;
-      for (Int_t i = 0; i < 4; ++i)
-      {
-         if (z[i] < zt)
-         {
-            zt  = z[i];
-            idxDepth = i;
-         }
-      }
+      // get corner closest to eye excluding left corner
       Double_t zm = 1.f;
       Int_t idxDepthT = 0;
       for (Int_t i = 0; i < 4; ++i)
       {
-         if (z[i] < zm && z[i] >= zt && i != idxDepth)
+         if (projZ[i] < zm && projZ[i] >= zt && i != idxFront )
          {
-            zm  = z[i];
+            zm  = projZ[i];
             idxDepthT = i;
          }
       }
-      if (idxDepth == idxLeft)  idxDepth =idxDepthT;
+      if (idxFront == idxLeft)  idxFront =idxDepthT;
 
-      Float_t ayX = 0; // Y position of back plane X = const
-      Float_t axY = 0; // X postion of back plane  Y = const
-      Float_t cX  = 0, cY  = 0; // coodinates of a point closest to eye
-      switch (idxDepth)
+      switch (idxFront)
       {
          case 0:
-            axY=y1; ayX=x1;
-            cX=x0; cY=y0;
+            fBackPlaneXConst[0].Set(x1, y0, 0); fBackPlaneXConst[1].Set(x1, y1, 0);
+            fBackPlaneYConst[0].Set(x0, y1, 0); fBackPlaneYConst[1].Set(x1, y1, 0);
             break;
          case 1:
-            axY=y1; ayX=x0;
-            cX= x1; cY=y0;
+            fBackPlaneXConst[0].Set(x0, y0, 0); fBackPlaneXConst[1].Set(x0, y1, 0);
+            fBackPlaneYConst[0].Set(x0, y1, 0); fBackPlaneYConst[1].Set(x1, y1, 0);
             break;
          case 2:
-            axY=y0; ayX=x0;
-            cX=x1;  cY=y1;
+            fBackPlaneXConst[0].Set(x0, y0, 0); fBackPlaneXConst[1].Set(x0, y1, 0);
+            fBackPlaneYConst[0].Set(x0, y0, 0); fBackPlaneYConst[1].Set(x1, y0, 0);
             break;
          case 3:
-            axY=y0; ayX=x1;
-            cX= x0; cY=y1;
+            fBackPlaneXConst[0].Set(x1, y0, 0); fBackPlaneXConst[1].Set(x1, y1, 0);
+            fBackPlaneYConst[0].Set(x0, y0, 0); fBackPlaneYConst[1].Set(x1, y0, 0);
             break;
       }
+   }
+}
 
-      glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT);
-      glLineWidth(1);
-
-      // box verticals
-      glBegin(GL_LINES);
-      glVertex3f(x0, axY, 0); glVertex3f(x0, axY, fDataMax);
-      glVertex3f(x1, axY, 0); glVertex3f(x1, axY, fDataMax);
-      glVertex3f(ayX, y0, 0); glVertex3f(ayX, y0, fDataMax);
-      glVertex3f(ayX, y1, 0); glVertex3f(ayX, y1, fDataMax);
-      if (fM->fBoxMode == TEveCaloLego::kFrontBack)
-      {
-         glVertex3f(cX, cY, 0); glVertex3f(cX, cY, fDataMax);
-      }
+//______________________________________________________________________________
+void TEveCaloLegoGL::DrawAxis3D(TGLRnrCtx & rnrCtx) const
+{
+   // Draw z-axis and z-box at the appropriate grid corner-point including
+   // tick-marks and labels.
 
-      // box top
-      glVertex3f(x0, axY, fDataMax); glVertex3f(x1, axY, fDataMax);
-      glVertex3f(ayX, y0, fDataMax); glVertex3f(ayX, y1, fDataMax);
-      if (fM->fBoxMode == TEveCaloLego::kFrontBack)
-      {
-         glVertex3f(cX, cY, fDataMax); glVertex3f(cX, axY, fDataMax);
-         glVertex3f(cX, cY, fDataMax); glVertex3f(ayX, cY, fDataMax);
-      }
-      glEnd();
-      glPopAttrib();
+   // set font size first depending on size of projected axis
 
-      // box horizontals stippled
-      Int_t ondiv;
-      Double_t omin, omax, bw1;
-      THLimitsFinder::Optimize(0, fDataMax, fM->fNZSteps, omin, omax, ondiv, bw1);
-
-      glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT);
-      glLineStipple(1, 0x5555);
-      glEnable(GL_LINE_STIPPLE);
-      glBegin(GL_LINES);
-      Float_t hz  = bw1;
-      for (Int_t i = 1; i <= ondiv; ++i, hz += bw1)
-      {
-         glVertex3f(x0, axY, hz); glVertex3f(x1, axY, hz);
-         glVertex3f(ayX, y0, hz); glVertex3f(ayX, y1, hz);
-      }
-      glEnd();
-      glPopAttrib();
-   } // draw box
+   TGLMatrix mm;
+   GLdouble pm[16];
+   GLint    vp[4];
+   glGetDoublev(GL_MODELVIEW_MATRIX, mm.Arr());
+   glGetDoublev(GL_PROJECTION_MATRIX, pm);
+   glGetIntegerv(GL_VIEWPORT, vp);
 
-   /**************************************************************************/
+   GLdouble dn[3];
+   GLdouble up[3];
+   gluProject(fZAxisTitlePos.fX, fZAxisTitlePos.fY, 0                , mm.Arr(), pm, vp, &dn[0], &dn[1], &dn[2]);
+   gluProject(fZAxisTitlePos.fX, fZAxisTitlePos.fY, fZAxisTitlePos.fZ, mm.Arr(), pm, vp, &up[0], &up[1], &up[2]);
+   Double_t len = TMath::Sqrt((up[0] - dn[0]) * (up[0] - dn[0])
+                              + (up[1] - dn[1]) * (up[1] - dn[1])
+                              + (up[2] - dn[2]) * (up[2] - dn[2]));
 
-   DrawZAxis(rnrCtx, azX,  azY);
+   TGLVertex3 worldRef(fZAxisTitlePos.fX, fZAxisTitlePos.fY, fZAxisTitlePos.fZ);
+   fAxisPainter.RefTMOff(0) = rnrCtx.RefCamera().ViewportDeltaToWorld(worldRef, -10, 0,  &mm);
+   fAxisPainter.SetLabelPixelFontSize(TMath::CeilNint(len*fZAxis->GetLabelSize()));
+   fAxisPainter.SetTitlePixelFontSize(TMath::CeilNint(len*fZAxis->GetTitleSize()));
 
-   if (fM->fTowerPicked >= 0)
+   // Z axis
+   //
+   if (fM->fData->Empty() == kFALSE)
    {
-      // left most corner of the picked tower
-      TEveCaloData::CellData_t cd;
-      fM->fData->GetCellData(fM->fCellList[fM->fTowerPicked], cd);
-      PhiShiftInterval(cd.fPhiMin, cd.fPhiMax);
-      switch(idxLeft)
-      {
-         case 0:
-            azX  =  cd.EtaMin();      azY  =  cd.PhiMin();
-            break;
-         case 1:
-            azX  =  cd.EtaMax();      azY  =  cd.PhiMin();
-            break;
-         case 2:
-            azX  =  cd.EtaMax();      azY  =  cd.PhiMax();
-            break;
-         case 3:
-            azX  =  cd.EtaMin();      azY  =  cd.PhiMax();
-            break;
+      fZAxis->SetAxisColor(fM->fGridColor);
+      fZAxis->SetLabelColor(fM->fFontColor);
+      fZAxis->SetTitleColor(fM->fFontColor);
+      fZAxis->SetNdivisions(fM->fNZSteps*100 + 10);
+      fZAxis->SetLimits(0, fDataMax);
+      fZAxis->SetTitle(fM->GetPlotEt() ? "Et[GeV]" : "E[GeV]");
+
+      fAxisPainter.SetTMNDim(1);
+      fAxisPainter.RefDir().Set(0., 0., 1.);
+      fAxisPainter.SetLabelAlign(TGLFont::kRight);
+      glPushMatrix();
+      glTranslatef(fZAxisTitlePos.fX, fZAxisTitlePos.fY, 0);
+
+      // tickmark vector = 10 pixels left
+      fAxisPainter.RefTitlePos().Set(fAxisPainter.RefTMOff(0).X(),  fAxisPainter.RefTMOff(0).Y(), fZAxisTitlePos.fZ);
+      fAxisPainter.PaintAxis(rnrCtx, fZAxis);
+      glTranslated( fAxisPainter.RefTMOff(0).X(),  fAxisPainter.RefTMOff(0).Y(),  fAxisPainter.RefTMOff(0).Z());
+      glPopMatrix();
+
+      // repaint axis if tower dobule-clicked
+      if (fM->fTowerPicked >= 0) {
+         TEveCaloData::CellData_t cd;
+         fM->fData->GetCellData(fM->fCellList[fM->fTowerPicked], cd);
+         WrapTwoPi(cd.fPhiMin, cd.fPhiMax);
+         glPushMatrix();
+         glTranslatef(cd.EtaMin(), cd.PhiMin(), 0);
+         fAxisPainter.RnrLines();
+         fAxisPainter.RnrLabels();
+         glPopMatrix();
       }
-      DrawZAxis(rnrCtx, azX,  azY);
-   }
-} // DrawZScales3D
 
-//______________________________________________________________________________
-void TEveCaloLegoGL::DrawXYScales(TGLRnrCtx & rnrCtx,
-                                  Float_t x0, Float_t x1,
-                                  Float_t y0, Float_t y1) const
-{
-   // Draw XY title, labels.
+      // draw box frame
+      //
+      if (fM->fBoxMode) {
 
-   // corner point closest to the eye
-   const GLdouble *pm = rnrCtx.RefCamera().RefLastNoPickProjM().CArr();
-   GLdouble mm[16];
-   GLint    vp[4];
-   glGetDoublev(GL_MODELVIEW_MATRIX,  mm);
-   glGetIntegerv(GL_VIEWPORT, vp);
-   GLdouble y,  z[4], x[4];
-   gluProject(x0, y0, 0, mm, pm, vp, &x[0], &y, &z[0]);
-   gluProject(x1, y0, 0, mm, pm, vp, &x[1], &y, &z[1]);
-   gluProject(x1, y1, 0, mm, pm, vp, &x[2], &y, &z[2]);
-   gluProject(x0, y1, 0, mm, pm, vp, &x[3], &y, &z[3]);
+         glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT);
 
-   Float_t zt = 1.f;
-   Float_t zm = 0.f;
-   Int_t idx = 0;
-   for (Int_t i = 0; i < 4; ++i)
-   {
-      if (z[i] < zt)
-      {
-         zt  = z[i];
-         idx = i;
+         // box verticals
+         glLineWidth(1);
+         glBegin(GL_LINES);
+         TGLUtil::Color(fM->GetGridColor());
+
+         glVertex3f(fBackPlaneXConst[0].fX   ,fBackPlaneXConst[0].fY   ,0);
+         glVertex3f(fBackPlaneXConst[0].fX   ,fBackPlaneXConst[0].fY   ,fDataMax);
+         glVertex3f(fBackPlaneXConst[1].fX   ,fBackPlaneXConst[1].fY   ,0);
+         glVertex3f(fBackPlaneXConst[1].fX   ,fBackPlaneXConst[1].fY   ,fDataMax);
+
+
+         glVertex3f(fBackPlaneYConst[0].fX   ,fBackPlaneYConst[0].fY   ,0);
+         glVertex3f(fBackPlaneYConst[0].fX   ,fBackPlaneYConst[0].fY   ,fDataMax);
+         glVertex3f(fBackPlaneYConst[1].fX   ,fBackPlaneYConst[1].fY   ,0);
+         glVertex3f(fBackPlaneYConst[1].fX   ,fBackPlaneYConst[1].fY   ,fDataMax);
+
+         // box top
+         glVertex3f(fBackPlaneXConst[0].fX   ,fBackPlaneXConst[0].fY   ,fDataMax);
+         glVertex3f(fBackPlaneXConst[1].fX   ,fBackPlaneXConst[1].fY   ,fDataMax);
+         glVertex3f(fBackPlaneYConst[0].fX   ,fBackPlaneYConst[0].fY   ,fDataMax);
+         glVertex3f(fBackPlaneYConst[1].fX   ,fBackPlaneYConst[1].fY   ,fDataMax);
+
+         glEnd();
+
+         // box horizontals stippled
+         glEnable(GL_LINE_STIPPLE);
+         Int_t ondiv;
+         Double_t omin, omax, bw1;
+         THLimitsFinder::Optimize(0, fDataMax, fM->fNZSteps, omin, omax, ondiv, bw1);
+
+         glLineStipple(1, 0x5555);
+         glBegin(GL_LINES);
+         Float_t hz  = bw1;
+         for (Int_t i = 1; i <= ondiv; ++i, hz += bw1) {
+            glVertex3f(fBackPlaneXConst[0].fX   ,fBackPlaneXConst[0].fY   ,hz);
+            glVertex3f(fBackPlaneXConst[1].fX   ,fBackPlaneXConst[1].fY   ,hz);
+            glVertex3f(fBackPlaneYConst[0].fX   ,fBackPlaneYConst[0].fY   ,hz);
+            glVertex3f(fBackPlaneYConst[1].fX   ,fBackPlaneYConst[1].fY   ,hz);
+         }
+         glEnd();
+
+         glPopAttrib();
       }
-      if (z[i] > zm) zm = z[i];
    }
-   if (zm - zt < 1e-2) idx = 0; // avoid flipping in front view
 
-   // XY axis location
-   Float_t axY  = 0, ayX  = 0;
-   Float_t axtX = 0, aytY = 0; // title pos
-   switch (idx)
-   {
-      case 0:
-         axY  = y0; ayX  = x0;
-         axtX = x1; aytY = y1;
-         break;
-      case 1:
-         ayX  = x1; axY  = y0;
-         axtX = x0; aytY = y1;
-         break;
-      case 2:
-         ayX  = x1; axY  = y1;
-         axtX = x0; aytY = y0;
-         break;
-      case 3:
-         ayX  = x0; axY  = y1;
-         axtX = x1; aytY = y0;
-         break;
-   }
+   // XY Axis
+   //
 
-   Float_t zOff  = -fDataMax*0.03;
-   Float_t yOff  =  0.03*TMath::Sign(y1-y0, axY);
-   Float_t xOff  =  0.03*TMath::Sign(x1-x0, ayX);
-   Float_t rxy = (fPhiAxis->GetXmax()-fPhiAxis->GetXmin())/(fEtaAxis->GetXmax()-fEtaAxis->GetXmin());
-   (rxy>1) ? yOff /= rxy : xOff *=rxy;
+   Float_t yOff  = fM->GetPhiRng();
+   if (fXAxisTitlePos.fY < fM->GetPhiMax()) yOff = -yOff;
 
-   if (fXAxisAtt.GetRelativeFontSize() == kFALSE)
-   {
-      fXAxisAtt.SetAbsLabelFontSize(fZAxisAtt.GetAbsLabelFontSize());
-      fXAxisAtt.SetAbsTitleFontSize(Int_t(fZAxisAtt.GetAbsTitleFontSize()*0.8));
-   }
+   Float_t xOff  = fM->GetEtaRng();
+   if (fYAxisTitlePos.fX < fM->GetEtaMax()) xOff = -xOff;
+
+   TAxis ax;
+   ax.SetAxisColor(fM->fGridColor);
+   ax.SetLabelColor(fM->fFontColor);
+   ax.SetTitleColor(fM->fFontColor);
+   ax.SetTitleFont(fM->GetData()->GetEtaBins()->GetTitleFont());
+   ax.SetLabelOffset(0.02);
+   ax.SetTickLength(0.05);
+   ax.SetLabelSize(0.03);
+
+   fAxisPainter.SetTMNDim(2);
+   fAxisPainter.RefTMOff(1).Set(0, 0, -fDataMax);
+   fAxisPainter.SetLabelAlign(TGLFont::kCenterUp);
 
-   TAxis* ax = fM->GetData()->GetEtaBins();
-   const char* titleFontXY = TGLFontManager::GetFontNameFromId(ax->GetTitleFont());
-
-   fXAxisAtt.SetTitleFontName(titleFontXY);
-   fXAxisAtt.SetRng(x0, x1);
-   fXAxisAtt.SetAxisColor(fM->fGridColor);
-   fXAxisAtt.SetLabelColor(fM->fFontColor);
-   fXAxisAtt.SetTitleColor(fM->fFontColor);
-   fXAxisAtt.RefTMOff(0).Set(0, yOff, 0);
-   fXAxisAtt.RefTMOff(1).Set(0, 0, zOff);
-   fXAxisAtt.RefTitlePos().Set(axtX, 0, 0);
-   fXAxisAtt.SetTitle(ax->GetTitle());
+   // eta
    glPushMatrix();
-   glTranslatef(0, axY, 0);
-   fAxisPainter.Paint(rnrCtx, fXAxisAtt);
+   fAxisPainter.RefDir().Set(1, 0, 0);
+   fAxisPainter.RefTMOff(0).Set(0, yOff, 0);
+   glTranslatef(0, fXAxisTitlePos.fY, 0);
+   ax.SetNdivisions(710);
+   ax.SetLimits(fM->GetEtaMin(), fM->GetEtaMax());
+   ax.SetTitle(fM->GetData()->GetEtaBins()->GetTitle());
+   fAxisPainter.RefTitlePos().Set(fXAxisTitlePos.fX, yOff*1.5*ax.GetTickLength(), -fDataMax*ax.GetTickLength());
+   fAxisPainter.PaintAxis(rnrCtx, &ax);
+   glTranslatef(0, yOff*1.5*ax.GetTickLength(), -fDataMax*ax.GetTickLength());
+   //   fAxisPainter.RnrTitle(fM->GetData()->GetEtaBins()->GetTitle(), fXAxisTitlePos.fX, TGLFont::kCenterUp);
    glPopMatrix();
 
+   // phi
+   fAxisPainter.RefDir().Set(0, 1, 0);
+   fAxisPainter.RefTMOff(0).Set(xOff, 0, 0);
+   ax.SetNdivisions(510);
+   ax.SetLimits(fM->GetPhiMin(), fM->GetPhiMax());
+   ax.SetTitle(fM->GetData()->GetPhiBins()->GetTitle());
+   glPushMatrix();
+   glTranslatef(fYAxisTitlePos.fX, 0, 0);
+   fAxisPainter.RefTitlePos().Set( xOff*1.5*ax.GetTickLength(), fYAxisTitlePos.fY,  -fDataMax*ax.GetTickLength());
+   fAxisPainter.PaintAxis(rnrCtx, &ax);
+   glTranslatef(xOff*1.5*ax.GetTickLength(), 0,  -fDataMax*ax.GetTickLength());
+   //fAxisPainter.RnrTitle(fM->GetData()->GetPhiBins()->GetTitle(), fYAxisTitlePos.fY, TGLFont::kCenterUp);
+   glPopMatrix();
+
+} // DrawAxis3D
+
+//______________________________________________________________________________
+void TEveCaloLegoGL::DrawAxis2D(TGLRnrCtx & rnrCtx) const
+{
+   // Draw XY axis.
+
+   TAxis ax;
+   ax.SetAxisColor(fM->fGridColor);
+   ax.SetLabelColor(fM->fFontColor);
+   ax.SetTitleColor(fM->fFontColor);
+   ax.SetTitleFont(fM->GetData()->GetEtaBins()->GetTitleFont());
+   ax.SetLabelOffset(0.01);
+   ax.SetTickLength(0.05);
+
+   // set fonts
+   fAxisPainter.SetAttAxis(&ax);
+
+   // get projected length of diagonal to determine
+   TGLMatrix mm;
+   GLdouble pm[16];
+   GLint    vp[4];
+   glGetDoublev(GL_MODELVIEW_MATRIX, mm.Arr());
+   glGetDoublev(GL_PROJECTION_MATRIX, pm);
+   glGetIntegerv(GL_VIEWPORT, vp);
+
+   GLdouble dn[3];
+   GLdouble up[3];
+   gluProject(fM->GetEtaMin(), fM->GetPhiMin(), 0, mm.Arr(), pm, vp, &dn[0], &dn[1], &dn[2]);
+   gluProject(fM->GetEtaMax(), fM->GetPhiMax(), 0, mm.Arr(), pm, vp, &up[0], &up[1], &up[2]);
+   Double_t len = TMath::Sqrt((up[0] - dn[0]) * (up[0] - dn[0])
+                              + (up[1] - dn[1]) * (up[1] - dn[1])
+                              + (up[2] - dn[2]) * (up[2] - dn[2]));
+   fAxisPainter.SetLabelPixelFontSize(TMath::CeilNint(len*0.02));
+   fAxisPainter.SetTitlePixelFontSize(TMath::CeilNint(len*0.02));
+
+   // eta
+   ax.SetNdivisions(710);
+   ax.SetLimits(fM->GetEtaMin(), fM->GetEtaMax());
+   ax.SetTitle(fM->GetData()->GetEtaBins()->GetTitle());
+   fAxisPainter.RefTitlePos().Set(fM->GetEtaMax(), -fM->GetPhiRng()*(ax.GetTickLength()+ ax.GetLabelOffset()), 0 );
+   fAxisPainter.RefDir().Set(1, 0, 0);
+   fAxisPainter.RefTMOff(0).Set(0,  -fM->GetPhiRng(), 0);
+   fAxisPainter.SetLabelAlign(TGLFont::kCenterUp);
 
-   ax = fM->GetData()->GetPhiBins();
-   fYAxisAtt.SetTitleFontName(titleFontXY);
-   fYAxisAtt.SetRng(y0, y1);
-   fYAxisAtt.SetAxisColor(fM->fGridColor);
-   fYAxisAtt.SetLabelColor(fM->fFontColor);
-   fYAxisAtt.SetTitleColor(fM->fFontColor);
-   fYAxisAtt.RefTMOff(0).Set(xOff, 0, 0);
-   fYAxisAtt.RefTMOff(1).Set(0, 0, zOff);
-   fYAxisAtt.SetAbsLabelFontSize(fXAxisAtt.GetAbsLabelFontSize());
-   fYAxisAtt.SetAbsTitleFontSize(fXAxisAtt.GetAbsTitleFontSize());
-   fYAxisAtt.RefTitlePos().Set(0, aytY, 0);
-   fYAxisAtt.SetTitle(ax->GetTitle());
    glPushMatrix();
-   glTranslatef(ayX, 0, 0);
-   fAxisPainter.Paint(rnrCtx, fYAxisAtt);
+   glTranslatef(0, fM->GetPhiMin(), 0);
+   fAxisPainter.PaintAxis(rnrCtx, &ax);
    glPopMatrix();
 
-} // DrawXYScales
+   // phi
+   ax.SetNdivisions(510);
+   ax.SetLimits(fM->GetPhiMin(), fM->GetPhiMax());
+   ax.SetTitle(fM->GetData()->GetPhiBins()->GetTitle());  
+   fAxisPainter.RefTitlePos().Set(-fM->GetEtaRng()*(ax.GetTickLength()+ ax.GetLabelOffset()), fM->GetPhiMax(), 0);
+   fAxisPainter.RefDir().Set(0, 1, 0);
+   fAxisPainter.RefTMOff(0).Set(-fM->GetEtaRng(), 0, 0);
+   fAxisPainter.SetLabelAlign(TGLFont::kRight);
+
+   glPushMatrix();
+   glTranslatef(fM->GetEtaMin(), 0, 0);
+   fAxisPainter.PaintAxis(rnrCtx, &ax);
+   glPopMatrix();
+}
 
 //______________________________________________________________________________
 Int_t TEveCaloLegoGL::GetGridStep(TGLRnrCtx &rnrCtx) const
@@ -641,36 +655,33 @@ Int_t TEveCaloLegoGL::GetGridStep(TGLRnrCtx &rnrCtx) const
    GLint    vp[4];
    glGetDoublev(GL_MODELVIEW_MATRIX,  mm);
    glGetIntegerv(GL_VIEWPORT, vp);
-   const GLdouble *pm = rnrCtx.RefCamera().RefLastNoPickProjM().CArr();
-
-   gluProject(fM->fEtaMin, fM->GetPhiMin(), 0.f , mm, pm, vp, &x0, &y0, &z0);
-   gluProject(fM->fEtaMax, fM->GetPhiMax(), 0.f , mm, pm, vp, &x1, &y1, &z1);
-   Float_t d0 = Sqrt((x0-x1)*(x0-x1) + (y0-y1)*(y0-y1) + (z0-z1)*(z0-z1));
+   const GLdouble *pmx = rnrCtx.RefCamera().RefLastNoPickProjM().CArr();
 
-   gluProject(fM->fEtaMax, fM->GetPhiMin(), 0.f , mm, pm, vp, &x0, &y0, &z0);
-   gluProject(fM->fEtaMin, fM->GetPhiMax(), 0.f , mm, pm, vp, &x1, &y1, &z1);
-   Float_t d1 = Sqrt((x0-x1)*(x0-x1) + (y0-y1)*(y0-y1) + (z0-z1)*(z0-z1));
+   GLdouble em, eM, pm, pM;
+   fM->GetData()->GetEtaLimits(pm, pM);
+   fM->GetData()->GetPhiLimits(em, eM);
+   gluProject(em, pm, 0.f , mm, pmx, vp, &x0, &y0, &z0);
+   gluProject(eM, pM, 0.f , mm, pmx, vp, &x1, &y1, &z1);
+   Float_t d0 = Sqrt((x0 - x1) * (x0 - x1) + (y0 - y1) * (y0 - y1) + (z0 - z1) * (z0 - z1));
 
-   Float_t d = d1>d0? d1:d0;
+   gluProject(em, pm, 0.f , mm, pmx, vp, &x0, &y0, &z0);
+   gluProject(eM, pM, 0.f , mm, pmx, vp, &x1, &y1, &z1);
+   Float_t d1 = Sqrt((x0 - x1) * (x0 - x1) + (y0 - y1) * (y0 - y1) + (z0 - z1) * (z0 - z1));
 
+   Float_t d = d1 > d0 ? d1 : d0;
    Int_t i0 = fM->fData->GetEtaBins()->FindBin(fM->GetEtaMin());
    Int_t i1 = fM->fData->GetEtaBins()->FindBin(fM->GetEtaMax());
    Int_t j0 = fM->fData->GetPhiBins()->FindBin(fM->GetPhiMin());
    Int_t j1 = fM->fData->GetPhiBins()->FindBin(fM->GetPhiMax());
 
-   Float_t ppb = d/Sqrt((i0-i1)*(i0-i1)+(j0-j1)*(j0-j1));
+   Float_t ppb = d / Sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
 
    Int_t ngroup;
-   if (ppb < fM->fPixelsPerBin*0.5)
-   {
+   if (ppb < fM->fPixelsPerBin*0.5) {
       ngroup = 4;
-   }
-   else if (ppb < fM->fPixelsPerBin)
-   {
+   } else if (ppb < fM->fPixelsPerBin) {
       ngroup = 2;
-   }
-   else
-   {
+   } else {
       ngroup = 1;
    }
 
@@ -678,34 +689,19 @@ Int_t TEveCaloLegoGL::GetGridStep(TGLRnrCtx &rnrCtx) const
 }
 
 //___________________________________________________________________________
-void TEveCaloLegoGL::SetAxis(TAxis *orig, TAxis *curr) const
+void TEveCaloLegoGL::RebinAxis(TAxis *orig, TAxis *curr) const
 {
-   // Calculate view-dependent grid density.
+   // Rebin eta, phi axis.
 
-   if(orig->GetXbins()->GetSize())
-      curr->Set(orig->GetNbins(), orig->GetXbins()->GetArray());
-   else
-      curr->Set(orig->GetNbins(), orig->GetXmin(), orig->GetXmax());
+   Int_t nb = orig->GetNbins();
+   Int_t newbins = nb/fBinStep;
+   Double_t *bins = new Double_t[newbins+1];
 
+   for(Int_t i = 0; i <= newbins; ++i)
+      bins[i] = orig->GetBinLowEdge(1+i*fBinStep);
 
-   if (fBinStep>1)
-   {
-      Int_t nb = curr->GetNbins();
-      Int_t newbins = nb/fBinStep;
-      if(curr->GetXbins()->GetSize() > 0)
-      {
-         // variable bin sizes
-         Double_t *bins = new Double_t[newbins+1];
-         for(Int_t i = 0; i <= newbins; ++i)
-            bins[i] = curr->GetBinLowEdge(1+i*fBinStep);
-         curr->Set(newbins,bins);
-         delete [] bins;
-      }
-      else
-      {
-         curr->Set(newbins, curr->GetXmin(), curr->GetXmax());
-      }
-   }
+   curr->Set(newbins,bins);
+   delete [] bins;
 }
 
 //______________________________________________________________________________
@@ -721,11 +717,11 @@ void TEveCaloLegoGL::DrawHistBase(TGLRnrCtx &rnrCtx) const
    TGLCapabilitySwitch lights_off(GL_LIGHTING, kFALSE);
    TGLCapabilitySwitch sw_blend(GL_BLEND, kTRUE);
 
+   // XY grid
+   //
    TGLUtil::Color(fM->fGridColor);
-
    glLineWidth(1);
    glBegin(GL_LINES);
-
    glVertex2f(eta0, phi0);
    glVertex2f(eta0, phi1);
    glVertex2f(eta1, phi0);
@@ -749,37 +745,36 @@ void TEveCaloLegoGL::DrawHistBase(TGLRnrCtx &rnrCtx) const
    }
 
    // phi grid
-   Float_t y0, y1;
-   for (Int_t i=1; i<=fPhiAxis->GetNbins(); ++i)
-   {
-      y0 = fPhiAxis->GetBinUpEdge(i);
-      y1 = fPhiAxis->GetBinUpEdge(i);
-      if (PhiShiftInterval(y0, y1))
+   Int_t npb = fPhiAxis->GetNbins();
+   Float_t binLow = 0, binUp;
+   for (Int_t i = 1; i <= npb; i++) {
+      binLow = fPhiAxis->GetBinLowEdge(i);
+      binUp =  fPhiAxis->GetBinUpEdge(i);
+      WrapTwoPi(binLow, binUp);
+      if (binLow >= phi0 && binUp <= phi1)
       {
-         glVertex2f(eta0, y0);
-         glVertex2f(eta1, y0);
+         glVertex2f(eta0, binLow);
+         glVertex2f(eta1, binLow);
+         glVertex2f(eta0, binUp);
+         glVertex2f(eta1, binUp);
       }
    }
 
    glEnd();
 
    // XYZ axes
-
+   //
    glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT | GL_POLYGON_BIT);
    glLineWidth(2);
-
-   if (!fM->fData->Empty())
+   if (fCells3D)
    {
-      if (fM->fProjection == TEveCaloLego::k3D || rnrCtx.RefCamera().GetCamBase().GetBaseVec(1).Z() == 0)
-         DrawZScales3D(rnrCtx, eta0, eta1, phi0, phi1);
-
-      if (fM->fProjection == TEveCaloLego::k2D || rnrCtx.RefCamera().GetCamBase().GetBaseVec(1).Z() != 0)
-         fXAxisAtt.SetRelativeFontSize(kTRUE);
-      else
-         fXAxisAtt.SetRelativeFontSize(kFALSE);
+      SetAxis3DTitlePos(rnrCtx, eta0, eta1, phi0, phi1);
+      DrawAxis3D(rnrCtx);
+   }
+   else
+   {
+      DrawAxis2D(rnrCtx);
    }
-
-   DrawXYScales(rnrCtx, eta0, eta1, phi0, phi1);
    glPopAttrib();
 }
 
@@ -790,16 +785,14 @@ void TEveCaloLegoGL::DrawCells3D(TGLRnrCtx & rnrCtx) const
 
    // quads
    {
-      for(SliceDLMap_i i = fDLMap.begin(); i != fDLMap.end(); ++i)
-      {
+      for (SliceDLMap_i i = fDLMap.begin(); i != fDLMap.end(); ++i) {
          TGLUtil::Color(fM->GetDataSliceColor(i->first));
          glCallList(i->second);
       }
    }
    // outlines
    {
-      if (rnrCtx.SceneStyle() == TGLRnrCtx::kFill)
-      {
+      if (rnrCtx.SceneStyle() == TGLRnrCtx::kFill) {
          glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
          glDisable(GL_POLYGON_OFFSET_FILL);
          TGLUtil::Color(1);
@@ -825,8 +818,7 @@ void TEveCaloLegoGL::DrawCells2D() const
 
    // When kValSize is used, plot gl-points at tower-centers avoid flickering.
    vvTEveVec_t antiFlick(1);
-   if (fM->f2DMode == TEveCaloLego::kValSize && fM->fTopViewUseMaxColor)
-   {
+   if (fM->f2DMode == TEveCaloLego::kValSize && fM->fTopViewUseMaxColor) {
       antiFlick.resize(fM->GetData()->GetNSlices());
    }
 
@@ -834,17 +826,15 @@ void TEveCaloLegoGL::DrawCells2D() const
 
    UChar_t col[4];
    Color_t defCol = fM->GetTopViewTowerColor();
-   if (fBinStep == 1)
-   {
+   if (fBinStep == 1) {
       // draw in original binning
       Int_t   name = 0, max_energy_slice;
-      Float_t sum, max_energy, x1=0, x2=0, y1=0, y2=0;
+      Float_t sum, max_energy, x1 = 0, x2 = 0, y1 = 0, y2 = 0;
       TGLUtil::Color(defCol);
       TEveCaloData::vCellId_t::iterator currentCell = fM->fCellList.begin();
       TEveCaloData::vCellId_t::iterator nextCell    = currentCell;
       ++nextCell;
-      while (currentCell != fM->fCellList.end())
-      {
+      while (currentCell != fM->fCellList.end()) {
          TEveCaloData::CellData_t currentCellData;
          TEveCaloData::CellData_t nextCellData;
 
@@ -852,8 +842,7 @@ void TEveCaloLegoGL::DrawCells2D() const
          sum = max_energy = currentCellData.Value(fM->fPlotEt);
          max_energy_slice = currentCell->fSlice;
 
-         while (nextCell != fM->fCellList.end() && currentCell->fTower == nextCell->fTower)
-         {
+         while (nextCell != fM->fCellList.end() && currentCell->fTower == nextCell->fTower) {
             fM->fData->GetCellData(*nextCell, nextCellData);
             Float_t energy = nextCellData.Value(fM->fPlotEt);
             sum += energy;
@@ -866,9 +855,8 @@ void TEveCaloLegoGL::DrawCells2D() const
 
          glLoadName(name);
          glBegin(GL_QUADS);
-         PhiShiftInterval(currentCellData.fPhiMin,currentCellData.fPhiMax);
-         if (fM->f2DMode == TEveCaloLego::kValColor)
-         {
+         WrapTwoPi(currentCellData.fPhiMin, currentCellData.fPhiMax);
+         if (fM->f2DMode == TEveCaloLego::kValColor) {
             fM->fPalette->ColorFromValue(FloorNint(sum), col);
             TGLUtil::Color4ubv(col);
 
@@ -877,14 +865,12 @@ void TEveCaloLegoGL::DrawCells2D() const
 
             y1 = Max(fM->GetPhiMin(), currentCellData.PhiMin());
             y2 = Min(fM->GetPhiMax(), currentCellData.PhiMax());
-         }
-         else if (fM->f2DMode == TEveCaloLego::kValSize)
-         {
+         } else if (fM->f2DMode == TEveCaloLego::kValSize) {
             Double_t scaleFactor = 0;
             Double_t range = 100;
-            if (range*sum/fDataMax > 1) scaleFactor = Log(range*sum/fDataMax)/Log(range);
-            Float_t etaW = (currentCellData.EtaDelta()*0.5f)*scaleFactor;
-            Float_t phiW = (currentCellData.PhiDelta()*0.5f)*scaleFactor;
+            if (range*sum / fDataMax > 1) scaleFactor = Log(range * sum / fDataMax) / Log(range);
+            Float_t etaW = (currentCellData.EtaDelta() * 0.5f) * scaleFactor;
+            Float_t phiW = (currentCellData.PhiDelta() * 0.5f) * scaleFactor;
 
             x1 = Max(fM->GetEtaMin(), currentCellData.Eta() - etaW);
             x2 = Min(fM->GetEtaMax(), currentCellData.Eta() + etaW);
@@ -892,14 +878,11 @@ void TEveCaloLegoGL::DrawCells2D() const
             y1 = Max(fM->GetPhiMin(), currentCellData.Phi() - phiW);
             y2 = Min(fM->GetPhiMax(), currentCellData.Phi() + phiW);
 
-            if (fM->fTopViewUseMaxColor)
-            {
+            if (fM->fTopViewUseMaxColor) {
                TGLUtil::Color(fM->GetData()->GetSliceColor(max_energy_slice));
-               antiFlick[max_energy_slice].push_back(TEveVector(0.5f*(x1+x2), 0.5f*(y1+y2), sum));
-            }
-            else
-            {
-               antiFlick[0].push_back(TEveVector(0.5f*(x1+x2), 0.5f*(y1+y2), sum));
+               antiFlick[max_energy_slice].push_back(TEveVector(0.5f*(x1 + x2), 0.5f*(y1 + y2), sum));
+            } else {
+               antiFlick[0].push_back(TEveVector(0.5f*(x1 + x2), 0.5f*(y1 + y2), sum));
             }
          }
 
@@ -921,26 +904,21 @@ void TEveCaloLegoGL::DrawCells2D() const
       const Int_t nEta = fEtaAxis->GetNbins();
       const Int_t nPhi = fPhiAxis->GetNbins();
       std::vector<Float_t> vec;
-      vec.assign((nEta+2)*(nPhi+2), 0.f);
+      vec.assign((nEta + 2)*(nPhi + 2), 0.f);
       std::vector<Float_t> max_e;
       std::vector<Int_t>   max_e_slice;
-      if (fM->fTopViewUseMaxColor)
-      {
-         max_e.assign((nEta+2) * (nPhi+2), 0.f);
-         max_e_slice.assign((nEta+2) * (nPhi+2), -1);
+      if (fM->fTopViewUseMaxColor) {
+         max_e.assign((nEta + 2) * (nPhi + 2), 0.f);
+         max_e_slice.assign((nEta + 2) * (nPhi + 2), -1);
       }
 
-      for (UInt_t bin=0; bin<fRebinData.fBinData.size(); ++bin)
-      {
+      for (UInt_t bin = 0; bin < fRebinData.fBinData.size(); ++bin) {
          Float_t ssum = 0;
-         if (fRebinData.fBinData[bin] != -1)
-         {
+         if (fRebinData.fBinData[bin] != -1) {
             Float_t *val = fRebinData.GetSliceVals(bin);
-            for (Int_t s=0; s<fRebinData.fNSlices; ++s)
-            {
+            for (Int_t s = 0; s < fRebinData.fNSlices; ++s) {
                ssum += val[s];
-               if (fM->fTopViewUseMaxColor && val[s] > max_e[bin])
-               {
+               if (fM->fTopViewUseMaxColor && val[s] > max_e[bin]) {
                   max_e[bin]       = val[s];
                   max_e_slice[bin] = s;
                }
@@ -950,17 +928,16 @@ void TEveCaloLegoGL::DrawCells2D() const
       }
 
       Float_t maxv = 0;
-      for (UInt_t i =0; i<vec.size(); ++i)
-         if (vec[i] > maxv) maxv=vec[i];
+      for (UInt_t i = 0; i < vec.size(); ++i)
+         if (vec[i] > maxv) maxv = vec[i];
 
-      Float_t scale    = fM->fData->GetMaxVal(fM->fPlotEt)/maxv;
-      Float_t logMax   = Log(maxv+1);
-      Float_t scaleLog = fM->fData->GetMaxVal(fM->fPlotEt)/logMax;
+      Float_t scale    = fM->fData->GetMaxVal(fM->fPlotEt) / maxv;
+      Float_t logMax   = Log(maxv + 1);
+      Float_t scaleLog = fM->fData->GetMaxVal(fM->fPlotEt) / logMax;
 
       // take smallest threshold
       Float_t threshold = fM->GetDataSliceThreshold(0);
-      for (Int_t s=1; s<fM->fData->GetNSlices(); ++s)
-      {
+      for (Int_t s = 1; s < fM->fData->GetNSlices(); ++s) {
          if (threshold > fM->GetDataSliceThreshold(s))
             threshold = fM->GetDataSliceThreshold(s);
       }
@@ -968,25 +945,21 @@ void TEveCaloLegoGL::DrawCells2D() const
       // draw  scaled
       TGLUtil::Color(defCol);
       Float_t y0, y1, eta, etaW, phi, phiW;
-      for (Int_t i=1; i<=fEtaAxis->GetNbins(); ++i)
-      {
-         for (Int_t j=1; j<=fPhiAxis->GetNbins(); ++j)
-         {
-            const Int_t bin = j*(nEta+2)+i;
-            if (vec[bin] > threshold && fRebinData.fBinData[bin] != -1)
-            {
+      for (Int_t i = 1; i <= fEtaAxis->GetNbins(); ++i) {
+         for (Int_t j = 1; j <= fPhiAxis->GetNbins(); ++j) {
+            const Int_t bin = j * (nEta + 2) + i;
+            if (vec[bin] > threshold && fRebinData.fBinData[bin] != -1) {
                y0 = fPhiAxis->GetBinLowEdge(j);
                y1 = fPhiAxis->GetBinUpEdge(j);
-               if (!PhiShiftInterval(y0, y1)) continue;
+               WrapTwoPi(y0, y1);
 
-               const Float_t binVal = vec[bin]*scale;
+               const Float_t binVal = vec[bin] * scale;
                const Float_t logVal = Log(vec[bin] + 1);
 
                glLoadName(bin);
                glBegin(GL_QUADS);
 
-               if (fM->f2DMode == TEveCaloLego::kValColor)
-               {
+               if (fM->f2DMode == TEveCaloLego::kValColor) {
                   fM->fPalette->ColorFromValue((Int_t)(logVal*scaleLog), col);
                   TGLUtil::Color4ubv(col);
 
@@ -994,25 +967,20 @@ void TEveCaloLegoGL::DrawCells2D() const
                   etaW = fEtaAxis->GetBinWidth(i);
 
                   glVertex3f(eta     , y0, binVal);
-                  glVertex3f(eta+etaW, y0, binVal);
-                  glVertex3f(eta+etaW, y1, binVal);
+                  glVertex3f(eta + etaW, y0, binVal);
+                  glVertex3f(eta + etaW, y1, binVal);
                   glVertex3f(eta     , y1, binVal);
 
-               }
-               else if (fM->f2DMode == TEveCaloLego::kValSize)
-               {
+               } else if (fM->f2DMode == TEveCaloLego::kValSize) {
                   eta  = fEtaAxis->GetBinCenter(i);
-                  etaW = fEtaAxis->GetBinWidth(i)*0.5f*logVal/logMax;
-                  phi  = 0.5f*(y0 + y1);
-                  phiW = 0.5f*(y1 - y0)*logVal/logMax;
+                  etaW = fEtaAxis->GetBinWidth(i) * 0.5f * logVal / logMax;
+                  phi  = 0.5f * (y0 + y1);
+                  phiW = 0.5f * (y1 - y0) * logVal / logMax;
 
-                  if (fM->fTopViewUseMaxColor)
-                  {
+                  if (fM->fTopViewUseMaxColor) {
                      TGLUtil::Color(fM->GetData()->GetSliceColor(max_e_slice[bin]));
                      antiFlick[max_e_slice[bin]].push_back(TEveVector(eta, phi, binVal));
-                  }
-                  else
-                  {
+                  } else {
                      antiFlick[0].push_back(TEveVector(eta, phi, binVal));
                   }
 
@@ -1027,38 +995,33 @@ void TEveCaloLegoGL::DrawCells2D() const
       }
    }
 
-   if (fM->f2DMode == TEveCaloLego::kValSize)
-   {
+   if (fM->f2DMode == TEveCaloLego::kValSize) {
       TGLUtil::Color(defCol);
       glPointSize(1);
       glBegin(GL_POINTS);
       Int_t slice = 0;
-      for (vvTEveVec_i i = antiFlick.begin(); i != antiFlick.end(); ++i, ++slice)
-      {
+      for (vvTEveVec_i i = antiFlick.begin(); i != antiFlick.end(); ++i, ++slice) {
          if (fM->fTopViewUseMaxColor)
             TGLUtil::Color(fM->GetData()->GetSliceColor(slice));
 
-         for (vTEveVec_i j = i->begin(); j != i->end(); ++j)
-         {
+         for (vTEveVec_i j = i->begin(); j != i->end(); ++j) {
             glVertex3fv(j->Arr());
          }
       }
       glEnd();
    }
 }
-
 //______________________________________________________________________________
 void TEveCaloLegoGL::DirectDraw(TGLRnrCtx & rnrCtx) const
 {
    // Draw the object.
 
-   if ( ! fM->fData || ! fM->fData->GetEtaBins() || ! fM->fData->GetPhiBins())
+   if (! fM->fData || ! fM->fData->GetEtaBins() || ! fM->fData->GetPhiBins())
       return;
 
-
    // projection type
    if (fM->fProjection == TEveCaloLego::kAuto)
-      fCells3D = (! (rnrCtx.RefCamera().IsOrthographic() && rnrCtx.RefCamera().GetCamBase().GetBaseVec(1).Z()));
+      fCells3D = (!(rnrCtx.RefCamera().IsOrthographic() && rnrCtx.RefCamera().GetCamBase().GetBaseVec(1).Z()));
    else if (fM->fProjection == TEveCaloLego::k2D)
       fCells3D = kFALSE;
    else
@@ -1071,60 +1034,54 @@ void TEveCaloLegoGL::DirectDraw(TGLRnrCtx & rnrCtx) const
    Double_t em, eM, pm, pM;
    fM->fData->GetEtaLimits(em, eM);
    fM->fData->GetPhiLimits(pm, pM);
-   Double_t unit = ((eM-em) < (pM-pm)) ? (eM-em):(pM-pm);
+   Double_t unit = ((eM - em) < (pM - pm)) ? (eM - em) : (pM - pm);
    glPushMatrix();
-   Float_t sx = (eM-em)/fM->GetEtaRng();
-   Float_t sy = (pM-pm)/fM->GetPhiRng();
-   glScalef(sx/unit, sy/unit, fM->fData->Empty() ? 1: fM->GetValToHeight());
+   Float_t sx = (eM - em) / fM->GetEtaRng();
+   Float_t sy = (pM - pm) / fM->GetPhiRng();
+   glScalef(sx / unit, sy / unit, fM->fData->Empty() ? 1 : fM->GetValToHeight());
    glTranslatef(-fM->GetEta(), -fM->fPhi, 0);
 
-   // set axis
+
+   // rebin axsis , check limits, fix TwoPi cycling
    Int_t oldBinStep = fBinStep;
    fBinStep = GetGridStep(rnrCtx);
-
-   SetAxis(fM->fData->GetEtaBins(), fEtaAxis);
-   SetAxis(fM->fData->GetPhiBins(), fPhiAxis);
+   RebinAxis(fM->fData->GetEtaBins(), fEtaAxis);
+   RebinAxis(fM->fData->GetPhiBins(), fPhiAxis);
 
    // cache ids
    Bool_t idCacheChanged = kFALSE;
-   if (fM->fCellIdCacheOK == kFALSE)
-   {
+   if (fM->fCellIdCacheOK == kFALSE) {
       fM->BuildCellIdCache();
       idCacheChanged = kTRUE;
    }
 
    // rebin data
-   if (oldBinStep != fBinStep || idCacheChanged)
-   {
+   if (oldBinStep != fBinStep || idCacheChanged) {
       fDLCacheOK = kFALSE;
 
       fRebinData.fSliceData.clear();
       fRebinData.fSliceData.clear();
 
-      if (fBinStep > 1)
-      {
+      if (fBinStep > 1) {
          fM->fData->Rebin(fEtaAxis, fPhiAxis, fM->fCellList, fM->fPlotEt, fRebinData);
-         if (fM->fNormalizeRebin)
-         {
+         if (fM->fNormalizeRebin) {
             Double_t maxVal = 0;
-            for (UInt_t i=0; i<fRebinData.fSliceData.size(); i+=fRebinData.fNSlices)
-            {
+            for (UInt_t i = 0; i < fRebinData.fSliceData.size(); i += fRebinData.fNSlices) {
                Double_t sum = 0;
-               for(Int_t s=0; s<fRebinData.fNSlices; s++)
+               for (Int_t s = 0; s < fRebinData.fNSlices; s++)
                   sum += fRebinData.fSliceData[i+s];
 
                if (sum > maxVal) maxVal = sum;
             }
 
             const Float_t scale = fM->GetMaxVal() / maxVal;
-            for (std::vector<Float_t>::iterator it=fRebinData.fSliceData.begin(); it!=fRebinData.fSliceData.end(); it++)
+            for (std::vector<Float_t>::iterator it = fRebinData.fSliceData.begin(); it != fRebinData.fSliceData.end(); it++)
                (*it) *= scale;
          }
       }
    }
 
-   if (!fM->fData->Empty())
-   {
+   if (!fM->fData->Empty()) {
       glPushAttrib(GL_LINE_BIT | GL_POLYGON_BIT);
       glLineWidth(1);
       glDisable(GL_LIGHTING);
@@ -1134,13 +1091,10 @@ void TEveCaloLegoGL::DirectDraw(TGLRnrCtx & rnrCtx) const
 
       glPushName(0);
       glLoadName(0);
-      if (fCells3D)
-      {
+      if (fCells3D) {
          if (!fDLCacheOK) MakeDisplayList();
          DrawCells3D(rnrCtx);
-      }
-      else
-      {
+      } else {
          DrawCells2D();
       }
       glPopName();
@@ -1148,18 +1102,16 @@ void TEveCaloLegoGL::DirectDraw(TGLRnrCtx & rnrCtx) const
    }
 
    // draw histogram base
-   if (rnrCtx.Selection() == kFALSE && rnrCtx.Highlight() == kFALSE)
-   {
+   if (rnrCtx.Selection() == kFALSE && rnrCtx.Highlight() == kFALSE) {
       DrawHistBase(rnrCtx);
-      if (fM->fDrawHPlane)
-      {
+      if (fM->fDrawHPlane) {
          glPushAttrib(GL_ENABLE_BIT | GL_POLYGON_BIT);
          glEnable(GL_BLEND);
          glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
          glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
          glDisable(GL_CULL_FACE);
          TGLUtil::ColorTransparency(fM->fPlaneColor, fM->fPlaneTransparency);
-         Float_t zhp = fM->fHPlaneVal*fDataMax;
+         Float_t zhp = fM->fHPlaneVal * fDataMax;
          glBegin(GL_POLYGON);
          glVertex3f(fM->fEtaMin, fM->GetPhiMin(), zhp);
          glVertex3f(fM->fEtaMax, fM->GetPhiMin(), zhp);
@@ -1181,36 +1133,26 @@ void TEveCaloLegoGL::ProcessSelection(TGLRnrCtx & /*rnrCtx*/, TGLSelectRecord &
    if (rec.GetN() < 2) return;
    Int_t cellID = rec.GetItem(1);
 
-   if (fBinStep == 1)
-   {
+   if (fBinStep == 1) {
       TEveCaloData::CellData_t cellData;
       fM->fData->GetCellData(fM->fCellList[cellID], cellData);
 
-      if (fCells3D)
-      {
+      if (fCells3D) {
          printf("Bin %d selected in slice %d val %f\n",
                 fM->fCellList[cellID].fTower,
                 fM->fCellList[cellID].fSlice, cellData.fValue);
+      } else {
+         printf("Bin %d selected\n", fM->fCellList[cellID].fTower);
       }
-      else
-      {
-         printf("Bin %d selected\n",fM->fCellList[cellID].fTower);
-      }
-   }
-   else
-   {
-      if (fCells3D)
-      {
+   } else {
+      if (fCells3D) {
          Float_t* v = fRebinData.GetSliceVals(rec.GetItem(2));
          Int_t s = rec.GetItem(1);
          printf("Rebined bin %d selected in slice %d val %f\n", rec.GetItem(2), s, v[s]);
-      }
-      else
-      {
+      } else {
          Float_t* v = fRebinData.GetSliceVals(rec.GetItem(1));
-         printf("Rebined bin %d selected\n",rec.GetItem(1));
-         for (Int_t s=0; s<2; s++)
-         {
+         printf("Rebined bin %d selected\n", rec.GetItem(1));
+         for (Int_t s = 0; s < 2; s++) {
             printf("slice %d val %f\n", s, v[s]);
          }
       }
diff --git a/graf3d/eve/src/TEveCaloLegoOverlay.cxx b/graf3d/eve/src/TEveCaloLegoOverlay.cxx
new file mode 100644
index 0000000..8ac1f1d
--- /dev/null
+++ b/graf3d/eve/src/TEveCaloLegoOverlay.cxx
@@ -0,0 +1,367 @@
+// @(#)root/eve:$Id: root-5.22-00d-fireworks-graf3d-gui.patch,v 1.5 2010/10/09 09:42:53 eulisse Exp $
+// Author: Alja Mrak-Tadel 2007
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#include "TEveCaloLegoOverlay.h"
+
+#include "TAxis.h"
+
+#include "TGLRnrCtx.h"
+#include "TGLIncludes.h"
+#include "TGLSelectRecord.h"
+#include "TGLUtil.h"
+#include "TGLCamera.h"
+#include "TGLAxisPainter.h"
+
+#include "TEveCalo.h"
+#include "TEveCaloData.h"
+
+
+//______________________________________________________________________________
+//
+//
+// GL-overaly control GUI for TEveCaloLego.
+//
+//
+
+ClassImp(TEveCaloLegoOverlay);
+
+//______________________________________________________________________________
+TEveCaloLegoOverlay::TEveCaloLegoOverlay() :
+   TGLCameraOverlay(),
+   TEveElementList("Lego Menu", "TEveCaloLegoOverlay", kTRUE),
+   fHeaderSelected(kFALSE),
+
+   fCalo(0),
+   fSliderAxis(0),
+   fMainColor(kGray),
+
+   fShowCamera(kTRUE),
+   fShowPlane(kFALSE),
+
+   fMenuW(0.08),
+   fButtonW(0.5),
+   fSliderH(0.6),
+   fSliderPosY(0.15),
+
+   fShowSlider(kFALSE),
+   fSliderVal(0),
+
+   fActiveID(-1),
+   fActiveCol(kRed-4)
+{
+   // Constructor.
+  fMainColorPtr = &fMainColor;
+  fSliderAxis = new TAxis();
+
+}
+
+
+/******************************************************************************/
+void TEveCaloLegoOverlay::DrawSlider(TGLRnrCtx& rnrCtx)
+{
+   // Draw slider and calorimeter Z scale on left side of screen.
+
+   glTranslatef(0, fSliderPosY, 0.5);
+
+   // event handler
+   if (rnrCtx.Selection())
+   {
+      glLoadName(2);
+      Float_t w = fButtonW*fMenuW*0.5f;
+      glBegin(GL_QUADS);
+      glVertex2f(-w, 0);
+      glVertex2f( w, 0);
+      glVertex2f( w, fSliderH);
+      glVertex2f(-w, fSliderH);
+      glEnd();
+   }
+
+   // render
+   if ( fCalo->GetData() && fCalo->GetData()->Empty() == kFALSE)
+   {
+      // slider axis
+      Double_t maxVal = fCalo->GetMaxVal();
+      fAxisPainter->SetLabelPixelFontSize(TMath::CeilNint(rnrCtx.GetCamera()->RefViewport().Height()*0.06));
+      fAxisPainter->RefDir().Set(0, 1, 0);
+      fAxisPainter->RefTMOff(0).Set(1, 0, 0);
+      fAxisPainter->SetLabelAlign(TGLFont::kLeft);
+      fSliderAxis->SetRangeUser(0, maxVal);
+      fSliderAxis->SetLimits(0, maxVal);
+      fSliderAxis->SetNdivisions(710);
+      fSliderAxis->SetTickLength(0.02*maxVal);
+      fSliderAxis->SetLabelOffset(0.02*maxVal);
+      fSliderAxis->SetLabelSize(0.05);
+      fSliderAxis->SetAxisColor(fMainColor);
+      fSliderAxis->SetLabelColor(fMainColor);
+
+      glPushMatrix();
+      glScalef(fSliderH/maxVal, fSliderH/maxVal, 1.);
+      fAxisPainter->PaintAxis(rnrCtx, fSliderAxis);
+      glPopMatrix();
+
+      // marker
+      TGLUtil::Color((fActiveID == 2) ? fActiveCol : 3);
+      glPointSize(8);
+      glBegin(GL_POINTS);
+      glVertex3f(0, fSliderVal*fSliderH, -0.1);
+      glEnd();
+   }
+}
+
+//______________________________________________________________________________
+void TEveCaloLegoOverlay::RenderPlaneInterface(TGLRnrCtx &rnrCtx)
+{
+   // Render menu for plane-value and the plane if marked.
+
+   TGLCapabilitySwitch lights_off(GL_LIGHTING, kFALSE);
+   glPushAttrib(GL_ENABLE_BIT | GL_POLYGON_BIT | GL_LINE_BIT | GL_POINT_BIT);
+   glEnable(GL_POINT_SMOOTH);
+   glHint(GL_POINT_SMOOTH_HINT, GL_NICEST);
+   glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
+   glEnable(GL_POLYGON_OFFSET_FILL);
+   glPolygonOffset(0.1, 1);
+   glDisable(GL_CULL_FACE);
+   glEnable(GL_BLEND);
+   glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+   glPushName(0);
+
+
+   // move to the center of menu
+   glPushMatrix();
+   glTranslatef(1 -fMenuW, 0, 0); // translate to lower left corner
+
+   // button
+   glPushMatrix();
+   glTranslatef(0, (1-fButtonW )*fMenuW*0.8, 0);
+   glLoadName(1);
+   Float_t a=0.6;
+   (fActiveID == 1) ? TGLUtil::Color(fActiveCol):TGLUtil::Color4f(0, 1, 0, a);
+   Float_t bw = fButtonW*fMenuW*0.5;
+   Float_t bwt = bw*0.8;
+   Float_t bh = fButtonW*fMenuW;
+   glBegin(GL_QUADS);
+   glVertex2f(-bw, 0);
+   glVertex2f( bw, 0);
+   glVertex2f( bwt, bh);
+   glVertex2f(-bwt, bh);
+   glEnd();
+
+   TGLUtil::Color(4);
+
+   glLineWidth(1);
+   glBegin(GL_LINES);
+   glVertex2f(0, 0); glVertex2f(0, bh);
+   glVertex2f((bw+bwt)*0.5, bh*0.5); glVertex2f(-(bw+bwt)*0.5, bh*0.5);
+   glEnd();
+
+   glLineWidth(2);
+   glBegin(GL_LINE_LOOP);
+   glVertex2f(-bw, 0);
+   glVertex2f( bw, 0);
+   glVertex2f( bwt, bh);
+   glVertex2f(-bwt, bh);
+   glEnd();
+   glLineWidth(1);
+
+   glPopMatrix();
+   if (fShowSlider) DrawSlider(rnrCtx);
+
+   glPopName();
+   glPopAttrib();
+
+   glPopMatrix();
+
+}
+
+/******************************************************************************/
+void TEveCaloLegoOverlay::RenderHeader(TGLRnrCtx& rnrCtx)
+{
+   // Render text on top right corner of the screen.
+
+   TGLRect &vp = rnrCtx.GetCamera()->RefViewport();
+
+   TGLFont font;
+   Int_t fs = TGLFontManager::GetFontSize(vp.Height()*0.035, 12, 36);
+   rnrCtx.RegisterFont(fs, "arial", TGLFont::kPixmap, font);
+   Float_t off = fs*0.2;
+   Float_t bb[6];
+   font.BBox(fHeaderTxt.Data(), bb[0], bb[1], bb[2], bb[3], bb[4], bb[5]);
+   Float_t x = vp.Width() -bb[3] -off;
+   Float_t y = vp.Height() -bb[4] -off;
+   if (rnrCtx.Selection())
+   {
+      glPushName(0);
+      glLoadName(3);
+      glBegin(GL_QUADS);
+      glVertex2f(x/vp.Width(), y/ vp.Height());
+      glVertex2f(1,  y/ vp.Height());
+      glVertex2f(1, 1);
+      glVertex2f(x/vp.Width(), 1);
+      glEnd();
+      glPopName();
+   }
+   else
+   {
+      TGLUtil::Color(fHeaderSelected ? fActiveCol : fCalo->GetFontColor());
+      glRasterPos2i(0, 0);
+      glBitmap(0, 0, 0, 0, x, y, 0);
+      font.Render(fHeaderTxt.Data());
+   }
+}
+
+/******************************************************************************/
+void TEveCaloLegoOverlay::Render(TGLRnrCtx& rnrCtx)
+{
+   // Render the overlay elements.
+
+   if (fShowPlane || fHeaderTxt.Length())
+   {
+      // go to normalised coordinates
+      glMatrixMode(GL_PROJECTION);
+      glPushMatrix();
+      glLoadIdentity();
+      if (rnrCtx.Selection())
+      {
+         TGLRect rect(*rnrCtx.GetPickRectangle());
+         rnrCtx.GetCamera()->WindowToViewport(rect);
+         gluPickMatrix(rect.X(), rect.Y(), rect.Width(), rect.Height(), rnrCtx.RefCamera().RefViewport().CArr());
+      }
+      glMatrixMode(GL_MODELVIEW);
+      glPushMatrix();
+      glLoadIdentity();
+
+      glTranslatef(-1, -1, 0);
+
+      glScalef(2, 2, 1);
+      if (fShowPlane) RenderPlaneInterface(rnrCtx);
+      RenderHeader(rnrCtx);
+
+      glPopMatrix();
+      glMatrixMode(GL_PROJECTION);
+      glPopMatrix();
+      glMatrixMode(GL_MODELVIEW);
+   }
+
+
+   // call TGLCamera overlay render
+   if (fShowCamera)
+   {
+      TGLCamera& cam = rnrCtx.RefCamera();
+      TGLRect& vp = cam.RefViewport();
+      Bool_t skip = kFALSE;
+      // check if lego axis are already visible
+      if (cam.IsOrthographic())
+      {
+         using namespace TMath;
+
+         Float_t x0 = fCalo->GetEtaMin();
+         Float_t y0 = fCalo->GetPhiMin();
+
+         const GLdouble *pm = rnrCtx.RefCamera().RefLastNoPickProjM().CArr();
+         GLdouble mm[16];
+         glGetDoublev(GL_MODELVIEW_MATRIX,  mm);
+
+         GLdouble x, y, z;
+         gluProject(x0, y0, 0, mm, pm, (Int_t*)vp.CArr(), &x, &y, &z);
+         // viewport height goes from top to bottom
+         if ( x > vp.Left() && y > vp.Top())
+            skip = kTRUE;
+      }
+
+      if (!skip) TGLCameraOverlay::Render(rnrCtx);
+   }
+}
+
+/******************************************************************************/
+// Virtual event handlers from TGLOverlayElement
+/******************************************************************************/
+
+Bool_t TEveCaloLegoOverlay::SetSliderVal(Event_t* event, TGLRnrCtx &rnrCtx)
+{
+   // Set height of horizontal plane in the calorimeter.
+
+   TGLRect& wprt = rnrCtx.RefCamera().RefViewport();
+   fSliderVal = (1 -event->fY*1./wprt.Height() -fSliderPosY)/fSliderH;
+
+   if (fSliderVal < 0 )
+      fSliderVal = 0;
+   else if (fSliderVal > 1)
+      fSliderVal = 1;
+
+   fCalo->SetHPlaneVal(fSliderVal);
+
+   return kTRUE;
+}
+
+//______________________________________________________________________________
+Bool_t TEveCaloLegoOverlay::Handle(TGLRnrCtx          & rnrCtx,
+                               TGLOvlSelectRecord & rec,
+                               Event_t            * event)
+{
+   // Handle overlay event.
+   // Return TRUE if event was handled.
+
+   switch (event->fType)
+   {
+      case kMotionNotify:
+      {
+         Int_t item = rec.GetN() < 2 ? -1 : (Int_t)rec.GetItem(1);
+         if (fActiveID != item) {
+            fActiveID = item;
+            return kTRUE;
+         } else {
+            if (fActiveID == 2 && event->fState == 256)
+               return SetSliderVal(event, rnrCtx);
+
+            return kFALSE;
+         }
+         break;
+      }
+      case kButtonPress:
+      {
+         if (event->fCode != kButton1) {
+            return kFALSE;
+         }
+         switch (rec.GetItem(1))
+         {
+            case 1:
+               fShowSlider = !fShowSlider;
+               fCalo->SetDrawHPlane(fShowSlider);
+               break;
+            case 2:
+               return SetSliderVal(event, rnrCtx);
+            case 3:
+               fHeaderSelected = !fHeaderSelected;
+            default:
+               break;
+         }
+      }
+      default:
+         break;
+   }
+   return kFALSE;
+}
+
+//______________________________________________________________________________
+Bool_t TEveCaloLegoOverlay::MouseEnter(TGLOvlSelectRecord& /*rec*/)
+{
+   // Mouse has entered overlay area.
+
+   return kTRUE;
+}
+
+//______________________________________________________________________________
+void TEveCaloLegoOverlay::MouseLeave()
+{
+   // Mouse has left overlay area.
+
+   fActiveID = -1;
+}
diff --git a/graf3d/eve/src/TEveCaloVizEditor.cxx b/graf3d/eve/src/TEveCaloVizEditor.cxx
index 5c9d18f..4feb502 100644
--- a/graf3d/eve/src/TEveCaloVizEditor.cxx
+++ b/graf3d/eve/src/TEveCaloVizEditor.cxx
@@ -257,7 +257,7 @@ void TEveCaloVizEditor::SetModel(TObject* obj)
       fPhi->SetValue(fM->fPhi);
       fPhi->SetToolTip("Center angle in radians");
 
-      fPhiOffset->SetLimits(0, TMath::Pi(), 101, TGNumberFormat::kNESRealTwo);
+      fPhiOffset->SetLimits(1e-3, TMath::Pi(), 101, TGNumberFormat::kNESRealTwo);
       fPhiOffset->SetValue(fM->fPhiOffset);
       fPhiOffset->SetToolTip("Phi range in radians");
 
@@ -351,3 +351,57 @@ void TEveCaloVizEditor::DoSliceColor(Pixel_t pixel)
    fM->SetDataSliceColor(cs->WidgetId(), Color_t(TColor::GetColor(pixel)));
    Update();
 }
+
+/**************************************************************************/
+/**************************************************************************/
+/**************************************************************************/
+//______________________________________________________________________________
+// GUI editor for TEveCalo3DEditor.
+//
+
+ClassImp(TEveCalo3DEditor);
+
+//______________________________________________________________________________
+TEveCalo3DEditor::TEveCalo3DEditor(const TGWindow *p, Int_t width, Int_t height,
+                                       UInt_t options, Pixel_t back) :
+   TGedFrame(p, width, height, options | kVerticalFrame, back),
+   fM(0),
+   fFrameTransparency(0)
+{
+   // Constructor.
+
+   MakeTitle("TEveCalo3D");
+
+   TGHorizontalFrame* f = new TGHorizontalFrame(this);
+   TGLabel* lab = new TGLabel(f, "Frame transparency: ");
+   f->AddFrame(lab, new TGLayoutHints(kLHintsLeft|kLHintsBottom, 1, 1, 1, 1));
+
+   fFrameTransparency = new TGNumberEntry(f, 0., 2, -1,
+                                     TGNumberFormat::kNESInteger, TGNumberFormat::kNEANonNegative,
+                                     TGNumberFormat::kNELLimitMinMax, 0, 100);
+    
+   fFrameTransparency->SetHeight(18);
+   fFrameTransparency->GetNumberEntry()->SetToolTipText("Transparency: 0 is opaque, 100 fully transparent.");
+   f->AddFrame(fFrameTransparency, new TGLayoutHints(kLHintsLeft, 0, 0, 0, 0));
+   fFrameTransparency->Connect("ValueSet(Long_t)","TEveCalo3DEditor", this, "DoFrameTransparency()");
+
+   AddFrame(f, new TGLayoutHints(kLHintsTop, 1, 1, 1, 0));
+}
+
+//______________________________________________________________________________
+void TEveCalo3DEditor::SetModel(TObject* obj)
+{
+   // Set model object.
+
+   fM = dynamic_cast<TEveCalo3D*>(obj);
+   fFrameTransparency->SetNumber(fM->GetFrameTransparency());
+}
+
+//______________________________________________________________________________
+void TEveCalo3DEditor::DoFrameTransparency()
+{
+   // Slot for frame transparency.
+
+   fM->SetFrameTransparency((UChar_t)(fFrameTransparency->GetNumber()));
+   Update();
+}
diff --git a/graf3d/eve/src/TEveCompound.cxx b/graf3d/eve/src/TEveCompound.cxx
index ba09619..4b154d5 100644
--- a/graf3d/eve/src/TEveCompound.cxx
+++ b/graf3d/eve/src/TEveCompound.cxx
@@ -24,7 +24,7 @@
 ClassImp(TEveCompound);
 
 //______________________________________________________________________________
-TEveCompound::TEveCompound(const Text_t* n, const Text_t* t, Bool_t doColor) :
+TEveCompound::TEveCompound(const char* n, const char* t, Bool_t doColor) :
    TEveElementList (n, t, doColor),
    TEveProjectable (),
    fCompoundOpen   (0)
diff --git a/graf3d/eve/src/TEveDigitSet.cxx b/graf3d/eve/src/TEveDigitSet.cxx
index e8ebfeb..5b2595a 100644
--- a/graf3d/eve/src/TEveDigitSet.cxx
+++ b/graf3d/eve/src/TEveDigitSet.cxx
@@ -47,7 +47,7 @@
 ClassImp(TEveDigitSet);
 
 //______________________________________________________________________________
-TEveDigitSet::TEveDigitSet(const Text_t* n, const Text_t* t) :
+TEveDigitSet::TEveDigitSet(const char* n, const char* t) :
    TEveElement     (),
    TNamed          (n, t),
 
diff --git a/graf3d/eve/src/TEveElement.cxx b/graf3d/eve/src/TEveElement.cxx
index 38166f4..4fd8c71 100644
--- a/graf3d/eve/src/TEveElement.cxx
+++ b/graf3d/eve/src/TEveElement.cxx
@@ -232,7 +232,7 @@ void TEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level) const
 /******************************************************************************/
 
 //______________________________________________________________________________
-const Text_t* TEveElement::GetElementName() const
+const char* TEveElement::GetElementName() const
 {
    // Virtual function for retrieveing name of the element.
    // Here we attempt to cast the assigned object into TNamed and call
@@ -245,7 +245,7 @@ const Text_t* TEveElement::GetElementName() const
 }
 
 //______________________________________________________________________________
-const Text_t*  TEveElement::GetElementTitle() const
+const char*  TEveElement::GetElementTitle() const
 {
    // Virtual function for retrieveing title of the render-element.
    // Here we attempt to cast the assigned object into TNamed and call
@@ -258,7 +258,7 @@ const Text_t*  TEveElement::GetElementTitle() const
 }
 
 //______________________________________________________________________________
-void TEveElement::SetElementName(const Text_t* name)
+void TEveElement::SetElementName(const char* name)
 {
    // Virtual function for setting of name of an element.
    // Here we attempt to cast the assigned object into TNamed and call
@@ -275,7 +275,7 @@ void TEveElement::SetElementName(const Text_t* name)
 }
 
 //______________________________________________________________________________
-void TEveElement::SetElementTitle(const Text_t* title)
+void TEveElement::SetElementTitle(const char* title)
 {
    // Virtual function for setting of title of an element.
    // Here we attempt to cast the assigned object into TNamed and call
@@ -292,7 +292,7 @@ void TEveElement::SetElementTitle(const Text_t* title)
 }
 
 //______________________________________________________________________________
-void TEveElement::SetElementNameTitle(const Text_t* name, const Text_t* title)
+void TEveElement::SetElementNameTitle(const char* name, const char* title)
 {
    // Virtual function for setting of name and title of render element.
    // Here we attempt to cast the assigned object into TNamed and call
@@ -899,12 +899,60 @@ void TEveElement::SpawnEditor()
 }
 
 //______________________________________________________________________________
-void TEveElement::ExportToCINT(Text_t* var_name)
+void TEveElement::ExportToCINT(char* var_name)
 {
    // Export render-element to CINT with variable name var_name.
 
    const char* cname = IsA()->GetName();
-   gROOT->ProcessLine(Form("%s* %s = (%s*)0x%lx;", cname, var_name, cname, this));
+   gROOT->ProcessLine(TString::Format("%s* %s = (%s*)0x%lx;", cname, var_name, cname, this));
+}
+
+/******************************************************************************/
+
+//______________________________________________________________________________
+void TEveElement::DumpSourceObject() const
+{
+   // Call Dump() on source object.
+   // Throws an exception if it is not set.
+
+   static const TEveException eh("TEveElement::DumpSourceObject ");
+
+   TObject *so = GetSourceObject();
+   if (!so)
+      throw eh + "source-object not set.";
+
+   so->Dump();
+}
+
+//______________________________________________________________________________
+void TEveElement::PrintSourceObject() const
+{
+   // Call Print() on source object.
+   // Throws an exception if it is not set.
+
+   static const TEveException eh("TEveElement::PrintSourceObject ");
+
+   TObject *so = GetSourceObject();
+   if (!so)
+      throw eh + "source-object not set.";
+
+   so->Print();
+}
+
+//______________________________________________________________________________
+void TEveElement::ExportSourceObjectToCINT(char* var_name) const
+{
+   // Export source object to CINT with given name for the variable.
+   // Throws an exception if it is not set.
+
+   static const TEveException eh("TEveElement::ExportSourceObjectToCINT ");
+
+   TObject *so = GetSourceObject();
+   if (!so)
+      throw eh + "source-object not set.";
+
+   const char* cname = so->IsA()->GetName();
+   gROOT->ProcessLine(TString::Format("%s* %s = (%s*)0x%lx;", cname, var_name, cname, so));
 }
 
 /******************************************************************************/
@@ -1019,7 +1067,7 @@ void TEveElement::PropagateRnrStateToProjecteds()
    // Propagate render state to the projected replicas of this element.
    // Maybe this should be optional on gEve/element level.
 
-   TEveProjectable* pable = dynamic_cast<TEveProjectable*>(this);
+   TEveProjectable *pable = dynamic_cast<TEveProjectable*>(this);
    if (pable && pable->HasProjecteds())
    {
       pable->PropagateRenderState(fRnrSelf, fRnrChildren);
@@ -1691,7 +1739,7 @@ TObject* TEveElementObjectPtr::GetObject(const TEveException& eh) const
 }
 
 //______________________________________________________________________________
-void TEveElementObjectPtr::ExportToCINT(Text_t* var_name)
+void TEveElementObjectPtr::ExportToCINT(char* var_name)
 {
    // Export external object to CINT with variable name var_name.
    // Virtual from TEveElement.
@@ -1732,7 +1780,7 @@ TEveElementObjectPtr::~TEveElementObjectPtr()
 ClassImp(TEveElementList);
 
 //______________________________________________________________________________
-TEveElementList::TEveElementList(const Text_t* n, const Text_t* t, Bool_t doColor) :
+TEveElementList::TEveElementList(const char* n, const char* t, Bool_t doColor) :
    TEveElement(),
    TNamed(n, t),
    fColor(0),
diff --git a/graf3d/eve/src/TEveEventManager.cxx b/graf3d/eve/src/TEveEventManager.cxx
index 4308b90..14e3dbb 100644
--- a/graf3d/eve/src/TEveEventManager.cxx
+++ b/graf3d/eve/src/TEveEventManager.cxx
@@ -22,7 +22,7 @@
 ClassImp(TEveEventManager)
 
 //______________________________________________________________________________
-TEveEventManager::TEveEventManager(const Text_t* n, const Text_t* t) :
+TEveEventManager::TEveEventManager(const char* n, const char* t) :
    TEveElementList(n, t),
    fNewEventCommands()
 {
diff --git a/graf3d/eve/src/TEveGValuators.cxx b/graf3d/eve/src/TEveGValuators.cxx
index a271ee9..1cc2745 100644
--- a/graf3d/eve/src/TEveGValuators.cxx
+++ b/graf3d/eve/src/TEveGValuators.cxx
@@ -224,7 +224,7 @@ void TEveGValuator::SetValue(Float_t val, Bool_t emit)
 }
 
 //______________________________________________________________________________
-void TEveGValuator::SetToolTip(const Text_t* tip)
+void TEveGValuator::SetToolTip(const char* tip)
 {
    // Set the tooltip of the number-entry.
 
diff --git a/graf3d/eve/src/TEveGeoNode.cxx b/graf3d/eve/src/TEveGeoNode.cxx
index d138171..7492a47 100644
--- a/graf3d/eve/src/TEveGeoNode.cxx
+++ b/graf3d/eve/src/TEveGeoNode.cxx
@@ -58,7 +58,7 @@ TEveGeoNode::TEveGeoNode(TGeoNode* node) :
 }
 
 //______________________________________________________________________________
-const Text_t* TEveGeoNode::GetName()  const
+const char* TEveGeoNode::GetName()  const
 {
    // Return name, taken from geo-node. Used via TObject.
 
@@ -66,7 +66,7 @@ const Text_t* TEveGeoNode::GetName()  const
 }
 
 //______________________________________________________________________________
-const Text_t* TEveGeoNode::GetTitle() const
+const char* TEveGeoNode::GetTitle() const
 {
    // Return title, taken from geo-node. Used via TObject.
 
@@ -74,7 +74,7 @@ const Text_t* TEveGeoNode::GetTitle() const
 }
 
 //______________________________________________________________________________
-const Text_t* TEveGeoNode::GetElementName()  const
+const char* TEveGeoNode::GetElementName()  const
 {
    // Return name, taken from geo-node. Used via TEveElement.
 
@@ -82,7 +82,7 @@ const Text_t* TEveGeoNode::GetElementName()  const
 }
 
 //______________________________________________________________________________
-const Text_t* TEveGeoNode::GetElementTitle() const
+const char* TEveGeoNode::GetElementTitle() const
 {
    // Return title, taken from geo-node. Used via TEveElement.
 
@@ -473,6 +473,9 @@ void TEveGeoTopNode::NodeVisChanged(TGeoNode* node)
 // attributes allowing display of extracted TGeoShape's (without an
 // active TGeoManager) and simplified geometries (needed for NLT
 // projections).
+//
+// TGeoCompositeShapes are currently NOT supported. This is planned
+// for ROOT-5.24.
 
 namespace
 {
@@ -505,7 +508,7 @@ TGeoManager* TEveGeoShape::GetGeoMangeur()
 }
 
 //______________________________________________________________________________
-TEveGeoShape::TEveGeoShape(const Text_t* name, const Text_t* title) :
+TEveGeoShape::TEveGeoShape(const char* name, const char* title) :
    TEveElement   (fColor),
    TNamed        (name, title),
    fColor        (0),
diff --git a/graf3d/eve/src/TEveGeoShapeExtract.cxx b/graf3d/eve/src/TEveGeoShapeExtract.cxx
index 05bb23b..9c86976 100644
--- a/graf3d/eve/src/TEveGeoShapeExtract.cxx
+++ b/graf3d/eve/src/TEveGeoShapeExtract.cxx
@@ -31,7 +31,7 @@
 ClassImp(TEveGeoShapeExtract);
 
 //______________________________________________________________________________
-TEveGeoShapeExtract::TEveGeoShapeExtract(const Text_t* n, const Text_t* t) :
+TEveGeoShapeExtract::TEveGeoShapeExtract(const char* n, const char* t) :
    TNamed       (n,t),
 
    fRnrSelf     (kTRUE),
diff --git a/graf3d/eve/src/TEveJetCone.cxx b/graf3d/eve/src/TEveJetCone.cxx
new file mode 100644
index 0000000..1c0c446
--- /dev/null
+++ b/graf3d/eve/src/TEveJetCone.cxx
@@ -0,0 +1,174 @@
+// @(#)root/eve:$Id: root-5.22-00d-fireworks-graf3d-gui.patch,v 1.5 2010/10/09 09:42:53 eulisse Exp $
+// Author: Matevz Tadel, Jochen Thaeder 2009
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#include "TEveJetCone.h"
+#include "TEveTrans.h"
+
+#include "TBuffer3D.h"
+#include "TBuffer3DTypes.h"
+#include "TVirtualPad.h"
+#include "TVirtualViewer3D.h"
+
+#include "TMath.h"
+
+//______________________________________________________________________________
+//
+// Draws a jet cone with leading particle is specified in (eta,phi) and
+// cone radius is given.
+//
+// If Apex is not set, default is (0.,0.,0.)
+// In case of cylinder was set, cone is cut at the cylinder edges
+// example :
+//
+//  Float_t coneEta    = r.Uniform(-0.9, 0.9);
+//  Float_t conePhi    = r.Uniform(0.0, TwoPi() );
+//  Float_t coneRadius = 0.4;
+//
+//  TEveJetCone* jetCone = new TEveJetCone("JetCone");
+//  jetCone->SetCylinder( 250., 250. );
+//  if ( (jetCone->AddCone( coneEta, conePhi, coneRadius   ) ) != -1)
+//    gEve->AddElement( jetCone );
+//
+
+ClassImp(TEveJetCone);
+
+//______________________________________________________________________________
+TEveJetCone::TEveJetCone(const Text_t* n, const Text_t* t) :
+   TEveElementList(n, t, kTRUE),
+   TAttBBox(),
+   fApex( TEveVector(0.,0.,0.) ),
+   fBasePoints(),
+   fCylinderBorder( TEveVector(-1.,0.,-1.) ),
+   fThetaC(0.)
+{
+   // Constructor.
+
+   fColor = kGreen;
+}
+
+
+/******************************************************************************/
+
+//______________________________________________________________________________
+void TEveJetCone::ComputeBBox()
+{
+   // Compute bounding-box of the data.
+
+   BBoxInit();
+   BBoxCheckPoint(fApex);
+   for (vTEveVector_ci i = fBasePoints.begin(); i != fBasePoints.end(); ++i)
+   {
+      BBoxCheckPoint(*i);
+   }
+}
+
+//______________________________________________________________________________
+void TEveJetCone::Paint(Option_t*)
+{
+   // Paint object.
+   // This is for direct rendering (using TEveJetConeGL class).
+
+   static const TEveException eh("TEveJetCone::Paint ");
+
+   if (fRnrSelf == kFALSE) return;
+
+   TBuffer3D buff(TBuffer3DTypes::kGeneric);
+
+   // Section kCore
+   buff.fID           = this;
+   buff.fColor        = GetMainColor();
+   buff.fTransparency = GetMainTransparency();
+   if (HasMainTrans())
+      RefMainTrans().SetBuffer3D(buff);
+   buff.SetSectionsValid(TBuffer3D::kCore);
+
+   Int_t reqSections = gPad->GetViewer3D()->AddObject(buff);
+   if (reqSections != TBuffer3D::kNone)
+      Error(eh, "only direct GL rendering supported.");
+}
+
+//______________________________________________________________________________
+Int_t TEveJetCone::AddCone( const Float_t& eta, const Float_t& phi, const Float_t& coneRadius, const Float_t& height )
+{
+   // Add jet cone
+   // parameters are :
+   // * (eta,phi)    : of the center/leading particle
+   // * coneRadius   : in eta-phi space
+   // * height       : height of the cone
+   //                  * if cylinder is set and length is adapted to cylinder.
+   //                    - if height is given, it will be used as scalar factor
+   //                  * if cylinder is not set, height is used as height of the cone
+   // Return 0 on sucess
+
+   if ( fCylinderBorder.fZ == -1. && fCylinderBorder.fX == -1. && height == -1 )
+      return -1;
+
+   TEveVector coneAxis;
+   FillTEveVectorFromEtaPhi( coneAxis, eta, phi );
+
+   Float_t angleRad = 0.;
+   for ( Float_t angle = 0.; angle < 360. ; angle+=5. , angleRad=angle*TMath::Pi()/180 ) {
+
+      // -- Get Contour point
+      TEveVector contourPoint;
+      FillTEveVectorFromEtaPhi( contourPoint,
+                                eta + coneRadius * TMath::Cos(angleRad),
+                                phi + coneRadius * TMath::Sin(angleRad) );
+
+      // -- Set length of the contourPoint
+      if ( fCylinderBorder.fZ != -1. && fCylinderBorder.fX != -1. ) {
+         if ( contourPoint.Theta() < fThetaC )
+            contourPoint *= fCylinderBorder.fZ / TMath::Cos( contourPoint.Theta() ) ;
+         else if ( contourPoint.Theta() > ( TMath::Pi() - fThetaC ) )
+            contourPoint *= fCylinderBorder.fZ / TMath::Cos( contourPoint.Theta() - TMath::Pi() ) ;
+         else
+            contourPoint *= fCylinderBorder.fX / TMath::Sin( contourPoint.Theta() ) ;
+
+         if ( height != -1 ) contourPoint *= height;
+      }
+      else {
+         contourPoint *= height / GetArcCosConeOpeningAngle( coneAxis, contourPoint );
+      }
+
+      // -- Add contourPoint
+      fBasePoints.push_back( contourPoint );
+   }
+
+   return 0;
+}
+
+//______________________________________________________________________________
+void TEveJetCone::FillTEveVectorFromEtaPhi( TEveVector &vec, const Float_t& eta, const Float_t& phi )
+{
+   // Fill TEveVector with eta and phi, with magnitude 1.
+
+   vec.Set( TMath::Cos(phi) / TMath::CosH(eta),
+            TMath::Sin(phi) / TMath::CosH(eta),
+            TMath::TanH(eta) );
+   return;
+}
+
+//______________________________________________________________________________
+Float_t TEveJetCone::GetArcCosConeOpeningAngle( const TEveVector& axis, const TEveVector& contour )
+{
+   // Return the arccos of the opening angle between two eve vectors
+
+   Float_t arcCos = 0.;
+
+   Float_t tot2 = axis.Mag2() * contour.Mag2();
+   if( tot2 > 0. ) {
+      arcCos = axis.Dot( contour )/ TMath::Sqrt( tot2 );
+      if (arcCos >  1.0) arcCos =  1.0;
+      if (arcCos < -1.0) arcCos = -1.0;
+   }
+
+   return arcCos;
+}
diff --git a/graf3d/eve/src/TEveJetConeEditor.cxx b/graf3d/eve/src/TEveJetConeEditor.cxx
new file mode 100644
index 0000000..2b0af68
--- /dev/null
+++ b/graf3d/eve/src/TEveJetConeEditor.cxx
@@ -0,0 +1,73 @@
+// @(#)root/eve:$Id: root-5.22-00d-fireworks-graf3d-gui.patch,v 1.5 2010/10/09 09:42:53 eulisse Exp $
+// Author: Matevz Tadel, Jochen Thaeder 2009
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#include "TEveJetConeEditor.h"
+#include "TEveJetCone.h"
+
+#include "TVirtualPad.h"
+#include "TColor.h"
+
+// Cleanup these includes:
+#include "TGLabel.h"
+#include "TGButton.h"
+#include "TGNumberEntry.h"
+#include "TGColorSelect.h"
+#include "TGDoubleSlider.h"
+
+
+//______________________________________________________________________________
+// GUI editor for TEveJetCone.
+//
+
+ClassImp(TEveJetConeEditor);
+
+//______________________________________________________________________________
+TEveJetConeEditor::TEveJetConeEditor(const TGWindow *p, Int_t width, Int_t height,
+                                     UInt_t options, Pixel_t back) :
+   TGedFrame(p, width, height, options | kVerticalFrame, back),
+   fM(0)
+   // Initialize widget pointers to 0
+{
+   // Constructor.
+
+   MakeTitle("TEveJetCone");
+
+   // Create widgets
+   // fXYZZ = new TGSomeWidget(this, ...);
+   // AddFrame(fXYZZ, new TGLayoutHints(...));
+   // fXYZZ->Connect("SignalName()", "Reve::TEveJetConeEditor", this, "DoXYZZ()");
+}
+
+/******************************************************************************/
+
+//______________________________________________________________________________
+void TEveJetConeEditor::SetModel(TObject* obj)
+{
+   // Set model object.
+
+   fM = dynamic_cast<TEveJetCone*>(obj);
+
+   // Set values of widgets
+   // fXYZZ->SetValue(fM->GetXYZZ());
+}
+
+/******************************************************************************/
+
+// Implements callback/slot methods
+
+//______________________________________________________________________________
+// void TEveJetConeEditor::DoXYZZ()
+// {
+//    // Slot for XYZZ.
+//
+//    fM->SetXYZZ(fXYZZ->GetValue());
+//    Update();
+// }
diff --git a/graf3d/eve/src/TEveJetConeGL.cxx b/graf3d/eve/src/TEveJetConeGL.cxx
new file mode 100644
index 0000000..f6b7b3e
--- /dev/null
+++ b/graf3d/eve/src/TEveJetConeGL.cxx
@@ -0,0 +1,104 @@
+// @(#)root/eve:$Id: root-5.22-00d-fireworks-graf3d-gui.patch,v 1.5 2010/10/09 09:42:53 eulisse Exp $
+// Author: Matevz Tadel, Jochen Thaeder 2009
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#include "TEveJetConeGL.h"
+#include "TEveJetCone.h"
+
+#include "TMath.h"
+
+#include "TGLRnrCtx.h"
+#include "TGLIncludes.h"
+
+//______________________________________________________________________________
+// OpenGL renderer class for TEveJetCone.
+//
+
+ClassImp(TEveJetConeGL);
+
+//______________________________________________________________________________
+TEveJetConeGL::TEveJetConeGL() :
+   TGLObject(), fM(0)
+{
+   // Constructor.
+
+   // fDLCache = kFALSE; // Disable display list.
+}
+
+/******************************************************************************/
+
+//______________________________________________________________________________
+Bool_t TEveJetConeGL::SetModel(TObject* obj, const Option_t* /*opt*/)
+{
+   // Set model object.
+
+   if (SetModelCheckClass(obj, TEveJetCone::Class())) {
+      fM = dynamic_cast<TEveJetCone*>(obj);
+      return kTRUE;
+   }
+   return kFALSE;
+}
+
+//______________________________________________________________________________
+void TEveJetConeGL::SetBBox()
+{
+   // Set bounding box.
+
+   // !! This ok if master sub-classed from TAttBBox
+   SetAxisAlignedBBox(((TEveJetCone*)fExternalObj)->AssertBBox());
+}
+
+/******************************************************************************/
+
+//______________________________________________________________________________
+void TEveJetConeGL::DirectDraw(TGLRnrCtx& /*rnrCtx*/) const
+{
+   // Render with OpenGL.
+
+   // printf("TEveJetConeGL::DirectDraw LOD %d\n", rnrCtx.CombiLOD());
+
+   glPushAttrib(GL_ENABLE_BIT | GL_POLYGON_BIT);
+
+   glDisable(GL_CULL_FACE);
+   glEnable(GL_NORMALIZE);
+
+   glBegin(GL_TRIANGLE_FAN);
+   glVertex3fv(fM->fApex);
+   if ( fM->fBasePoints.size() > 2)
+   {
+      TEveJetCone::vTEveVector_ci prev = fM->fBasePoints.end(); --prev;
+      TEveJetCone::vTEveVector_ci i    = fM->fBasePoints.begin();
+      TEveJetCone::vTEveVector_ci next = i; ++next;
+
+      TEveVector norm_buf;
+      TEveVector beg_normal = TMath::Cross((*i - fM->fApex).Arr(), (*next - *prev).Arr(), norm_buf.Arr());
+
+      glNormal3fv(beg_normal);
+      glVertex3fv(fM->fBasePoints.front());
+
+      prev = i;  i = next;  ++next;
+
+      while (i != fM->fBasePoints.begin())
+      {
+         glNormal3fv(TMath::Cross((*i - fM->fApex).Arr(), (*next - *prev).Arr(), norm_buf.Arr()));
+         glVertex3fv(*i);
+
+         prev = i;
+         i    = next;
+         ++next; if (next == fM->fBasePoints.end()) next = fM->fBasePoints.begin();
+      }
+
+      glNormal3fv(beg_normal);
+      glVertex3fv(fM->fBasePoints.front());
+   }
+   glEnd();
+
+   glPopAttrib();
+}
diff --git a/graf3d/eve/src/TEveLegoOverlay.cxx b/graf3d/eve/src/TEveLegoOverlay.cxx
index ebe58bb..b95ba95 100644
--- a/graf3d/eve/src/TEveLegoOverlay.cxx
+++ b/graf3d/eve/src/TEveLegoOverlay.cxx
@@ -1,360 +1,2 @@
 // @(#)root/eve:$Id: root-5.22-00d-fireworks-graf3d-gui.patch,v 1.5 2010/10/09 09:42:53 eulisse Exp $
-// Author: Matevz Tadel 2007
-
-/*************************************************************************
- * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
- * All rights reserved.                                                  *
- *                                                                       *
- * For the licensing terms see $ROOTSYS/LICENSE.                         *
- * For the list of contributors see $ROOTSYS/README/CREDITS.             *
- *************************************************************************/
-
-#include "TEveLegoOverlay.h"
-
-#include "TEveCalo.h"
-#include "TEveCaloData.h"
-
-#include <TGLRnrCtx.h>
-#include <TGLIncludes.h>
-#include <TGLSelectRecord.h>
-#include <TGLUtil.h>
-#include <TGLCamera.h>
-
-//______________________________________________________________________________
-//
-//
-// GL-overaly control GUI for TEveCaloLego.
-//
-//
-
-ClassImp(TEveLegoOverlay);
-
-//______________________________________________________________________________
-TEveLegoOverlay::TEveLegoOverlay() :
-   TGLCameraOverlay(),
-   TEveElementList("Lego Menu", "TEveLegoOverlay", kTRUE),
-   fHeaderSelected(kFALSE),
-
-   fCalo(0),
-   fMainColor(kGray),
-
-   fShowCamera(kTRUE),
-   fShowPlane(kFALSE),
-
-   fMenuW(0.08),
-   fButtonW(0.5),
-   fSliderH(0.6),
-   fSliderPosY(0.15),
-
-   fShowSlider(kFALSE),
-   fSliderVal(0),
-
-   fActiveID(-1),
-   fActiveCol(kRed-4)
-{
-   // Constructor.
-  fMainColorPtr = &fMainColor;
-
-}
-
-
-/******************************************************************************/
-void TEveLegoOverlay::DrawSlider(TGLRnrCtx& rnrCtx)
-{
-   // Draw slider and calorimeter Z scale on left side of screen.
-
-   glTranslatef(0, fSliderPosY, 0.5);
-
-   // event handling
-   if (rnrCtx.Selection())
-   {
-      glLoadName(2);
-      Float_t w = fButtonW*fMenuW*0.5f;
-      glBegin(GL_QUADS);
-      glVertex2f(-w, 0);
-      glVertex2f( w, 0);
-      glVertex2f( w, fSliderH);
-      glVertex2f(-w, fSliderH);
-      glEnd();
-   }
-
-   // drawing
-   if ( fCalo->GetData() && fCalo->GetData()->Empty() == kFALSE)
-   {
-      // axis
-      Double_t maxVal = fCalo->GetMaxVal();
-      TGLRect& wprt = rnrCtx.RefCamera().RefViewport();
-      Float_t fs = wprt.Height()*fSliderH* fAxisAtt.GetLabelSize();
-      fAxisAtt.SetAbsLabelFontSize(TGLFontManager::GetFontSize(fs, 12, 36));
-
-      fAxisAtt.RefDir().Set(0, 1, 0);
-      fAxisAtt.SetTextAlign(TGLFont::kLeft);
-      fAxisAtt.SetRng(0, maxVal);
-      fAxisAtt.RefTMOff(0).X() = -maxVal*0.03;
-      fAxisAtt.SetAbsLabelFontSize(TMath::Nint(fs));
-
-      glPushMatrix();
-      glScalef( fSliderH/maxVal, fSliderH/maxVal, 1.);
-      fAxisAtt.SetAxisColor(fMainColor);
-      fAxisAtt.SetLabelColor(fMainColor);
-      fAxisPainter.Paint(rnrCtx, fAxisAtt);
-      glPopMatrix();
-
-      // marker
-      TGLUtil::Color((fActiveID == 2) ? fActiveCol : 3);
-      glPointSize(8);
-      glBegin(GL_POINTS);
-      glVertex3f(0, fSliderVal*fSliderH, -0.1);
-      glEnd();
-   }
-}
-
-//______________________________________________________________________________
-void TEveLegoOverlay::RenderPlaneInterface(TGLRnrCtx &rnrCtx)
-{
-   // Render menu for plane-value and the plane if marked.
-
-   TGLCapabilitySwitch lights_off(GL_LIGHTING, kFALSE);
-   glPushAttrib(GL_ENABLE_BIT | GL_POLYGON_BIT | GL_LINE_BIT | GL_POINT_BIT);
-   glEnable(GL_POINT_SMOOTH);
-   glHint(GL_POINT_SMOOTH_HINT, GL_NICEST);
-   glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
-   glEnable(GL_POLYGON_OFFSET_FILL);
-   glPolygonOffset(0.1, 1);
-   glDisable(GL_CULL_FACE);
-   glEnable(GL_BLEND);
-   glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-   glPushName(0);
-
-
-   // move to the center of menu
-   glPushMatrix();
-   glTranslatef(1 -fMenuW, 0, 0); // translate to lower left corner
-
-   // button
-   glPushMatrix();
-   glTranslatef(0, (1-fButtonW )*fMenuW*0.8, 0);
-   glLoadName(1);
-   Float_t a=0.6;
-   (fActiveID == 1) ? TGLUtil::Color(fActiveCol):TGLUtil::Color4f(0, 1, 0, a);
-   Float_t bw = fButtonW*fMenuW*0.5;
-   Float_t bwt = bw*0.8;
-   Float_t bh = fButtonW*fMenuW;
-   glBegin(GL_QUADS);
-   glVertex2f(-bw, 0);
-   glVertex2f( bw, 0);
-   glVertex2f( bwt, bh);
-   glVertex2f(-bwt, bh);
-   glEnd();
-
-   TGLUtil::Color(4);
-
-   glLineWidth(1);
-   glBegin(GL_LINES);
-   glVertex2f(0, 0); glVertex2f(0, bh);
-   glVertex2f((bw+bwt)*0.5, bh*0.5); glVertex2f(-(bw+bwt)*0.5, bh*0.5);
-   glEnd();
-
-   glLineWidth(2);
-   glBegin(GL_LINE_LOOP);
-   glVertex2f(-bw, 0);
-   glVertex2f( bw, 0);
-   glVertex2f( bwt, bh);
-   glVertex2f(-bwt, bh);
-   glEnd();
-
-   glPopMatrix();
-
-   if (fShowSlider) DrawSlider(rnrCtx);
-
-   glPopName();
-   glPopAttrib();
-
-   glPopMatrix();
-
-}
-
-/******************************************************************************/
-void TEveLegoOverlay::RenderHeader(TGLRnrCtx& rnrCtx)
-{
-   // Render text on top right corner of the screen.
-
-   TGLRect &vp = rnrCtx.GetCamera()->RefViewport();
-
-   TGLFont font;
-   Int_t fs = TGLFontManager::GetFontSize(vp.Height()*0.035, 12, 36);
-   rnrCtx.RegisterFont(fs, "arial", TGLFont::kPixmap, font);
-   Float_t off = fs*0.2;
-   Float_t bb[6];
-   font.BBox(fHeaderTxt.Data(), bb[0], bb[1], bb[2], bb[3], bb[4], bb[5]);
-   Float_t x = vp.Width() -bb[3] -off;
-   Float_t y = vp.Height() -bb[4] -off;
-   if (rnrCtx.Selection())
-   {
-      glPushName(0);
-      glLoadName(3);
-      glBegin(GL_QUADS);
-      glVertex2f(x/vp.Width(), y/ vp.Height());
-      glVertex2f(1,  y/ vp.Height());
-      glVertex2f(1, 1);
-      glVertex2f(x/vp.Width(), 1);
-      glEnd();
-      glPopName();
-   }
-   else
-   {
-      TGLUtil::Color(fHeaderSelected ? fActiveCol : fCalo->GetFontColor());
-      glRasterPos2i(0, 0);
-      glBitmap(0, 0, 0, 0, x, y, 0);
-      font.Render(fHeaderTxt.Data());
-   }
-}
-
-/******************************************************************************/
-void TEveLegoOverlay::Render(TGLRnrCtx& rnrCtx)
-{
-   // Render the overlay elements.
-
-   if (fShowPlane || fHeaderTxt.Length())
-   {
-      // go to normalised coordinates
-      glMatrixMode(GL_PROJECTION);
-      glPushMatrix();
-      glLoadIdentity();
-      if (rnrCtx.Selection())
-      {
-         TGLRect rect(*rnrCtx.GetPickRectangle());
-         rnrCtx.GetCamera()->WindowToViewport(rect);
-         gluPickMatrix(rect.X(), rect.Y(), rect.Width(), rect.Height(), rnrCtx.RefCamera().RefViewport().CArr());
-      }
-      glMatrixMode(GL_MODELVIEW);
-      glPushMatrix();
-      glLoadIdentity();
-
-      glTranslatef(-1, -1, 0);
-
-      glScalef(2, 2, 1);
-      if (fShowPlane) RenderPlaneInterface(rnrCtx);
-      RenderHeader(rnrCtx);
-
-      glPopMatrix();
-      glMatrixMode(GL_PROJECTION);
-      glPopMatrix();
-      glMatrixMode(GL_MODELVIEW);
-   }
-
-
-   // call TGLCamera overlay render
-   if (fShowCamera)
-   {
-      TGLCamera& cam = rnrCtx.RefCamera();
-      TGLRect& vp = cam.RefViewport();
-      Bool_t skip = kFALSE;
-      // check if lego axis are already visible
-      if (cam.IsOrthographic())
-      {
-         using namespace TMath;
-
-         Float_t x0 = fCalo->GetEtaMin();
-         Float_t y0 = fCalo->GetPhiMin();
-
-         const GLdouble *pm = rnrCtx.RefCamera().RefLastNoPickProjM().CArr();
-         GLdouble mm[16];
-         glGetDoublev(GL_MODELVIEW_MATRIX,  mm);
-
-         GLdouble x, y, z;
-         gluProject(x0, y0, 0, mm, pm, (Int_t*)vp.CArr(), &x, &y, &z);
-         // viewport height goes from top to bottom
-         if ( x > vp.Left() && y > vp.Top())
-            skip = kTRUE;
-      }
-
-      if (!skip) TGLCameraOverlay::Render(rnrCtx);
-   }
-}
-
-/******************************************************************************/
-// Virtual event handlers from TGLOverlayElement
-/******************************************************************************/
-
-Bool_t TEveLegoOverlay::SetSliderVal(Event_t* event, TGLRnrCtx &rnrCtx)
-{
-   // Set height of horizontal plane in the calorimeter.
-
-   TGLRect& wprt = rnrCtx.RefCamera().RefViewport();
-   fSliderVal = (1 -event->fY*1./wprt.Height() -fSliderPosY)/fSliderH;
-
-   if (fSliderVal < 0 )
-      fSliderVal = 0;
-   else if (fSliderVal > 1)
-      fSliderVal = 1;
-
-   fCalo->SetHPlaneVal(fSliderVal);
-
-   return kTRUE;
-}
-
-//______________________________________________________________________________
-Bool_t TEveLegoOverlay::Handle(TGLRnrCtx          & rnrCtx,
-                               TGLOvlSelectRecord & rec,
-                               Event_t            * event)
-{
-   // Handle overlay event.
-   // Return TRUE if event was handled.
-
-   switch (event->fType)
-   {
-      case kMotionNotify:
-      {
-         Int_t item = rec.GetN() < 2 ? -1 : (Int_t)rec.GetItem(1);
-         if (fActiveID != item) {
-            fActiveID = item;
-            return kTRUE;
-         } else {
-            if (fActiveID == 2 && event->fState == 256)
-               return SetSliderVal(event, rnrCtx);
-
-            return kFALSE;
-         }
-         break;
-      }
-      case kButtonPress:
-      {
-         if (event->fCode != kButton1) {
-            return kFALSE;
-         }
-         switch (rec.GetItem(1))
-         {
-            case 1:
-               fShowSlider = !fShowSlider;
-               fCalo->SetDrawHPlane(fShowSlider);
-               break;
-            case 2:
-               return SetSliderVal(event, rnrCtx);
-            case 3:
-               fHeaderSelected = !fHeaderSelected;
-            default:
-               break;
-         }
-      }
-      default:
-         break;
-   }
-   return kFALSE;
-}
-
-//______________________________________________________________________________
-Bool_t TEveLegoOverlay::MouseEnter(TGLOvlSelectRecord& /*rec*/)
-{
-   // Mouse has entered overlay area.
-
-   return kTRUE;
-}
-
-//______________________________________________________________________________
-void TEveLegoOverlay::MouseLeave()
-{
-   // Mouse has left overlay area.
-
-   fActiveID = -1;
-}
+// Dummy file ... removed in ROOT trunk and fireworks branch.
diff --git a/graf3d/eve/src/TEveLine.cxx b/graf3d/eve/src/TEveLine.cxx
index 3871dd2..dc4f5cd 100644
--- a/graf3d/eve/src/TEveLine.cxx
+++ b/graf3d/eve/src/TEveLine.cxx
@@ -39,7 +39,7 @@ TEveLine::TEveLine(Int_t n_points, ETreeVarType_e tv_type) :
 }
 
 //______________________________________________________________________________
-TEveLine::TEveLine(const Text_t* name, Int_t n_points, ETreeVarType_e tv_type) :
+TEveLine::TEveLine(const char* name, Int_t n_points, ETreeVarType_e tv_type) :
    TEvePointSet(name, n_points, tv_type),
    fRnrLine   (kTRUE),
    fRnrPoints (kFALSE),
diff --git a/graf3d/eve/src/TEveManager.cxx b/graf3d/eve/src/TEveManager.cxx
index cd59ced..c86d0a4 100644
--- a/graf3d/eve/src/TEveManager.cxx
+++ b/graf3d/eve/src/TEveManager.cxx
@@ -285,7 +285,7 @@ TGLViewer* TEveManager::GetDefaultGLViewer() const
 }
 
 //______________________________________________________________________________
-TEveViewer* TEveManager::SpawnNewViewer(const Text_t* name, const Text_t* title,
+TEveViewer* TEveManager::SpawnNewViewer(const char* name, const char* title,
                                         Bool_t embed)
 {
    // Create a new GL viewer.
@@ -318,7 +318,7 @@ TEveViewer* TEveManager::SpawnNewViewer(const Text_t* name, const Text_t* title,
 }
 
 //______________________________________________________________________________
-TEveScene* TEveManager::SpawnNewScene(const Text_t* name, const Text_t* title)
+TEveScene* TEveManager::SpawnNewScene(const char* name, const char* title)
 {
    // Create a new scene.
 
@@ -332,7 +332,7 @@ TEveScene* TEveManager::SpawnNewScene(const Text_t* name, const Text_t* title)
 /******************************************************************************/
 
 //______________________________________________________________________________
-TMacro* TEveManager::GetMacro(const Text_t* name) const
+TMacro* TEveManager::GetMacro(const char* name) const
 {
    // Find macro in fMacroFolder by name.
 
diff --git a/graf3d/eve/src/TEveParamList.cxx b/graf3d/eve/src/TEveParamList.cxx
index 56cb1a5..3683228 100644
--- a/graf3d/eve/src/TEveParamList.cxx
+++ b/graf3d/eve/src/TEveParamList.cxx
@@ -34,7 +34,7 @@
 ClassImp(TEveParamList);
 
 //______________________________________________________________________________
-TEveParamList::TEveParamList(const Text_t* n, const Text_t* t, Bool_t doColor) :
+TEveParamList::TEveParamList(const char* n, const char* t, Bool_t doColor) :
    TNamed(n, t),
    fColor(0)
 {
diff --git a/graf3d/eve/src/TEvePointSet.cxx b/graf3d/eve/src/TEvePointSet.cxx
index e8f34c5..a82b5ea 100644
--- a/graf3d/eve/src/TEvePointSet.cxx
+++ b/graf3d/eve/src/TEvePointSet.cxx
@@ -69,7 +69,7 @@ TEvePointSet::TEvePointSet(Int_t n_points, ETreeVarType_e tv_type) :
 }
 
 //______________________________________________________________________________
-TEvePointSet::TEvePointSet(const Text_t* name, Int_t n_points, ETreeVarType_e tv_type) :
+TEvePointSet::TEvePointSet(const char* name, Int_t n_points, ETreeVarType_e tv_type) :
    TEveElement(fMarkerColor),
    TPointSet3D(n_points),
    TEvePointSelectorConsumer(tv_type),
@@ -115,6 +115,35 @@ TEvePointSet::~TEvePointSet()
 /******************************************************************************/
 
 //______________________________________________________________________________
+void TEvePointSet::ClonePoints(const TEvePointSet& e)
+{
+   // Clone points and all point-related information from point-set 'e'.
+
+   // TPolyMarker3D
+   delete [] fP;
+   fN = e.fN;
+   if (fN > 0)
+   {
+      const Int_t nn = 3 * e.fN;
+      fP = new Float_t [nn];
+      for (Int_t i = 0; i < nn; i++) fP[i] = e.fP[i];
+   } else {
+      fP = 0;
+   }
+   fLastPoint = e.fLastPoint;
+
+   // TPointSet3D
+   CopyIds(e);
+
+   // TEvePointSet
+   delete fIntIds;
+   fIntIds         = e.fIntIds ? new TArrayI(*e.fIntIds) : 0;
+   fIntIdsPerPoint = e.fIntIdsPerPoint;
+}
+
+/******************************************************************************/
+
+//______________________________________________________________________________
 const TGPicture* TEvePointSet::GetListTreeIcon(Bool_t)
 {
    // Return pointset icon.
@@ -408,8 +437,8 @@ void TEvePointSet::PointSelected(Int_t id)
 ClassImp(TEvePointSetArray);
 
 //______________________________________________________________________________
-TEvePointSetArray::TEvePointSetArray(const Text_t* name,
-                                     const Text_t* title) :
+TEvePointSetArray::TEvePointSetArray(const char* name,
+                                     const char* title) :
    TEveElement(fMarkerColor),
    TNamed(name, title),
 
@@ -562,7 +591,7 @@ Int_t TEvePointSetArray::Size(Bool_t under, Bool_t over) const
 }
 
 //______________________________________________________________________________
-void TEvePointSetArray::InitBins(const Text_t* quant_name,
+void TEvePointSetArray::InitBins(const char* quant_name,
                                  Int_t nbins, Double_t min, Double_t max)
 {
    // Initialize internal point-sets with given binning parameters.
diff --git a/graf3d/eve/src/TEvePolygonSetProjected.cxx b/graf3d/eve/src/TEvePolygonSetProjected.cxx
index 1632aee..72dc746 100644
--- a/graf3d/eve/src/TEvePolygonSetProjected.cxx
+++ b/graf3d/eve/src/TEvePolygonSetProjected.cxx
@@ -49,7 +49,7 @@ typedef std::list<Seg_t>::iterator LSegIt_t;
 ClassImp(TEvePolygonSetProjected);
 
 //______________________________________________________________________________
-TEvePolygonSetProjected::TEvePolygonSetProjected(const Text_t* n, const Text_t* t) :
+TEvePolygonSetProjected::TEvePolygonSetProjected(const char* n, const char* t) :
    TEveElementList(n, t),
 
    fBuff(0),
diff --git a/graf3d/eve/src/TEveProjectionAxes.cxx b/graf3d/eve/src/TEveProjectionAxes.cxx
index b92b07d..788fc04 100644
--- a/graf3d/eve/src/TEveProjectionAxes.cxx
+++ b/graf3d/eve/src/TEveProjectionAxes.cxx
@@ -43,11 +43,16 @@ TEveProjectionAxes::TEveProjectionAxes(TEveProjectionManager* m) :
 {
    // Constructor.
 
-   fNdivisions = 1006; // primary np = n/100, secondary ns = n -np*100
-   fLabelSize = 0.015;
-
    fCanEditMainTrans = kFALSE;
    fManager->AddDependent(this);
+
+   // Axis attributes.
+   fNdivisions = 1010;
+   fLabelSize = 0.015;
+   fLabelColor = kGray+1;
+   fAxisColor = kGray+1;
+   fTickLength = 0.015;
+   fLabelOffset = 0.01;
 }
 
 //______________________________________________________________________________
diff --git a/graf3d/eve/src/TEveProjectionAxesEditor.cxx b/graf3d/eve/src/TEveProjectionAxesEditor.cxx
index bbdaddc..2a9a854 100644
--- a/graf3d/eve/src/TEveProjectionAxesEditor.cxx
+++ b/graf3d/eve/src/TEveProjectionAxesEditor.cxx
@@ -32,7 +32,6 @@ TEveProjectionAxesEditor::TEveProjectionAxesEditor(const TGWindow *p, Int_t widt
 
    fLabMode(0),
    fAxesMode(0),
-   fNdivisions(0),
 
    fCenterFrame(0),
    fDrawCenter(0),
@@ -81,15 +80,6 @@ TEveProjectionAxesEditor::TEveProjectionAxesEditor(const TGWindow *p, Int_t widt
       AddFrame(f);
    }
 
-   fNdivisions = new TEveGValuator(this, "Ndivisions:", 70, 0);
-   fNdivisions->SetLabelWidth(labw);
-   fNdivisions->SetNELength(6);
-   fNdivisions->SetShowSlider(kFALSE);
-   fNdivisions->Build();
-   fNdivisions->SetLimits(100, 10000);
-   fNdivisions->Connect("ValueSet(Double_t)", "TEveProjectionAxesEditor", this, "DoNdivisions()");
-   AddFrame(fNdivisions, new TGLayoutHints(kLHintsTop, 1, 1, 1, 1));
-
    //______________________________________________________________________________
 
    // center tab
@@ -136,7 +126,6 @@ void TEveProjectionAxesEditor::SetModel(TObject* obj)
 
    fLabMode->Select(fM->GetLabMode(), kFALSE);
    fAxesMode->Select(fM->GetAxesMode(), kFALSE);
-   fNdivisions->SetValue(fM->GetNdivisions());
    fDrawCenter->SetState(fM->GetDrawCenter()  ? kButtonDown : kButtonUp);
    fDrawOrigin->SetState(fM->GetDrawOrigin()  ? kButtonDown : kButtonUp);
 
@@ -179,11 +168,3 @@ void TEveProjectionAxesEditor::DoAxesMode(Int_t mode)
    fM->SetAxesMode(em);
    Update();
 }
-//______________________________________________________________________________
-void TEveProjectionAxesEditor::DoNdivisions()
-{
-   // Slot for setting step size.
-
-   fM->SetNdivisions((Int_t)fNdivisions->GetValue());
-   Update();
-}
diff --git a/graf3d/eve/src/TEveProjectionAxesGL.cxx b/graf3d/eve/src/TEveProjectionAxesGL.cxx
index 51e4061..2a49107 100644
--- a/graf3d/eve/src/TEveProjectionAxesGL.cxx
+++ b/graf3d/eve/src/TEveProjectionAxesGL.cxx
@@ -47,6 +47,7 @@ Bool_t TEveProjectionAxesGL::SetModel(TObject* obj, const Option_t* /*opt*/)
 
    if (SetModelCheckClass(obj, TEveProjectionAxes::Class())) {
       fM = dynamic_cast<TEveProjectionAxes*>(obj);
+      fAxisPainter.SetAttAxis(fM);
       return fM->GetManager() ? kTRUE : kFALSE;
    }
    return kFALSE;
@@ -62,145 +63,119 @@ void TEveProjectionAxesGL::SetBBox()
 }
 
 //______________________________________________________________________________
-void TEveProjectionAxesGL::DrawScales(Bool_t horizontal, TGLFont& font, Float_t tmSize, Float_t dtw) const
+void TEveProjectionAxesGL::FilterOverlappingLabels(Int_t idx, Float_t ref) const
 {
-   // Draw labels and tick-marks.
+   TGLAxisPainter::LabVec_t &orig = fAxisPainter.RefLabVec();
+   if (orig.size() == 0) return;
 
-   // tick-marks
+   Float_t center = fM->GetManager()->GetCenter()[idx];
 
-   glBegin(GL_LINES);
-
-   // draw small tickmarks
-   Float_t mh = tmSize*0.5;
-   for (TMVec_t::iterator it = fTickMarks.begin(); it != fTickMarks.end(); ++it)
-   {
-      if (horizontal)
-      {
-         glVertex2f(*it, 0);  glVertex2f(*it, mh);
-      }
-      else
-      {
-         glVertex2f(0, *it); glVertex2f(mh, *it);
-      }
-   }
-
-   // draw label tickmarks
+   // Get index of label closest to the distortion center.
+   // Needed to keep simetry around center.
    Int_t minIdx = 0;
-   Float_t minVal = TMath::Abs( fLabVec[0].second);
    Int_t cnt = 0;
-   for (LabVec_t::iterator it = fLabVec.begin(); it != fLabVec.end(); ++it)
+   Float_t currD = 0;
+   Float_t minD = TMath::Abs(orig[0].first -center);
+   for (TGLAxisPainter::LabVec_t::iterator it = orig.begin(); it != orig.end(); ++it)
    {
-      if (TMath::Abs((*it).second) < minVal)
+      currD = TMath::Abs((*it).first - center);
+      if (minD > currD)
       {
-         minVal = TMath::Abs((*it).second);
+         minD = currD;
          minIdx = cnt;
       }
+      cnt++;
+   }
+
+   // Minimum allowed distance 4* font size.
+   TGLAxisPainter::LabVec_t  filtered;
+   filtered.push_back(orig[minIdx]);
+   Int_t size = orig.size();
+   Float_t minDist = 4*fM->GetLabelSize()*ref;
+   Float_t pos = 0;
 
-      if (horizontal)
+   // Go from center to minimum.
+   if (minIdx > 0)
+   {
+      pos =  orig[minIdx].first;
+      for (Int_t i=minIdx-1; i>=0; --i)
       {
-         glVertex2f((*it).first, 0);  glVertex2f((*it).first, tmSize);
+         if (TMath::Abs(pos - orig[i].first) > minDist)
+         {
+            filtered.push_back(orig[i]);
+            pos = orig[i].first;
+         }
       }
-      else
+   }
+
+   // Go from center to maximum.
+   if (minIdx < (size -1))
+   {
+      pos =  orig[minIdx].first;
+      for (Int_t i=minIdx+1; i<size; ++i)
       {
-         glVertex2f(0, (*it).first); glVertex2f(tmSize, (*it).first);
+         if (TMath::Abs(orig[i].first - pos) > minDist)
+         {
+            filtered.push_back(orig[i]);
+            pos = orig[i].first;
+         }
       }
-      cnt++;
    }
-   glEnd();
-
-   //  align labels
-   TGLFont::ETextAlign_e align;
-   if (horizontal)
-      align = (tmSize < 0) ? TGLFont::kCenterUp : TGLFont::kCenterDown;
-   else
-      align = (tmSize < 0) ? TGLFont::kRight : TGLFont::kLeft;
-   Float_t llx, lly, llz, urx, ury, urz;
-
-
-   // get text format for current axis range and bin width
-   fAxisAtt.SetRng(fLabVec.front().second, fLabVec.back().second);
-   fAxisPainter.SetAxisAtt(&fAxisAtt);
-   if (minIdx + 1 < (Int_t) fLabVec.size())
-      fAxisPainter.SetTextFormat(fLabVec[minIdx+1].second - fLabVec[minIdx].second);
-   else
-      fAxisPainter.SetTextFormat(fLabVec[minIdx].second - fLabVec[minIdx-1].second);
-
-   // move from center out to be symetric
-   Int_t nl = fLabVec.size();
-   char txt[100];
-   Float_t off = 1.5*tmSize;
 
-
-   // render zero or minimum absolute value if not exist
-   fAxisPainter.FormAxisValue(fLabVec[minIdx].second, txt);
-   font.BBox(txt, llx, lly, llz, urx, ury, urz);
-   if (horizontal)
-      font.RenderBitmap(txt, fLabVec[minIdx].first, off, 0, align);
-   else
-      font.RenderBitmap(txt, off, fLabVec[minIdx].first, 0, align);
-
-   // positive values (from zero to right)
-   Float_t prev = fLabVec[minIdx].first;
-   for (Int_t i=minIdx+1; i<nl; ++i)
+   // Set labels list and text format.
+   if (filtered.size() >= 2)
    {
-      fAxisPainter.FormAxisValue(fLabVec[i].second, txt);
-      font.BBox(txt, llx, lly, llz, urx, ury, urz);
-      if (prev > (fLabVec[i].first - (urx-llx)*0.5*dtw))
-         continue;
-
-      if (horizontal)
-         font.RenderBitmap(txt, fLabVec[i].first, off, 0, align);
+      if ( minIdx > 0 )
+         fAxisPainter.SetTextFormat(orig.front().second, orig.back().second,  orig[minIdx].second - orig[minIdx-1].second);
       else
-         font.RenderBitmap(txt, off, fLabVec[i].first, 0, align);
+         fAxisPainter.SetTextFormat(orig.front().second, orig.back().second,  orig[minIdx+1].second - orig[minIdx].second);
 
-      prev = fLabVec[i].first + (urx-llx)*0.5*dtw;
+      fAxisPainter.RefLabVec().swap(filtered);
    }
-
-   // negative values (zero to left)
-   prev = fLabVec[minIdx].first;
-   for (Int_t i=minIdx-1; i>=0; --i)
+   else
    {
-      fAxisPainter.FormAxisValue(fLabVec[i].second, txt);
-      font.BBox(txt, llx, lly, llz, urx, ury, urz);
-      if ( prev < (fLabVec[i].first + (urx-llx)*0.5*dtw ))
-         continue;
-
-      if (horizontal)
-         font.RenderBitmap(txt, fLabVec[i].first, off, 0, align);
-      else
-         font.RenderBitmap(txt, off, fLabVec[i].first, 0, align);
-
-      prev = fLabVec[i].first -(urx-llx)*0.5 *dtw;
+      fAxisPainter.SetTextFormat(orig.front().second, orig.back().second,  orig.back().second - orig.front().second);
    }
 }
 
 //______________________________________________________________________________
-void TEveProjectionAxesGL::SplitInterval(Float_t p1, Float_t p2, Int_t ax, Int_t nLab) const
+void TEveProjectionAxesGL::SplitInterval(Float_t p1, Float_t p2, Int_t ax) const
 {
    // Build an array of tick-mark position-value pairs.
 
-   fLabVec.clear();
-   fTickMarks.clear();
+   fAxisPainter.RefLabVec().clear();
+   fAxisPainter.RefTMVec().clear();
+
+   // Get list of label position-value pairs.
+
+
+   // Minimum/maximum are defined at the front/back element of list.
+   fAxisPainter.RefTMVec().push_back(TGLAxisPainter::TM_t(p1, -1));
 
    if (fM->GetLabMode() == TEveProjectionAxes::kValue)
    {
-      SplitIntervalByVal(p1, p2, ax, nLab);
+      SplitIntervalByVal(p1, p2, ax);
    }
    else if (fM->GetLabMode() == TEveProjectionAxes::kPosition)
    {
-      SplitIntervalByPos(p1, p2, ax, nLab);
+      SplitIntervalByPos(p1, p2, ax);
    }
+
+
+   FilterOverlappingLabels(0, p2 -p1);
+
+   // Minimum/maximum are defined at the front/back element of list.
+   fAxisPainter.RefTMVec().push_back(TGLAxisPainter::TM_t(p2, -1));
 }
 
 //______________________________________________________________________________
-void TEveProjectionAxesGL::SplitIntervalByPos(Float_t p1, Float_t p2, Int_t ax, Int_t nLab) const
+void TEveProjectionAxesGL::SplitIntervalByPos(Float_t p1, Float_t p2, Int_t ax) const
 {
    // Add tick-marks at equidistant position.
 
-   // limits
-   Int_t ndiv = fM->GetNdivisions();
-   Int_t n1a = nLab;
-   Int_t n2a = ndiv % 100;
+   // Limits.
+   Int_t n1a = TMath::FloorNint(fM->GetNdivisions() / 100);
+   Int_t n2a = fM->GetNdivisions() - n1a * 100;
    Int_t bn1, bn2;
    Double_t bw1, bw2; // bin with first second order
    Double_t bl1, bh1, bl2, bh2; // bin low, high first second order
@@ -210,112 +185,107 @@ void TEveProjectionAxesGL::SplitIntervalByPos(Float_t p1, Float_t p2, Int_t ax,
    Int_t n1=TMath::CeilNint(p1/bw1);
    Int_t n2=TMath::FloorNint(p2/bw1);
 
+   TGLAxisPainter::LabVec_t &labVec = fAxisPainter.RefLabVec();
+   TGLAxisPainter::TMVec_t  &tmVec =  fAxisPainter.RefTMVec();
+
    Float_t p = n1*bw1;
    Float_t pMinor = p;
    for (Int_t l=n1; l<=n2; l++)
    {
-      fLabVec.push_back(Lab_t(p , fProjection->GetValForScreenPos(ax, p)));
+      // Labels.
+      labVec.push_back( TGLAxisPainter::Lab_t(p , fProjection->GetValForScreenPos(ax, p)));
 
-      // tickmarks
-      fTickMarks.push_back(p);
-      pMinor = p-bw2;
+      // Tick-marks.
+      tmVec.push_back(TGLAxisPainter::TM_t(p, 0));
+      pMinor = p+bw2;
       for (Int_t i=1; i<bn2; i++)
       {
          if (pMinor > p2)  break;
-         fTickMarks.push_back(pMinor);
+         tmVec.push_back( TGLAxisPainter::TM_t(pMinor, 1));
          pMinor += bw2;
       }
       p += bw1;
    }
 
-   // complete
+   // Complete second order tick-marks.
    pMinor = n1*bw1 -bw2;
    while ( pMinor > p1)
    {
-      fTickMarks.push_back(pMinor);
+      tmVec.push_back(TGLAxisPainter::TM_t(pMinor, 1));
       pMinor -=bw2;
    }
 }
 
 //______________________________________________________________________________
-void TEveProjectionAxesGL::SplitIntervalByVal(Float_t p1, Float_t p2, Int_t ax, Int_t nLab) const
+void TEveProjectionAxesGL::SplitIntervalByVal(Float_t p1, Float_t p2, Int_t ax) const
 {
    // Add tick-marks on fixed value step.
 
    Float_t v1 = fProjection->GetValForScreenPos(ax, p1);
    Float_t v2 = fProjection->GetValForScreenPos(ax, p2);
 
+   TGLAxisPainter::LabVec_t &labVec =  fAxisPainter.RefLabVec();
+   TGLAxisPainter::TMVec_t  &tmVec  =  fAxisPainter.RefTMVec();
 
-   // limits
-   Int_t ndiv = fM->GetNdivisions();
-   Int_t n1a = nLab;
-   Int_t n2a = ndiv %100;
+   // Limits
+   Int_t n1a = TMath::FloorNint(fM->GetNdivisions() / 100);
+   Int_t n2a = fM->GetNdivisions() - n1a * 100;
    Int_t bn1, bn2;
    Double_t bw1, bw2; // bin with first second order
    Double_t bl1, bh1, bl2, bh2; // bin low, high first second order
    THLimitsFinder::Optimize(v1, v2, n1a, bl1, bh1, bn1, bw1);
    THLimitsFinder::Optimize(bl1, bl1+bw1, n2a, bl2, bh2, bn2, bw2);
 
-   Float_t pMinor;
+   Float_t pFirst, pSecond; // position of first, second order of tickmarks
    Float_t v = bl1;
    // step
    for (Int_t l=0; l<=bn1; l++)
    {
-      fLabVec.push_back(Lab_t(fProjection->GetScreenVal(ax, v) , v));
+      // Labels.
+      pFirst = fProjection->GetScreenVal(ax, v);
+      labVec.push_back(TGLAxisPainter::Lab_t(pFirst , v));
+      tmVec.push_back(TGLAxisPainter::TM_t(pFirst, 0));
 
-      // tickmarks
-      for (Int_t k=0; k<bn2; k++)
+      // Tickmarks.
+      for (Int_t k=1; k<bn2; k++)
       {
-         pMinor = fProjection->GetScreenVal(ax, v+k*bw2);
-         if (pMinor > p2)  break;
-         fTickMarks.push_back(pMinor);
+         pSecond = fProjection->GetScreenVal(ax, v+k*bw2);
+         if (pSecond > p2)  break;
+         tmVec.push_back(TGLAxisPainter::TM_t(pSecond, 1));
       }
       v += bw1;
    }
 
-   // complete
+   // Complete second order tick-marks.
    v = bl1 -bw2;
    while ( v > v1)
    {
-      pMinor = fProjection->GetScreenVal(ax, v);
-      if (pMinor < p1)  break;
-      fTickMarks.push_back(pMinor);
+      pSecond = fProjection->GetScreenVal(ax, v);
+      if (pSecond < p1)  break;
+      tmVec.push_back(TGLAxisPainter::TM_t(pSecond, 1));
       v -= bw2;
    }
 }
 
 //______________________________________________________________________________
-Bool_t TEveProjectionAxesGL::GetRange(Int_t ax, Float_t frustMin, Float_t frustMax, Float_t& start, Float_t& end) const
+void TEveProjectionAxesGL::GetRange(Int_t ax, Float_t frustMin, Float_t frustMax, Float_t& min, Float_t& max) const
 {
-   // take range from bounding box of projection manager
+   // Get range from bounding box of projection manager
 
-   Bool_t rngBBox=kTRUE;
 
-   Float_t bf = 1.2;
-   start = fM->GetManager()->GetBBox()[ax*2]   * bf;
-   end   = fM->GetManager()->GetBBox()[ax*2+1] * bf;
+   // Compare frustum range with bbox and take larger.
 
-   // compare frustum range with bbox, take smaller
-   Float_t frustC = 0.5f * (frustMin + frustMax);
-   Float_t frustR = 0.8f * (frustMax - frustMin);
-   frustMin = frustC - 0.5f*frustR;
-   frustMax = frustC + 0.5f*frustR;
-   if (start < frustMin || end > frustMax)
-   {
-      rngBBox=kFALSE;
-      start = frustMin;
-      end = frustMax;
-   }
+   Float_t frng = (frustMax -frustMin)*0.4;
+   Float_t c = 0.5*(frustMax +frustMin);
+   min = c - frng;
+   max = c + frng;
 
-   // ceheck projection  limits
-   // set limit factor in case of divergence
+   // Check projection  limits.
+   // Set limit factor in case of divergence.
    Float_t dLim = fProjection->GetLimit(ax, 0);
    Float_t uLim = fProjection->GetLimit(ax, 1);
-
-   if (start < dLim) start = dLim*0.98;
-   if (end   > uLim) end   = uLim*0.98;
-
-   return rngBBox;
+   if (min < dLim) min = dLim*0.98;
+   if (max > uLim) max   = uLim*0.98;
 }
 
 //______________________________________________________________________________
@@ -326,115 +296,113 @@ void TEveProjectionAxesGL::DirectDraw(TGLRnrCtx& rnrCtx) const
 
    if (rnrCtx.Selection() || rnrCtx.Highlight()) return;
 
-   fProjection = fM->GetManager()->GetProjection();
-
+   // Draw on front-clipping plane.
    Float_t old_depth_range[2];
    glGetFloatv(GL_DEPTH_RANGE, old_depth_range);
-   glDepthRange(0, 0); // Draw on front-clipping plane.
+   glDepthRange(0, 0);
 
-   // frustum size
+   // Frustum size.
    TGLCamera &camera = rnrCtx.RefCamera();
    Float_t l = -camera.FrustumPlane(TGLCamera::kLeft).D();
    Float_t r =  camera.FrustumPlane(TGLCamera::kRight).D();
    Float_t t =  camera.FrustumPlane(TGLCamera::kTop).D();
    Float_t b = -camera.FrustumPlane(TGLCamera::kBottom).D();
 
-   // font size relative to wiewport width
-   TGLFont font;
-   GLint   vp[4];
-   glGetIntegerv(GL_VIEWPORT, vp);
-   Int_t fs =  TGLFontManager::GetFontSize(TMath::Min(vp[2], vp[3])*fM->GetLabelSize(), 8, 36);
-   rnrCtx.RegisterFont(fs, "arial", TGLFont::kPixmap, font);
-   font.PreRender();
-
-   Float_t bboxCentX = (fM->GetManager()->GetBBox()[0] + fM->GetManager()->GetBBox()[1])* 0.5;
-   Float_t bboxCentY = (fM->GetManager()->GetBBox()[2] + fM->GetManager()->GetBBox()[3])* 0.5;
-
-   Float_t startX, endX;
-   Float_t startY, endY;
-   Bool_t  rngBBoxX = GetRange(0, l, r, startX, endX);
-   Bool_t  rngBBoxY = GetRange(1, b, t, startY, endY);
-   Float_t rngX = endX - startX;
-   Float_t rngY = endY - startY;
-
-   const Float_t rtm    = 0.015; // relative tick-mark size
-   const Int_t   minPix = 5;     // minimum tick-mark size in pixels
-
-   // X-axis
-   if (fM->fAxesMode == TEveProjectionAxes::kAll ||
-       fM->fAxesMode == TEveProjectionAxes::kHorizontal)
-   {
-
-      Float_t dtw  = (r-l)/vp[2]; // delta to viewport
-      Int_t   nLab = (rngX < rngY ) ? TMath::FloorNint(fM->GetNdivisions()/100) :
-                                      TMath::CeilNint((fM->GetNdivisions()*rngX)/(rngY*100));
-      SplitInterval(startX, endX, 0, nLab);
-
-      Float_t vOff = dtw*minPix;
-      Float_t tms  = (t-b)*rtm;
-      if (tms < vOff) tms = vOff;
-
-      // bottom
-      glPushMatrix();
-      glTranslatef(rngBBoxX ? bboxCentX : 0, b, 0);
-      DrawScales(kTRUE, font, tms, dtw);
-      glPopMatrix();
-      // top
-      glPushMatrix();
-      glTranslatef(rngBBoxX ? bboxCentX : 0, t, 0);
-      DrawScales(kTRUE, font, -tms, dtw);
-      glPopMatrix();
-   }
-
-   // Y-axis
-   if (fM->fAxesMode == TEveProjectionAxes::kAll ||
-       fM->fAxesMode == TEveProjectionAxes::kVertical)
+   fProjection = fM->GetManager()->GetProjection();
+   glDisable(GL_LIGHTING);
+   // Projection center and origin marker.
    {
-      Float_t dtw = (t-b)/vp[3];// delta to viewport
-      Int_t nLab = (rngY < rngX ) ? TMath::FloorNint(fM->GetNdivisions()/100) : TMath::CeilNint((fM->GetNdivisions()*rngY)/(rngX*100)) ;
-      SplitInterval(startY, endY, 1, nLab);
-
-      Float_t hOff = dtw * minPix;
-      Float_t tms  = (r - l) * rtm;
-      if (tms < hOff) tms = hOff;
-
-      // left
-      glPushMatrix();
-      glTranslatef(l, rngBBoxY ? bboxCentY : 0, 0);
-      DrawScales(kFALSE, font, tms, dtw);
-      glPopMatrix();
-      // right
-      glPushMatrix();
-      glTranslatef(r, rngBBoxY ? bboxCentY : 0, 0);
-      DrawScales(kFALSE, font, -tms, dtw);
-      glPopMatrix();
+      Float_t d = ((r-l) > (b-t)) ? (b-t) : (r-l);
+      d *= 0.02f;
+      if (fM->GetDrawCenter())
+      {
+         Float_t* c = fProjection->GetProjectedCenter();
+         TGLUtil::Color3f(1., 0., 0.);
+         glBegin(GL_LINES);
+         glVertex3f(c[0] + d, c[1], c[2]); glVertex3f(c[0] - d, c[1], c[2]);
+         glVertex3f(c[0], c[1] + d, c[2]); glVertex3f(c[0], c[1] - d, c[2]);
+         glVertex3f(c[0], c[1], c[2] + d); glVertex3f(c[0], c[1], c[2] - d);
+         glEnd();
+      }
+      if (fM->GetDrawOrigin())
+      {
+         TEveVector zero;
+         fProjection->ProjectVector(zero);
+         TGLUtil::Color3f(1., 1., 1.);
+         glBegin(GL_LINES);
+         glVertex3f(zero[0] + d, zero[1], zero[2]); glVertex3f(zero[0] - d, zero[1], zero[2]);
+         glVertex3f(zero[0], zero[1] + d, zero[2]); glVertex3f(zero[0], zero[1] - d, zero[2]);
+         glVertex3f(zero[0], zero[1], zero[2] + d); glVertex3f(zero[0], zero[1], zero[2] - d);
+         glEnd();
+      }
    }
-   font.PostRender();
 
-   // projection center and origin marker
-   Float_t d = ((r-l) > (b-t)) ? (b-t) : (r-l);
-   d *= 0.02f;
-   if (fM->GetDrawCenter())
+   //
+   // Axses.
    {
-      Float_t* c = fProjection->GetProjectedCenter();
-      TGLUtil::Color3f(1., 0., 0.);
-      glBegin(GL_LINES);
-      glVertex3f(c[0] + d, c[1], c[2]); glVertex3f(c[0] - d, c[1], c[2]);
-      glVertex3f(c[0], c[1] + d, c[2]); glVertex3f(c[0], c[1] - d, c[2]);
-      glVertex3f(c[0], c[1], c[2] + d); glVertex3f(c[0], c[1], c[2] - d);
-      glEnd();
-   }
-   if (fM->GetDrawOrigin())
-   {
-      TEveVector zero;
-      fProjection->ProjectVector(zero);
-      TGLUtil::Color3f(1., 1., 1.);
-      glBegin(GL_LINES);
-      glVertex3f(zero[0] + d, zero[1], zero[2]); glVertex3f(zero[0] - d, zero[1], zero[2]);
-      glVertex3f(zero[0], zero[1] + d, zero[2]); glVertex3f(zero[0], zero[1] - d, zero[2]);
-      glVertex3f(zero[0], zero[1], zero[2] + d); glVertex3f(zero[0], zero[1], zero[2] - d);
-      glEnd();
+      using namespace TMath;
+      GLint   vp[4];
+      glGetIntegerv(GL_VIEWPORT, vp);
+      Float_t refLength =  TMath::Sqrt((TMath::Power(vp[2]-vp[0], 2) + TMath::Power(vp[3]-vp[1], 2)));
+      Float_t tickLength = TMath::Sqrt((TMath::Power(r-l, 2) + TMath::Power(t-b, 2)));
+      fAxisPainter.SetLabelFont(rnrCtx, TGLFontManager::GetFontNameFromId(fM->GetLabelFont()),  TMath::CeilNint(refLength*0.02), tickLength*fM->GetLabelSize());
+
+      Float_t min, max;
+      // X-axis.
+      if (fM->fAxesMode == TEveProjectionAxes::kAll ||
+          fM->fAxesMode == TEveProjectionAxes::kHorizontal)
+      {
+         GetRange(0, l, r, min, max);
+         SplitInterval(min, max, 0);
+
+         fAxisPainter.RefDir().Set(1, 0, 0);
+         fAxisPainter.RefTMOff(0).Set(0, tickLength, 0);
+
+         // Bottom.
+         glPushMatrix();
+         glTranslatef( 0, b, 0);
+         fAxisPainter.SetLabelAlign(TGLFont::kCenterDown);
+         fAxisPainter.RnrLabels();
+         fAxisPainter.RnrLines();
+         glPopMatrix();
+
+         // Top.
+         glPushMatrix();
+         glTranslatef( 0, t, 0);
+         fAxisPainter.SetLabelAlign(TGLFont::kCenterUp);
+         fAxisPainter.RefTMOff(0).Negate();
+         fAxisPainter.RnrLabels();
+         fAxisPainter.RnrLines();
+         glPopMatrix();
+      }
+     
+      // Y-axis.
+      if (fM->fAxesMode == TEveProjectionAxes::kAll ||
+          fM->fAxesMode == TEveProjectionAxes::kVertical)
+      {
+         GetRange(1, b, t, min, max);
+         SplitInterval(min, max, 1);
+
+         fAxisPainter.RefDir().Set(0, 1, 0);
+         fAxisPainter.RefTMOff(0).Set(tickLength, 0 , 0);
+
+         // Left.
+         glPushMatrix();
+         glTranslatef(l, 0, 0);
+         fAxisPainter.SetLabelAlign(TGLFont::kLeft);
+         fAxisPainter.RnrLabels();
+         fAxisPainter.RnrLines();
+         glPopMatrix();
+
+         // Right.
+         glPushMatrix();
+         glTranslatef(r, 0, 0);
+         fAxisPainter.SetLabelAlign(TGLFont::kRight);
+         fAxisPainter.RefTMOff(0).Negate();
+         fAxisPainter.RnrLabels();
+         fAxisPainter.RnrLines();
+         glPopMatrix();
+      }
    }
-
    glDepthRange(old_depth_range[0], old_depth_range[1]);
 }
diff --git a/graf3d/eve/src/TEveQuadSet.cxx b/graf3d/eve/src/TEveQuadSet.cxx
index df7d1e3..6d6c2f8 100644
--- a/graf3d/eve/src/TEveQuadSet.cxx
+++ b/graf3d/eve/src/TEveQuadSet.cxx
@@ -41,7 +41,7 @@
 ClassImp(TEveQuadSet);
 
 //______________________________________________________________________________
-TEveQuadSet::TEveQuadSet(const Text_t* n, const Text_t* t) :
+TEveQuadSet::TEveQuadSet(const char* n, const char* t) :
    TEveDigitSet   (n, t),
 
    fQuadType  (kQT_Undef),
@@ -55,7 +55,7 @@ TEveQuadSet::TEveQuadSet(const Text_t* n, const Text_t* t) :
 
 //______________________________________________________________________________
 TEveQuadSet::TEveQuadSet(EQuadType_e quadType, Bool_t valIsCol, Int_t chunkSize,
-                         const Text_t* n, const Text_t* t) :
+                         const char* n, const char* t) :
    TEveDigitSet   (n, t),
 
    fQuadType  (kQT_Undef),
diff --git a/graf3d/eve/src/TEveScalableStraightLineSet.cxx b/graf3d/eve/src/TEveScalableStraightLineSet.cxx
index 1bc5f5a..1db4b73 100644
--- a/graf3d/eve/src/TEveScalableStraightLineSet.cxx
+++ b/graf3d/eve/src/TEveScalableStraightLineSet.cxx
@@ -26,7 +26,7 @@
 ClassImp(TEveScalableStraightLineSet);
 
 //______________________________________________________________________________
-TEveScalableStraightLineSet::TEveScalableStraightLineSet(const Text_t* n, const Text_t* t):
+TEveScalableStraightLineSet::TEveScalableStraightLineSet(const char* n, const char* t):
    TEveStraightLineSet (n, t),
    fCurrentScale(1.0)
 {
diff --git a/graf3d/eve/src/TEveScene.cxx b/graf3d/eve/src/TEveScene.cxx
index 1b1f587..68e105d 100644
--- a/graf3d/eve/src/TEveScene.cxx
+++ b/graf3d/eve/src/TEveScene.cxx
@@ -33,7 +33,7 @@
 ClassImp(TEveScene);
 
 //______________________________________________________________________________
-TEveScene::TEveScene(const Text_t* n, const Text_t* t) :
+TEveScene::TEveScene(const char* n, const char* t) :
    TEveElementList(n, t),
    fPad    (0),
    fGLScene(0),
@@ -110,7 +110,7 @@ void TEveScene::Repaint(Bool_t dropLogicals)
 /******************************************************************************/
 
 //______________________________________________________________________________
-void TEveScene::SetName(const Text_t* n)
+void TEveScene::SetName(const char* n)
 {
    // Set scene's name.
 
@@ -177,7 +177,7 @@ const TGPicture* TEveScene::GetListTreeIcon(Bool_t)
 ClassImp(TEveSceneList);
 
 //______________________________________________________________________________
-TEveSceneList::TEveSceneList(const Text_t* n, const Text_t* t) :
+TEveSceneList::TEveSceneList(const char* n, const char* t) :
    TEveElementList(n, t)
 {
    // Constructor.
diff --git a/graf3d/eve/src/TEveSelection.cxx b/graf3d/eve/src/TEveSelection.cxx
index 10ea82d..b5d0143 100644
--- a/graf3d/eve/src/TEveSelection.cxx
+++ b/graf3d/eve/src/TEveSelection.cxx
@@ -24,7 +24,7 @@
 ClassImp(TEveSelection);
 
 //______________________________________________________________________________
-TEveSelection::TEveSelection(const Text_t* n, const Text_t* t) :
+TEveSelection::TEveSelection(const char* n, const char* t) :
    TEveElementList(n, t),
    fPickToSelect  (kPS_Projectable),
    fActive        (kTRUE),
diff --git a/graf3d/eve/src/TEveStraightLineSet.cxx b/graf3d/eve/src/TEveStraightLineSet.cxx
index 978e987..5596b38 100644
--- a/graf3d/eve/src/TEveStraightLineSet.cxx
+++ b/graf3d/eve/src/TEveStraightLineSet.cxx
@@ -32,7 +32,7 @@
 ClassImp(TEveStraightLineSet);
 
 //______________________________________________________________________________
-TEveStraightLineSet::TEveStraightLineSet(const Text_t* n, const Text_t* t):
+TEveStraightLineSet::TEveStraightLineSet(const char* n, const char* t):
    TEveElement (),
    TNamed      (n, t),
 
@@ -42,6 +42,7 @@ TEveStraightLineSet::TEveStraightLineSet(const Text_t* n, const Text_t* t):
    fOwnMarkersIds (kFALSE),
    fRnrMarkers    (kTRUE),
    fRnrLines      (kTRUE),
+   fDepthTest     (kTRUE),
    fLastLine      (0)
 {
    // Constructor.
diff --git a/graf3d/eve/src/TEveStraightLineSetGL.cxx b/graf3d/eve/src/TEveStraightLineSetGL.cxx
index 7b76c51..9e42daa 100644
--- a/graf3d/eve/src/TEveStraightLineSetGL.cxx
+++ b/graf3d/eve/src/TEveStraightLineSetGL.cxx
@@ -73,6 +73,17 @@ Bool_t TEveStraightLineSetGL::ShouldDLCache(const TGLRnrCtx& rnrCtx) const
 /******************************************************************************/
 
 //______________________________________________________________________________
+void TEveStraightLineSetGL::Draw(TGLRnrCtx& rnrCtx) const
+{
+   // Draw function for TEveStraightLineSetGL. Skips line-pass of outline mode.
+
+   if (rnrCtx.IsDrawPassOutlineLine())
+      return;
+
+   TGLObject::Draw(rnrCtx);
+}
+
+//______________________________________________________________________________
 void TEveStraightLineSetGL::DirectDraw(TGLRnrCtx& rnrCtx) const
 {
    // Render the line-set with GL.
@@ -81,13 +92,17 @@ void TEveStraightLineSetGL::DirectDraw(TGLRnrCtx& rnrCtx) const
 
    TEveStraightLineSet& mL = * fM;
 
-   // lines
    TGLCapabilitySwitch lights_off(GL_LIGHTING, kFALSE);
+   if (mL.GetDepthTest() == kFALSE)
+   {
+      glPushAttrib(GL_VIEWPORT_BIT);
+      glDepthRange(0, 0.1); 
+   }
+
+   // lines
    if (mL.GetRnrLines() && mL.GetLinePlex().Size() > 0)
    {
       glPushAttrib(GL_LINE_BIT | GL_ENABLE_BIT);
-
-      glDisable(GL_LIGHTING);
       glLineWidth(mL.GetLineWidth());
       if (mL.GetLineStyle() > 1) {
          Int_t    fac = 1;
@@ -179,6 +194,8 @@ void TEveStraightLineSetGL::DirectDraw(TGLRnrCtx& rnrCtx) const
       delete [] pnts;
    }
 
+   if (mL.GetDepthTest() == kFALSE)
+      glPopAttrib();
 }
 
 /******************************************************************************/
diff --git a/graf3d/eve/src/TEveText.cxx b/graf3d/eve/src/TEveText.cxx
index 19a344f..714cfbb 100644
--- a/graf3d/eve/src/TEveText.cxx
+++ b/graf3d/eve/src/TEveText.cxx
@@ -36,7 +36,7 @@
 ClassImp(TEveText);
 
 //______________________________________________________________________________
-TEveText::TEveText(const Text_t* txt) :
+TEveText::TEveText(const char* txt) :
    TEveElement(fTextColor),
    TNamed("TEveText", ""),
    TAtt3D(),
diff --git a/graf3d/eve/src/TEveTextEditor.cxx b/graf3d/eve/src/TEveTextEditor.cxx
index 0aae3c0..e09c375 100644
--- a/graf3d/eve/src/TEveTextEditor.cxx
+++ b/graf3d/eve/src/TEveTextEditor.cxx
@@ -175,7 +175,7 @@ void TEveTextEditor::SetModel(TObject* obj)
 }
 
 //______________________________________________________________________________
-void TEveTextEditor::DoText(const Text_t* /*txt*/)
+void TEveTextEditor::DoText(const char* /*txt*/)
 {
    // Slot for setting text.
 
diff --git a/graf3d/eve/src/TEveTrack.cxx b/graf3d/eve/src/TEveTrack.cxx
index b85545e..65e654b 100644
--- a/graf3d/eve/src/TEveTrack.cxx
+++ b/graf3d/eve/src/TEveTrack.cxx
@@ -22,7 +22,6 @@
 #include "TEveManager.h"
 #include "TEveBrowser.h"
 #include "TEveTrackProjected.h"
-#include "TROOT.h"
 
 #include <vector>
 #include <algorithm>
@@ -55,6 +54,7 @@ TEveTrack::TEveTrack() :
    fCharge(0),
    fLabel(kMinInt),
    fIndex(kMinInt),
+   fLockPoints(kFALSE),
    fPathMarks(),
    fPropagator(0),
    fBreakProjectedTracks(kBPTDefault)
@@ -74,6 +74,7 @@ TEveTrack::TEveTrack(TParticle* t, Int_t label, TEveTrackPropagator* rs):
    fCharge(0),
    fLabel(label),
    fIndex(kMinInt),
+   fLockPoints(kFALSE),
    fPathMarks(),
    fPropagator(0),
    fBreakProjectedTracks(kBPTDefault)
@@ -104,6 +105,7 @@ TEveTrack::TEveTrack(TEveMCTrack* t, TEveTrackPropagator* rs):
    fCharge(0),
    fLabel(t->fLabel),
    fIndex(t->fIndex),
+   fLockPoints(kFALSE),
    fPathMarks(),
    fPropagator(0),
    fBreakProjectedTracks(kBPTDefault)
@@ -134,6 +136,7 @@ TEveTrack::TEveTrack(TEveRecTrack* t, TEveTrackPropagator* rs) :
    fCharge(t->fSign),
    fLabel(t->fLabel),
    fIndex(t->fIndex),
+   fLockPoints(kFALSE),
    fPathMarks(),
    fPropagator(0),
    fBreakProjectedTracks(kBPTDefault)
@@ -157,6 +160,7 @@ TEveTrack::TEveTrack(const TEveTrack& t) :
    fCharge(t.fCharge),
    fLabel(t.fLabel),
    fIndex(t.fIndex),
+   fLockPoints(t.fLockPoints),
    fPathMarks(),
    fPropagator(0),
    fBreakProjectedTracks(t.fBreakProjectedTracks)
@@ -164,6 +168,10 @@ TEveTrack::TEveTrack(const TEveTrack& t) :
    // Copy constructor. Track paremeters are copied but the
    // extrapolation is not perfermed so you should still call
    // MakeTrack() to do that.
+   // If points of 't' are locked, they are cloned.
+
+   if (fLockPoints)
+      ClonePoints(t);
 
    SetMainColor(t.GetMainColor());
    // TEveLine
@@ -214,15 +222,21 @@ void TEveTrack::SetStdTitle()
 void TEveTrack::SetTrackParams(const TEveTrack& t)
 {
    // Copy track parameters from t.
-   // PathMarks are cleared.
+   // PathMarks are cleared - you can copy them via SetPathMarks(t).
+   // If track 't' is locked, you should probably clone its points
+   // over - use TEvePointSet::ClonePoints(t);
+
+   fV          = t.fV;
+   fP          = t.fP;
+   fBeta       = t.fBeta;
+   fPdg        = t.fPdg;
+   fCharge     = t.fCharge;
+   fLabel      = t.fLabel;
+   fIndex      = t.fIndex;
 
-   fV         = t.fV;
-   fP         = t.fP;
-   fBeta      = t.fBeta;
-   fPdg       = t.fPdg;
-   fCharge    = t.fCharge;
-   fLabel     = t.fLabel;
-   fIndex     = t.fIndex;
+   fPathMarks.clear();
+   SetPropagator(t.fPropagator);
+   fBreakProjectedTracks = t.fBreakProjectedTracks;
 
    SetMainColor(t.GetMainColor());
    // TEveLine
@@ -236,9 +250,6 @@ void TEveTrack::SetTrackParams(const TEveTrack& t)
    fLineColor = t.fLineColor;
    fLineStyle = t.fLineStyle;
    fLineWidth = t.fLineWidth;
-   fPathMarks.clear();
-   SetPropagator(t.fPropagator);
-   fBreakProjectedTracks = t.fBreakProjectedTracks;
 }
 
 //______________________________________________________________________________
@@ -291,84 +302,87 @@ void TEveTrack::MakeTrack(Bool_t recurse)
    // settings of the render-style.
    // If recurse is true, descend into children.
 
-   Reset(0);
+   if (!fLockPoints)
+   {
+      Reset(0);
 
-   TEveTrackPropagator& rTP((fPropagator != 0) ? *fPropagator : TEveTrackPropagator::fgDefStyle);
+      TEveTrackPropagator& rTP((fPropagator != 0) ? *fPropagator : TEveTrackPropagator::fgDefStyle);
 
-   const Float_t maxRsq = rTP.GetMaxR() * rTP.GetMaxR();
-   const Float_t maxZ   = rTP.GetMaxZ();
+      const Float_t maxRsq = rTP.GetMaxR() * rTP.GetMaxR();
+      const Float_t maxZ   = rTP.GetMaxZ();
 
-   if (TMath::Abs(fV.fZ) < maxZ && fV.fX*fV.fX + fV.fY*fV.fY < maxRsq)
-   {
-      TEveVector currP = fP;
-      Bool_t decay = kFALSE;
-      fPropagator->InitTrack(fV, fCharge);
-      for (vPathMark_i pm = fPathMarks.begin(); pm != fPathMarks.end(); ++pm)
+      if (TMath::Abs(fV.fZ) < maxZ && fV.fX*fV.fX + fV.fY*fV.fY < maxRsq)
       {
-         if (rTP.GetFitReferences() && pm->fType == TEvePathMark::kReference)
+         TEveVector currP = fP;
+         Bool_t decay = kFALSE;
+         fPropagator->InitTrack(fV, fCharge);
+         for (vPathMark_i pm = fPathMarks.begin(); pm != fPathMarks.end(); ++pm)
          {
-            if (TEveTrackPropagator::IsOutsideBounds(pm->fV, maxRsq, maxZ))
-               break;
-            // printf("%s fit reference  \n", fName.Data());
-            if (fPropagator->GoToVertex(pm->fV, currP)) {
-               currP.fX = pm->fP.fX; currP.fY = pm->fP.fY; currP.fZ = pm->fP.fZ;
-            }
-            else
+            if (rTP.GetFitReferences() && pm->fType == TEvePathMark::kReference)
             {
-               break;
-            }
-         }
-         else if (rTP.GetFitDaughters() && pm->fType == TEvePathMark::kDaughter)
-         {
-            if (TEveTrackPropagator::IsOutsideBounds(pm->fV, maxRsq, maxZ))
-               break;
-            // printf("%s fit daughter  \n", fName.Data());
-            if (fPropagator->GoToVertex(pm->fV, currP)) {
-               currP.fX -= pm->fP.fX; currP.fY -= pm->fP.fY; currP.fZ -= pm->fP.fZ;
+               if (TEveTrackPropagator::IsOutsideBounds(pm->fV, maxRsq, maxZ))
+                  break;
+               // printf("%s fit reference  \n", fName.Data());
+               if (fPropagator->GoToVertex(pm->fV, currP)) {
+                  currP.fX = pm->fP.fX; currP.fY = pm->fP.fY; currP.fZ = pm->fP.fZ;
+               }
+               else
+               {
+                  break;
+               }
             }
-            else
+            else if (rTP.GetFitDaughters() && pm->fType == TEvePathMark::kDaughter)
             {
-               break;
+               if (TEveTrackPropagator::IsOutsideBounds(pm->fV, maxRsq, maxZ))
+                  break;
+               // printf("%s fit daughter  \n", fName.Data());
+               if (fPropagator->GoToVertex(pm->fV, currP)) {
+                  currP.fX -= pm->fP.fX; currP.fY -= pm->fP.fY; currP.fZ -= pm->fP.fZ;
+               }
+               else
+               {
+                  break;
+               }
             }
-         }
-         else if (rTP.GetFitDecay() && pm->fType == TEvePathMark::kDecay)
-         {
-            if (TEveTrackPropagator::IsOutsideBounds(pm->fV, maxRsq, maxZ))
-               break;
-            // printf("%s fit decay \n", fName.Data());
-            fPropagator->GoToVertex(pm->fV, currP);
-            decay = true;
-            break;
-         }
-         else if (rTP.GetFitCluster2Ds() && pm->fType == TEvePathMark::kCluster2D)
-         {
-            // This if should actually be done for corrected point.
-            TEveVector itsect;
-            if (fPropagator->IntersectPlane(currP, pm->fV, pm->fP, itsect))
+            else if (rTP.GetFitDecay() && pm->fType == TEvePathMark::kDecay)
             {
-               TEveVector delta   = itsect - pm->fV;
-               TEveVector vtopass = pm->fV + pm->fE*(pm->fE.Dot(delta));
-               if (TEveTrackPropagator::IsOutsideBounds(vtopass, maxRsq, maxZ))
+               if (TEveTrackPropagator::IsOutsideBounds(pm->fV, maxRsq, maxZ))
                   break;
-               fPropagator->GoToVertex(vtopass, currP);
+               // printf("%s fit decay \n", fName.Data());
+               fPropagator->GoToVertex(pm->fV, currP);
+               decay = true;
+               break;
             }
-            else
+            else if (rTP.GetFitCluster2Ds() && pm->fType == TEvePathMark::kCluster2D)
             {
-               Warning("TEveTrack::MakeTrack", "Failed to intersect plane for Cluster2D. Ignoring path-mark.");
+               // This if should actually be done for corrected point.
+               TEveVector itsect;
+               if (fPropagator->IntersectPlane(currP, pm->fV, pm->fP, itsect))
+               {
+                  TEveVector delta   = itsect - pm->fV;
+                  TEveVector vtopass = pm->fV + pm->fE*(pm->fE.Dot(delta));
+                  if (TEveTrackPropagator::IsOutsideBounds(vtopass, maxRsq, maxZ))
+                     break;
+                  fPropagator->GoToVertex(vtopass, currP);
+               }
+               else
+               {
+                  Warning("TEveTrack::MakeTrack", "Failed to intersect plane for Cluster2D. Ignoring path-mark.");
+               }
+               break;
             }
-            break;
-         }
-      } // loop path-marks
+         } // loop path-marks
 
-      if (!decay || rTP.GetFitDecay() == kFALSE)
-      {
-         // printf("%s loop to bounds  \n",fName.Data() );
-         fPropagator->GoToBounds(currP);
+         if (!decay || rTP.GetFitDecay() == kFALSE)
+         {
+            // printf("%s loop to bounds  \n",fName.Data() );
+            fPropagator->GoToBounds(currP);
+         }
+         fPEnd = currP;
+         //  make_polyline:
+         fPropagator->FillPointSet(this);
+         fPropagator->ResetTrack();
       }
-      fPEnd = currP;
-      //  make_polyline:
-      fPropagator->FillPointSet(this);
-      fPropagator->ResetTrack();
    }
 
    if (recurse)
@@ -452,128 +466,6 @@ void TEveTrack::SortPathMarksByTime()
    std::sort(fPathMarks.begin(), fPathMarks.end(), Cmp_pathmark_t());
 }
 
-/******************************************************************************/
-
-//______________________________________________________________________________
-void TEveTrack::ImportHits()
-{
-   // Import hits with same label as the track.
-   // Uses macro "hits_from_label.C".
-
-   TEveUtil::LoadMacro("hits_from_label.C");
-   gROOT->ProcessLine(Form("hits_from_label(%d, (TEveElement*)%p);",
-                           fLabel, this));
-}
-
-//______________________________________________________________________________
-void TEveTrack::ImportClusters()
-{
-   // Import clusters with same label as the track.
-   // Uses macro "clusters_from_label.C".
-
-   TEveUtil::LoadMacro("clusters_from_label.C");
-   gROOT->ProcessLine(Form("clusters_from_label(%d, (TEveElement*)%p);",
-                           fLabel, this));
-}
-
-//______________________________________________________________________________
-void TEveTrack::ImportClustersFromIndex()
-{
-   // Import clusters marked with same reconstructed track index as the track.
-   // Uses macro "clusters_from_index.C".
-
-   static const TEveException eh("TEveTrack::ImportClustersFromIndex ");
-
-   if (fIndex == kMinInt)
-      throw(eh + "index not set.");
-
-   TEveUtil::LoadMacro("clusters_from_index.C");
-   gROOT->ProcessLine(Form("clusters_from_index(%d, (TEveElement*)%p);",
-                           fIndex, this));
-}
-
-/******************************************************************************/
-
-//______________________________________________________________________________
-void TEveTrack::ImportKine()
-{
-   // Import kinematics of the track's label recursively.
-   // Uses macro "kine_tracks.C".
-
-   static const TEveException eh("TEveTrack::ImportKine ");
-
-   if (fLabel == kMinInt)
-      throw(eh + "label not set.");
-
-   Int_t label;
-   if (fLabel < 0) {
-      Warning(eh, "label negative, taking absolute value.");
-      label = -fLabel;
-   } else {
-      label = fLabel;
-   }
-
-   TEveUtil::LoadMacro("kine_tracks.C");
-   gROOT->ProcessLine(Form("kine_track(%d, kTRUE, kTRUE, kTRUE, kTRUE, (TEveElement*)%p);",
-                           label, this));
-
-}
-
-//______________________________________________________________________________
-void TEveTrack::ImportKineWithArgs(Bool_t importMother, Bool_t importDaugters,
-                                   Bool_t colorPdg,     Bool_t recurse)
-{
-   // Import kinematics of the track's label. Arguments steer the
-   // import process:
-   //   importMother     import particle with track's label
-   //   importDaugters   import direct daughters of label
-   //   colorPdg         color kinematics by PDG code
-   //   recurse          recursive import of daughters' daughters
-   // Uses macro "kine_tracks.C".
-
-   static const TEveException eh("TEveTrack::ImportKineWithArgs ");
-
-   if (fLabel == kMinInt)
-      throw(eh + "label not set.");
-
-   Int_t label;
-   if (fLabel < 0) {
-      Warning(eh, "label negative, taking absolute value.");
-      label = -fLabel;
-   } else {
-      label = fLabel;
-   }
-
-   TEveUtil::LoadMacro("kine_tracks.C");
-   gROOT->ProcessLine(Form("kine_track(%d, %d, %d, %d, %d, (TEveElement*)%p);",
-                           label, importMother, importDaugters, colorPdg, recurse, this));
-}
-
-/******************************************************************************/
-
-//______________________________________________________________________________
-void TEveTrack::PrintKineStack()
-{
-   // Print kinematics pertaining to track's label.
-   // Uses macro "print_kine_from_label.C".
-
-   static const TEveException eh("TEveTrack::PrintKineStack ");
-
-   if (fLabel == kMinInt)
-      throw(eh + "label not set.");
-
-   Int_t label;
-   if (fLabel < 0) {
-      Warning(eh, "label negative, taking absolute value.");
-      label = -fLabel;
-   } else {
-      label = fLabel;
-   }
-
-   TEveUtil::LoadMacro("print_kine_from_label.C");
-   gROOT->ProcessLine(Form("print_kine_from_label(%d);", label));
-}
-
 //______________________________________________________________________________
 void TEveTrack::PrintPathMarks()
 {
@@ -652,18 +544,19 @@ TEveTrackList::TEveTrackList(TEveTrackPropagator* rs) :
    fMinPt (0), fMaxPt (0), fLimPt (0),
    fMinP  (0), fMaxP  (0), fLimP  (0)
 {
-   // Constructor. If TrackRenderStyle argument is 0, a new default
-   // render-style is created.
+   // Constructor. If track-propagator argument is 0, a new default
+   // one is created.
 
    fChildClass = TEveTrack::Class(); // override member from base TEveElementList
 
    fMainColorPtr = &fLineColor;
-   if (fPropagator== 0) rs = new TEveTrackPropagator;
+
+   if (rs == 0) rs = new TEveTrackPropagator;
    SetPropagator(rs);
 }
 
 //______________________________________________________________________________
-TEveTrackList::TEveTrackList(const Text_t* name, TEveTrackPropagator* rs) :
+TEveTrackList::TEveTrackList(const char* name, TEveTrackPropagator* rs) :
    TEveElementList(name),
    TAttMarker(1, 20, 1),
    TAttLine(1,1,1),
@@ -676,13 +569,14 @@ TEveTrackList::TEveTrackList(const Text_t* name, TEveTrackPropagator* rs) :
    fMinPt (0), fMaxPt (0), fLimPt (0),
    fMinP  (0), fMaxP  (0), fLimP  (0)
 {
-   // Constructor. If TrackRenderStyle argument is 0, a new default
-   // render-style is created.
+   // Constructor. If track-propagator argument is 0, a new default
+   // one is created.
 
    fChildClass = TEveTrack::Class(); // override member from base TEveElementList
 
    fMainColorPtr = &fLineColor;
-   if (fPropagator== 0) rs = new TEveTrackPropagator;
+
+   if (rs == 0) rs = new TEveTrackPropagator;
    SetPropagator(rs);
 }
 
@@ -1180,8 +1074,10 @@ TEveTrack* TEveTrackList::FindTrackByLabel(Int_t label)
 {
    // Find track by label, select it and display it in the editor.
 
-   for (List_i i=fChildren.begin(); i!=fChildren.end(); ++i) {
-      if (((TEveTrack*)(*i))->GetLabel() == label) {
+   for (List_i i=fChildren.begin(); i!=fChildren.end(); ++i)
+   {
+      if (((TEveTrack*)(*i))->GetLabel() == label)
+      {
          TGListTree     *lt   = gEve->GetLTEFrame()->GetListTree();
          TGListTreeItem *mlti = lt->GetSelected();
          if (mlti->GetUserData() != this)
@@ -1201,8 +1097,10 @@ TEveTrack* TEveTrackList::FindTrackByIndex(Int_t index)
 {
    // Find track by index, select it and display it in the editor.
 
-   for (List_i i=fChildren.begin(); i!=fChildren.end(); ++i) {
-      if (((TEveTrack*)(*i))->GetIndex() == index) {
+   for (List_i i=fChildren.begin(); i!=fChildren.end(); ++i)
+   {
+      if (((TEveTrack*)(*i))->GetIndex() == index)
+      {
          TGListTree     *lt   = gEve->GetLTEFrame()->GetListTree();
          TGListTreeItem *mlti = lt->GetSelected();
          if (mlti->GetUserData() != this)
@@ -1217,26 +1115,6 @@ TEveTrack* TEveTrackList::FindTrackByIndex(Int_t index)
    return 0;
 }
 
-//______________________________________________________________________________
-void TEveTrackList::ImportHits()
-{
-   // Import hits for all track.
-
-   for (List_i i=fChildren.begin(); i!=fChildren.end(); ++i) {
-      ((TEveTrack*)(*i))->ImportHits();
-   }
-}
-
-//______________________________________________________________________________
-void TEveTrackList::ImportClusters()
-{
-   // Import clusters for all track.
-
-   for (List_i i=fChildren.begin(); i!=fChildren.end(); ++i) {
-      ((TEveTrack*)(*i))->ImportClusters();
-   }
-}
-
 /******************************************************************************/
 
 //______________________________________________________________________________
diff --git a/graf3d/eve/src/TEveTrackPropagator.cxx b/graf3d/eve/src/TEveTrackPropagator.cxx
index 6f8411b..cc9f5e6 100644
--- a/graf3d/eve/src/TEveTrackPropagator.cxx
+++ b/graf3d/eve/src/TEveTrackPropagator.cxx
@@ -16,19 +16,27 @@
 
 #include <cassert>
 
+namespace
+{
+   const Float_t kBMin     = 1e-6;
+   const Float_t kPtMinSqr = 1e-20;
+   const Float_t kAMin     = 1e-10;
+   const Float_t kStepEps  = 1e-3;
+}
+
 //______________________________________________________________________________
 TEveTrackPropagator::Helix_t::Helix_t() :
    fCharge(0), fMinAng(45), fDelta(0.1),
+   fMaxStep(20.f), fCurrentStep(20.f),
    fPhi(0), fValid(kFALSE),
    fLam(-1), fR(-1), fPhiStep(-1), fSin(-1), fCos(-1),
-   fPtMag(-1), fPlDir(-1), fTStep(-1)
+   fPtMag(-1), fPlDir(-1), fLStep(-1)
 {
    // Default constructor.
 }
 
 //______________________________________________________________________________
-void TEveTrackPropagator::Helix_t::UpdateHelix(const TEveVector& p, const TEveVector& b,
-                                          Bool_t fullUpdate, Float_t fraction)
+void TEveTrackPropagator::Helix_t::UpdateHelix(const TEveVector& p, const TEveVector& b, Bool_t fullUpdate)
 {
    // Update helix parameters.
 
@@ -52,34 +60,36 @@ void TEveTrackPropagator::Helix_t::UpdateHelix(const TEveVector& p, const TEveVe
    if (fullUpdate)
    {
       using namespace TMath;
-
       Float_t a = fgkB2C * b.Mag() * Abs(fCharge);
-      if (a > 1e-10 && fPtMag*fPtMag > 1e-12)
+      if (a > kAMin && fPtMag*fPtMag > kPtMinSqr)
       {
          fValid = kTRUE;
 
          fR   = Abs(fPtMag / a);
          fLam = fPl.Mag() / fPtMag;
          if (fPlDir < 0) fLam = - fLam;
+
+         // get phi step, compare fMinAng with fDelta
+         fPhiStep = fMinAng * DegToRad();
+         if (fDelta < fR)
+         {
+            Float_t ang  = 2*ACos(1 - fDelta/fR);
+            if (ang < fPhiStep) fPhiStep = ang;
+         }
+
+         // check max step size
+         fCurrentStep = fR*fPhiStep*(1 + fLam*fLam);
+         if (fCurrentStep > fMaxStep)
+            fPhiStep *= (fMaxStep/fCurrentStep);
+
+         fLStep = fR*fPhiStep*fLam;
+         fSin   = Sin(fPhiStep);
+         fCos   = Cos(fPhiStep);
       }
       else
       {
          fValid = kFALSE;
-         return;
       }
-
-      // phi steps
-      fPhiStep = fMinAng * DegToRad();
-      if (fDelta < fR)
-      {
-         Float_t ang  = 2*ACos(1 - fDelta/fR);
-         if (ang < fPhiStep) fPhiStep = ang;
-      }
-      if (fraction > 0) fPhiStep *= fraction;
-
-      fTStep = fR*fPhiStep;
-      fSin   = Sin(fPhiStep);
-      fCos   = Cos(fPhiStep);
    }
 }
 
@@ -93,9 +103,9 @@ void TEveTrackPropagator::Helix_t::Step(const TEveVector4& v, const TEveVector&
 
    if (fValid)
    {
-      TEveVector d = fE2*(fR*fSin) + fE3*(fR*(1-fCos)) + fE1*(fLam*fTStep);
+      TEveVector d = fE2*(fR*fSin) + fE3*(fR*(1-fCos)) + fE1*fLStep;
       vOut    += d;
-      vOut.fT += fTStep;
+      vOut.fT += fLStep;
 
       pOut = fPl + fE2*(fPtMag*fCos) + fE3*(fPtMag*fSin);
 
@@ -103,44 +113,31 @@ void TEveTrackPropagator::Helix_t::Step(const TEveVector4& v, const TEveVector&
    }
    else
    {
-      // case: pT < 1e-6 or B < 1e-7
+      // case: pT < kPtMinSqr or B < kBMin
       // might happen if field directon changes pT ~ 0 or B becomes zero
-
-      if (fTStep == -1)
-      {
-         printf("WARNING TEveTrackPropagator::Helix_t::Step step-size not initialised.\n");
-      }
-      vOut += p * (fTStep / p.Mag());
+      vOut += p * (fMaxStep / p.Mag());
       pOut  = p;
    }
 }
 
 
 //______________________________________________________________________________
-void TEveTrackPropagator::Helix_t::UpdateRG(const TEveVector& p,  const TEveVector& b, Float_t bMax, Float_t maxStep)
+void TEveTrackPropagator::Helix_t::UpdateRK(const TEveVector& p, const TEveVector& b)
 {
-  // Update helix for stepper RungeKutta.
-
-  if (bMax > 0)
-  {
-    // full update
-    Float_t a  = fgkB2C * bMax * fCharge;
-    fPhiStep = fMinAng * TMath::DegToRad();
-    if (a)
-    {
-      fR      = TMath::Abs(p.Mag() / a);
-      fTStep   = TMath::Min(fR*fPhiStep, maxStep);
+   // Update helix for stepper RungeKutta.
+
+   if (fCharge)
+   {
       fValid = kTRUE;
-    }
-    else 
-    {
-      fValid = kFALSE;
-      fTStep = maxStep;
-    }
-  }
 
-  fB = b;
-  fPlDir = p.Dot(fB);
+      // cached values for propagator
+      fB = b;
+      fPlDir = p.Dot(fB);
+   }
+   else
+   {
+      fValid = kFALSE;
+   }
 }
 
 
@@ -167,7 +164,7 @@ const Float_t       TEveTrackPropagator::fgkB2C        = 0.299792458e-2;
 TEveTrackPropagator TEveTrackPropagator::fgDefStyle;
 
 //______________________________________________________________________________
-TEveTrackPropagator::TEveTrackPropagator(const Text_t* n, const Text_t* t,
+TEveTrackPropagator::TEveTrackPropagator(const char* n, const char* t,
                                          TEveMagField *field) :
    TEveElementList(n, t),
    TEveRefBackPtr(),
@@ -179,7 +176,6 @@ TEveTrackPropagator::TEveTrackPropagator(const Text_t* n, const Text_t* t,
 
    fNMax     (4096),
    fMaxOrbs  (0.5),
-   fMaxStepRG  (10),
 
    fEditPathMarks (kTRUE),
    fFitDaughters  (kTRUE),
@@ -295,10 +291,9 @@ Bool_t TEveTrackPropagator::GoToVertex(TEveVector& v, TEveVector& p)
    if (fStepper == kHelix)
       fH.UpdateHelix(p, fMagFieldObj->GetField(fV), kTRUE);
    else
-      fH.UpdateRG(p, fMagFieldObj->GetField(fV), fMagFieldObj->GetMaxFieldMag(), fMaxStepRG);
-
+      fH.UpdateRK(p, fMagFieldObj->GetField(fV));
 
-   if ((v-fV).Mag() < 1e-3)
+   if ((v-fV).Mag() < kStepEps)
    {
       fPoints.push_back(v);
       return kTRUE;
@@ -312,55 +307,50 @@ void TEveTrackPropagator::GoToBounds(TEveVector& p)
 {
    // Propagate particle to bounds.
    // Return TRUE if hit bounds.
-  
+
    if (fStepper == kHelix)
       fH.UpdateHelix(p, fMagFieldObj->GetField(fV), kTRUE);
    else
-      fH.UpdateRG(p, fMagFieldObj->GetField(fV), fMagFieldObj->GetMaxFieldMag(), fMaxStepRG);
+      fH.UpdateRK(p, fMagFieldObj->GetField(fV));
 
-    
    fH.fValid ? LoopToBounds(p): LineToBounds(p);
 }
 
 //______________________________________________________________________________
-void TEveTrackPropagator::Step(TEveVector4 &v, TEveVector &p, TEveVector4 &vOut, TEveVector &pOut,
-                               Float_t fraction = -1)
+void TEveTrackPropagator::Step(TEveVector4 &v, TEveVector &p, TEveVector4 &vOut, TEveVector &pOut)
 {
    // Wrapper to step helix.
 
    if (fStepper == kHelix)
    {
-      fH.UpdateHelix(p, fH.fB, !fMagFieldObj->IsConst(), fraction);
+      fH.UpdateHelix(p, fMagFieldObj->GetField(v), !fMagFieldObj->IsConst());
       fH.Step(v, p, vOut, pOut);
    }
    else
    {
-      fH.UpdateRG(p, fMagFieldObj->GetField(fV));
-      Float_t step = fH.fTStep;
-      if (fraction > 0)
-         step *= fraction;
-
-      Double_t vecRGI[7];
-      vecRGI[0] = v.fX;
-      vecRGI[1] = v.fY;
-      vecRGI[2] = v.fZ;
+      fH.UpdateRK(p, fMagFieldObj->GetField(v));
+
+      Double_t vecRKIn[7];
+      vecRKIn[0] = v.fX;
+      vecRKIn[1] = v.fY;
+      vecRKIn[2] = v.fZ;
       Float_t nm = 1/p.Mag();
-      vecRGI[3] = p.fX*nm;
-      vecRGI[4] = p.fY*nm;
-      vecRGI[5] = p.fZ*nm;
-      vecRGI[6] = p.Mag();
-
-      Double_t vecRGO[7];
-      OneStepRungeKutta(fH.fCharge, step, vecRGI, vecRGO);
-
-      vOut.fX = vecRGO[0];
-      vOut.fY = vecRGO[1];
-      vOut.fZ = vecRGO[2];
-      vOut.fT += step;
-      Double_t pm = vecRGO[6];
-      pOut.fX = vecRGO[3]*pm;
-      pOut.fY = vecRGO[4]*pm;
-      pOut.fZ = vecRGO[5]*pm;
+      vecRKIn[3] = p.fX*nm;
+      vecRKIn[4] = p.fY*nm;
+      vecRKIn[5] = p.fZ*nm;
+      vecRKIn[6] = p.Mag();
+
+      Double_t vecRKOut[7];
+      OneStepRungeKutta(fH.fCharge, fH.fMaxStep, vecRKIn, vecRKOut);
+
+      vOut.fX = vecRKOut[0];
+      vOut.fY = vecRKOut[1];
+      vOut.fZ = vecRKOut[2];
+      vOut.fT += fH.fMaxStep;
+      Double_t pm = vecRKOut[6];
+      pOut.fX = vecRKOut[3]*pm;
+      pOut.fY = vecRKOut[4]*pm;
+      pOut.fZ = vecRKOut[5]*pm;
    }
 }
 
@@ -468,22 +458,23 @@ Bool_t TEveTrackPropagator::LoopToVertex(TEveVector& v, TEveVector& p)
       TEveVector pln =  fH.fPl;
       pln.Normalize();
 
-      if (pln.Dot(d2) > 1e-10)
+      if (d1.Mag() > kStepEps)
       {
-         // set step fraction
-         Float_t frac = pln.Dot(d1)/pln.Dot(d2);
-         //  printf("frac %f %d p (%f %f %f)\n", frac, np-first_point, fH.fPl.fX, fH.fPl.fY, fH.fPl.fZ);
-
+         // step for forced step size;
+         Float_t origMaxStep = fH.fMaxStep;
+         fH.fMaxStep = d1.Mag();
          if (fStepper == kHelix)
-            fH.UpdateHelix(p, fH.fB, kTRUE, frac);
+            fH.UpdateHelix(p, fMagFieldObj->GetField(fV), kTRUE);
          else
-            fH.fTStep *= frac; 
+            fH.UpdateRK(p, fMagFieldObj->GetField(fV));
 
          Step(currV, p, forwV, forwP);
          p = forwP;
          currV = forwV;
          fPoints.push_back(currV); np++;
+         fH.fMaxStep =  origMaxStep;
 
+         // distibute offset
          TEveVector off(v); off -= currV;
          off *= 1.0f / currV.fT;
          for (Int_t i = first_point; i < np; ++i)
@@ -561,7 +552,7 @@ Bool_t TEveTrackPropagator::HelixIntersectPlane(const TEveVector& p,
    TEveVector pos(fV);
    TEveVector mom(p);
    if (fMagFieldObj->IsConst())
-      fH.UpdateHelix(mom, fMagFieldObj->GetField(pos), fH.fCharge,  kTRUE);
+      fH.UpdateHelix(mom, fMagFieldObj->GetField(pos), kFALSE);
 
    TEveVector n(normal);
    TEveVector delta = pos - point;
@@ -636,7 +627,7 @@ Bool_t TEveTrackPropagator::IntersectPlane(const TEveVector& p,
    // Returns:
    //  kFALSE if intersection can not be found, kTRUE otherwise.
 
-   if (fH.fCharge && fMagFieldObj && p.Perp2() > 1e-12)
+   if (fH.fCharge && fMagFieldObj && p.Perp2() > kPtMinSqr)
       return HelixIntersectPlane(p, point, normal, itsect);
    else
       return LineIntersectPlane(p, point, normal, itsect);
@@ -689,7 +680,8 @@ void TEveTrackPropagator::SetMagField(Float_t bX, Float_t bY, Float_t bZ)
 void TEveTrackPropagator::SetMagFieldObj(TEveMagField *mff)
 {
    // Set constant magnetic field and rebuild tracks.
-  if (fMagFieldObj) delete fMagFieldObj;
+
+   if (fMagFieldObj) delete fMagFieldObj;
 
    fMagFieldObj = mff;
    RebuildTracks();
@@ -818,10 +810,18 @@ void TEveTrackPropagator::SetRnrReferences(Bool_t rnr)
    RebuildTracks();
 }
 
+//______________________________________________________________________________
+void TEveTrackPropagator::SetMaxStep(Float_t x)
+{
+   // Set maximum radius and rebuild tracks.
+
+   fH.fMaxStep = x;
+   RebuildTracks();
+}
 
 //______________________________________________________________________________
 void TEveTrackPropagator::OneStepRungeKutta(Double_t charge, Double_t step,
-					Double_t* vect, Double_t* vout)
+                                            Double_t* vect, Double_t* vout)
 {
 
   // Wrapper to step with method RungeKutta.
@@ -897,7 +897,6 @@ void TEveTrackPropagator::OneStepRungeKutta(Double_t charge, Double_t step,
   Double_t h = step;
   Double_t rest;
 
-
   do {
     rest  = step - tl;
     if (TMath::Abs(h) > TMath::Abs(rest)) h = rest;
@@ -950,6 +949,7 @@ void TEveTrackPropagator::OneStepRungeKutta(Double_t charge, Double_t step,
     xyzt[2] = zt;
 
     //cmodif: call gufld(xyzt,f) changed into:
+    fH.fB = fMagFieldObj->GetField(xt, yt, zt);
     f[0] = -fH.fB.fX;
     f[1] = -fH.fB.fY;
     f[2] = -fH.fB.fZ;
@@ -989,6 +989,7 @@ void TEveTrackPropagator::OneStepRungeKutta(Double_t charge, Double_t step,
     xyzt[2] = zt;
 
     //cmodif: call gufld(xyzt,f) changed into:
+    fH.fB = fMagFieldObj->GetField(xt, yt, zt);
     f[0] = -fH.fB.fX;
     f[1] = -fH.fB.fY;
     f[2] = -fH.fB.fZ;
@@ -1074,7 +1075,7 @@ void TEveTrackPropagator::OneStepRungeKutta(Double_t charge, Double_t step,
 
   vout[kipx] = vect[kipx] + g4*vect[kipx] + g5*hxp[0] + g6*f1;
   vout[kipy] = vect[kipy] + g4*vect[kipy] + g5*hxp[1] + g6*f2;
-  vout[kipz] = vect[kipz] + g4*vect[kipz] + g5*hxp[2] + g6*f3; 
+  vout[kipz] = vect[kipz] + g4*vect[kipz] + g5*hxp[2] + g6*f3;
 
   fH.fPhi += tet;
 }
diff --git a/graf3d/eve/src/TEveTrans.cxx b/graf3d/eve/src/TEveTrans.cxx
index 190913b..d6b34af 100644
--- a/graf3d/eve/src/TEveTrans.cxx
+++ b/graf3d/eve/src/TEveTrans.cxx
@@ -510,7 +510,7 @@ void TEveTrans::SetRotByAngles(Float_t a1, Float_t a2, Float_t a3)
 
 //______________________________________________________________________________
 void TEveTrans::SetRotByAnyAngles(Float_t a1, Float_t a2, Float_t a3,
-                                  const Text_t* pat)
+                                  const char* pat)
 {
    // Sets Rotation part as given by angles a1, a1, a3 and pattern pat.
    // Pattern consists of "XxYyZz" characters.
diff --git a/graf3d/eve/src/TEveTreeTools.cxx b/graf3d/eve/src/TEveTreeTools.cxx
index 9ff5f08..1a0b6ae 100644
--- a/graf3d/eve/src/TEveTreeTools.cxx
+++ b/graf3d/eve/src/TEveTreeTools.cxx
@@ -31,7 +31,7 @@
 ClassImp(TEveSelectorToEventList)
 
 //______________________________________________________________________________
-TEveSelectorToEventList::TEveSelectorToEventList(TEventList* evl, const Text_t* sel) :
+TEveSelectorToEventList::TEveSelectorToEventList(TEventList* evl, const char* sel) :
    TSelectorDraw(), fEvList(evl)
 {
    // Constructor.
@@ -67,7 +67,7 @@ ClassImp(TEvePointSelectorConsumer)
 //______________________________________________________________________________
 TEvePointSelector::TEvePointSelector(TTree* t,
                                      TEvePointSelectorConsumer* c,
-                                     const Text_t* vexp, const Text_t* sel) :
+                                     const char* vexp, const char* sel) :
    TSelectorDraw(),
 
    fTree      (t),
@@ -83,7 +83,7 @@ TEvePointSelector::TEvePointSelector(TTree* t,
 }
 
 //______________________________________________________________________________
-Long64_t TEvePointSelector::Select(const Text_t* selection)
+Long64_t TEvePointSelector::Select(const char* selection)
 {
    // Process the tree, select points matching 'selection'.
 
@@ -116,7 +116,7 @@ Long64_t TEvePointSelector::Select(const Text_t* selection)
 }
 
 //______________________________________________________________________________
-Long64_t TEvePointSelector::Select(TTree* t, const Text_t* selection)
+Long64_t TEvePointSelector::Select(TTree* t, const char* selection)
 {
    // Process tree 't', select points matching 'selection'.
 
diff --git a/graf3d/eve/src/TEveUtil.cxx b/graf3d/eve/src/TEveUtil.cxx
index c4edebd..bf93a8c 100644
--- a/graf3d/eve/src/TEveUtil.cxx
+++ b/graf3d/eve/src/TEveUtil.cxx
@@ -133,7 +133,7 @@ void ChompTail(TString& s, char c='.')
 }
 
 //______________________________________________________________________________
-Bool_t TEveUtil::CheckMacro(const Text_t* mac)
+Bool_t TEveUtil::CheckMacro(const char* mac)
 {
    // Checks if macro 'mac' is loaded.
 
@@ -158,7 +158,7 @@ Bool_t TEveUtil::CheckMacro(const Text_t* mac)
 }
 
 //______________________________________________________________________________
-void TEveUtil::AssertMacro(const Text_t* mac)
+void TEveUtil::AssertMacro(const char* mac)
 {
    // Load and execute macro 'mac' if it has not been loaded yet.
 
@@ -168,7 +168,7 @@ void TEveUtil::AssertMacro(const Text_t* mac)
 }
 
 //______________________________________________________________________________
-void TEveUtil::Macro(const Text_t* mac)
+void TEveUtil::Macro(const char* mac)
 {
    // Execute macro 'mac'. Do not reload the macro.
 
@@ -180,7 +180,7 @@ void TEveUtil::Macro(const Text_t* mac)
 }
 
 //______________________________________________________________________________
-void TEveUtil::LoadMacro(const Text_t* mac)
+void TEveUtil::LoadMacro(const char* mac)
 {
    // Makes sure that macro 'mac' is loaded, but do not reload it.
 
@@ -255,7 +255,7 @@ void TEveUtil::ColorFromIdx(Float_t f1, Color_t c1, Float_t f2, Color_t c2,
 }
 
 //______________________________________________________________________________
-Color_t* TEveUtil::FindColorVar(TObject* obj, const Text_t* varname)
+Color_t* TEveUtil::FindColorVar(TObject* obj, const char* varname)
 {
    // Find address of Color_t data-member with name varname in object
    // obj.
diff --git a/graf3d/eve/src/TEveVSD.cxx b/graf3d/eve/src/TEveVSD.cxx
index adb4143..a6e4919 100644
--- a/graf3d/eve/src/TEveVSD.cxx
+++ b/graf3d/eve/src/TEveVSD.cxx
@@ -24,7 +24,7 @@
 ClassImp(TEveVSD);
 
 //______________________________________________________________________________
-TEveVSD::TEveVSD(const Text_t* , const Text_t* ) :
+TEveVSD::TEveVSD(const char* , const char* ) :
    TObject(),
 
    fBuffSize  (128*1024),
@@ -214,7 +214,7 @@ void TEveVSD::LoadTrees()
 }
 
 //______________________________________________________________________________
-void TEveVSD::LoadVSD(const Text_t* vsd_file_name, const Text_t* dir_name)
+void TEveVSD::LoadVSD(const char* vsd_file_name, const char* dir_name)
 {
    // Load VSD data from given file and directory.
 
diff --git a/graf3d/eve/src/TEveViewer.cxx b/graf3d/eve/src/TEveViewer.cxx
index 104226e..e950854 100644
--- a/graf3d/eve/src/TEveViewer.cxx
+++ b/graf3d/eve/src/TEveViewer.cxx
@@ -43,7 +43,7 @@
 ClassImp(TEveViewer);
 
 //______________________________________________________________________________
-TEveViewer::TEveViewer(const Text_t* n, const Text_t* t) :
+TEveViewer::TEveViewer(const char* n, const char* t) :
    TEveWindowFrame(0, n, t),
    fGLViewer      (0),
    fGLViewerFrame (0)
@@ -120,7 +120,7 @@ void TEveViewer::SetGLViewer(TGLViewer* viewer, TGFrame* frame)
 }
 
 //______________________________________________________________________________
-void TEveViewer::SpawnGLViewer(TGedEditor* ged)
+TGLSAViewer* TEveViewer::SpawnGLViewer(TGedEditor* ged)
 {
    // Spawn new GLViewer and adopt it.
 
@@ -136,10 +136,12 @@ void TEveViewer::SpawnGLViewer(TGedEditor* ged)
 
    if (fEveFrame == 0)
       PreUndock();
+
+   return v;
 }
 
 //______________________________________________________________________________
-void TEveViewer::SpawnGLEmbeddedViewer(Int_t border)
+TGLEmbeddedViewer* TEveViewer::SpawnGLEmbeddedViewer(Int_t border)
 {
    // Spawn new GLViewer and adopt it.
 
@@ -156,6 +158,8 @@ void TEveViewer::SpawnGLEmbeddedViewer(Int_t border)
 
    if (fEveFrame == 0)
       PreUndock();
+
+   return v;
 }
 
 //______________________________________________________________________________
@@ -247,7 +251,7 @@ Bool_t TEveViewer::HandleElementPaste(TEveElement* el)
 ClassImp(TEveViewerList);
 
 //______________________________________________________________________________
-TEveViewerList::TEveViewerList(const Text_t* n, const Text_t* t) :
+TEveViewerList::TEveViewerList(const char* n, const char* t) :
    TEveElementList(n, t),
    fShowTooltip   (kTRUE)
 {
@@ -348,6 +352,18 @@ void TEveViewerList::RepaintAllViewers(Bool_t resetCameras, Bool_t dropLogicals)
    }
 }
 
+//______________________________________________________________________________
+void TEveViewerList::DeleteAnnotations()
+{
+   // Delete annotations from all viewers.
+
+   for (List_i i=fChildren.begin(); i!=fChildren.end(); ++i)
+   {
+      TGLViewer* glv = ((TEveViewer*)*i)->GetGLViewer();
+      glv->DeleteOverlayAnnotations();
+   }
+}
+
 /******************************************************************************/
 
 //______________________________________________________________________________
diff --git a/graf3d/eve/src/TEveWindow.cxx b/graf3d/eve/src/TEveWindow.cxx
index 907b7a0..8fc093e 100644
--- a/graf3d/eve/src/TEveWindow.cxx
+++ b/graf3d/eve/src/TEveWindow.cxx
@@ -66,8 +66,31 @@
 ClassImp(TEveCompositeFrame);
 
 TContextMenu* TEveCompositeFrame::fgCtxMenu = 0;
+
 const TString TEveCompositeFrame::fgkEmptyFrameName("<relinquished>");
 TList*        TEveCompositeFrame::fgFrameList = new THashList;
+
+TEveCompositeFrame::IconBarCreator_foo TEveCompositeFrame::fgIconBarCreator = 0;
+
+UInt_t             TEveCompositeFrame::fgTopFrameHeight        = 14;
+UInt_t             TEveCompositeFrame::fgMiniBarHeight         = 4;
+Bool_t             TEveCompositeFrame::fgAllowTopFrameCollapse = kTRUE;
+
+//______________________________________________________________________________
+void TEveCompositeFrame::SetupFrameMarkup(IconBarCreator_foo creator,
+                                          UInt_t top_frame_height,
+                                          UInt_t mini_bar_height,
+                                          Bool_t allow_top_collapse)
+{
+   // Set properties of the EVE frame.
+   // Should be called before the windows are created.
+
+   fgIconBarCreator        = creator;
+   fgTopFrameHeight        = top_frame_height;
+   fgMiniBarHeight         = mini_bar_height;
+   fgAllowTopFrameCollapse = allow_top_collapse;
+}
+
 //______________________________________________________________________________
 TEveCompositeFrame::TEveCompositeFrame(TGCompositeFrame* parent,
                                        TEveWindow*   eve_parent) :
@@ -88,42 +111,49 @@ TEveCompositeFrame::TEveCompositeFrame(TGCompositeFrame* parent,
 {
    // Constructor.
 
-   static const UInt_t topH = 14, miniH = 4;
-
-   // --- TopFrame
+   fTopFrame = new TGHorizontalFrame(this, 20, fgTopFrameHeight);
 
-   fTopFrame = new TGHorizontalFrame(this, 20, topH);
-
-   fToggleBar = new TGTextButton(fTopFrame, "Hide");
-   fToggleBar->ChangeOptions(kRaisedFrame);
-   fToggleBar->Resize(40, topH);
-   fTopFrame->AddFrame(fToggleBar, new TGLayoutHints(kLHintsNormal));
+   if (fgAllowTopFrameCollapse)
+   {
+      fToggleBar = new TGTextButton(fTopFrame, "Hide");
+      fToggleBar->ChangeOptions(kRaisedFrame);
+      fToggleBar->Resize(40, fgTopFrameHeight);
+      fToggleBar->Connect("Clicked()", "TEveCompositeFrame", this, "FlipTitleBarState()");
+      fTopFrame->AddFrame(fToggleBar, new TGLayoutHints(kLHintsNormal));
+   }
 
    fTitleBar = new TGTextButton(fTopFrame, "Title Bar");
    fTitleBar->ChangeOptions(kRaisedFrame);
-   fTitleBar->Resize(40, topH);
+   fTitleBar->Resize(40, fgTopFrameHeight);
+   fTitleBar->Connect("Clicked()", "TEveCompositeFrame", this, "TitleBarClicked()");
    fTopFrame->AddFrame(fTitleBar, new TGLayoutHints(kLHintsNormal | kLHintsExpandX));
 
-   fIconBar = new TGTextButton(fTopFrame, "Actions");
-   fIconBar->ChangeOptions(kRaisedFrame);
-   fIconBar->Resize(40, topH);
+   if (fgIconBarCreator)
+   {
+      fIconBar = (fgIconBarCreator)(this, fTopFrame, fgTopFrameHeight);
+   }
+   else
+   {
+      TGButton* b = new TGTextButton(fTopFrame, "Actions");
+      b->ChangeOptions(kRaisedFrame);
+      b->Resize(40, fgTopFrameHeight);
+      b->Connect("Pressed()", "TEveCompositeFrame", this, "ActionPressed()");
+      fIconBar = b;
+   }
    fTopFrame->AddFrame(fIconBar, new TGLayoutHints(kLHintsNormal));
 
    AddFrame(fTopFrame, new TGLayoutHints(kLHintsNormal | kLHintsExpandX));
 
-   fToggleBar->Connect("Clicked()", "TEveCompositeFrame", this, "FlipTitleBarState()");
-   fTitleBar ->Connect("Clicked()", "TEveCompositeFrame", this, "TitleBarClicked()");
-   fIconBar  ->Connect("Pressed()", "TEveCompositeFrame", this, "ActionPressed()");
-
    // --- MiniBar
-
-   fMiniBar = new TGButton(this);
-   fMiniBar->ChangeOptions(kRaisedFrame | kFixedHeight);
-   fMiniBar->Resize(20, miniH);
-   fMiniBar->SetBackgroundColor(TEveWindow::GetMiniBarBackgroundColor());
-   AddFrame(fMiniBar, new TGLayoutHints(kLHintsNormal | kLHintsExpandX));
-
-   fMiniBar->Connect("Clicked()", "TEveCompositeFrame", this, "FlipTitleBarState()");
+   if (fgAllowTopFrameCollapse)
+   {
+      fMiniBar = new TGButton(this);
+      fMiniBar->ChangeOptions(kRaisedFrame | kFixedHeight);
+      fMiniBar->Resize(20, fgMiniBarHeight);
+      fMiniBar->SetBackgroundColor(TEveWindow::GetMiniBarBackgroundColor());
+      fMiniBar->Connect("Clicked()", "TEveCompositeFrame", this, "FlipTitleBarState()");
+      AddFrame(fMiniBar, new TGLayoutHints(kLHintsNormal | kLHintsExpandX));
+   }
 
    // --- Common settings.
 
@@ -301,28 +331,6 @@ void TEveCompositeFrame::ShowNormalDecorations()
 }
 
 //______________________________________________________________________________
-void TEveCompositeFrame::ReplaceIconBox(TGFrame* icon_box)
-{
-   // Replace default action-button with the provided frame.
-   // The contents will erased via local-cleanup so make sure the frame
-   // will properly destroy its children.
-   // MapWindow is called on the passed frame but not map-subwindows.
-
-   if (fIconBar)
-   {
-      fTopFrame->RemoveFrame(fIconBar);
-      fIconBar->DestroyWindow();
-      delete fIconBar;
-      fIconBar = 0;
-   }
-
-   icon_box->ReparentWindow(fTopFrame);
-   fTopFrame->AddFrame(icon_box, new TGLayoutHints(kLHintsNormal));
-   fTopFrame->Layout();
-   icon_box->MapWindow();
-}
-
-//______________________________________________________________________________
 void TEveCompositeFrame::ActionPressed()
 {
    // The action-button of the title-bar was pressed.
@@ -662,7 +670,7 @@ Pixel_t     TEveWindow::fgCurrentBackgroundColor = 0x80A0C0;
 Pixel_t     TEveWindow::fgMiniBarBackgroundColor = 0x80C0A0;
 
 //______________________________________________________________________________
-TEveWindow::TEveWindow(const Text_t* n, const Text_t* t) :
+TEveWindow::TEveWindow(const char* n, const char* t) :
    TEveElementList(n, t),
 
    fEveFrame     (0),
@@ -1081,7 +1089,7 @@ void TEveWindow::SwapWindows(TEveWindow* w1, TEveWindow* w2)
 ClassImp(TEveWindowSlot);
 
 //______________________________________________________________________________
-TEveWindowSlot::TEveWindowSlot(const Text_t* n, const Text_t* t) :
+TEveWindowSlot::TEveWindowSlot(const char* n, const char* t) :
    TEveWindow (n, t),
    fEmptyButt   (0),
    fEmbedBuffer (0)
@@ -1189,7 +1197,7 @@ TGCompositeFrame* TEveWindowSlot::StartEmbedding()
 }
 
 //______________________________________________________________________________
-TEveWindowFrame* TEveWindowSlot::StopEmbedding(const Text_t* name)
+TEveWindowFrame* TEveWindowSlot::StopEmbedding(const char* name)
 {
    // An embedded window is created in place of this window-slot.
    // This window-slot will auto-destruct.
@@ -1251,7 +1259,7 @@ TEveWindowFrame* TEveWindowSlot::StopEmbedding(const Text_t* name)
 ClassImp(TEveWindowFrame);
 
 //______________________________________________________________________________
-TEveWindowFrame::TEveWindowFrame(TGFrame* frame, const Text_t* n, const Text_t* t) :
+TEveWindowFrame::TEveWindowFrame(TGFrame* frame, const char* n, const char* t) :
    TEveWindow (n, t),
    fGUIFrame  (frame)
 {
@@ -1302,7 +1310,7 @@ TGCompositeFrame* TEveWindowFrame::GetGUICompositeFrame()
 ClassImp(TEveWindowPack);
 
 //______________________________________________________________________________
-TEveWindowPack::TEveWindowPack(TGPack* p, const Text_t* n, const Text_t* t) :
+TEveWindowPack::TEveWindowPack(TGPack* p, const char* n, const char* t) :
    TEveWindow   (n, t),
    fPack        (p ? p : new TGPack())
 {
@@ -1381,7 +1389,7 @@ void TEveWindowPack::EqualizeFrames()
 ClassImp(TEveWindowTab);
 
 //______________________________________________________________________________
-TEveWindowTab::TEveWindowTab(TGTab* tab, const Text_t* n, const Text_t* t) :
+TEveWindowTab::TEveWindowTab(TGTab* tab, const char* n, const char* t) :
    TEveWindow(n, t),
    fTab (tab ? tab : new TGTab())
 {
diff --git a/graf3d/eve/src/TEveWindowManager.cxx b/graf3d/eve/src/TEveWindowManager.cxx
index 9cc5e58..1eefcf5 100644
--- a/graf3d/eve/src/TEveWindowManager.cxx
+++ b/graf3d/eve/src/TEveWindowManager.cxx
@@ -28,7 +28,7 @@
 ClassImp(TEveWindowManager);
 
 //______________________________________________________________________________
-TEveWindowManager::TEveWindowManager(const Text_t* n, const Text_t* t) :
+TEveWindowManager::TEveWindowManager(const char* n, const char* t) :
    TEveElementList(n, t),
    TQObject       (),
    fCurrentWindow    (0),
diff --git a/graf3d/g3d/inc/TPointSet3D.h b/graf3d/g3d/inc/TPointSet3D.h
index 4a38eb3..ee65075 100644
--- a/graf3d/g3d/inc/TPointSet3D.h
+++ b/graf3d/g3d/inc/TPointSet3D.h
@@ -28,6 +28,8 @@ protected:
    Bool_t    fOwnIds; //Flag specifying id-objects are owned by the point-set
    TRefArray fIds;    //User-provided point identifications
 
+   void CopyIds(const TPointSet3D& t);
+
 public:
    TPointSet3D() :
       TPolyMarker3D(), fOwnIds(kFALSE), fIds() { fName="TPointSet3D"; }
diff --git a/graf3d/g3d/inc/TPolyLine3D.h b/graf3d/g3d/inc/TPolyLine3D.h
index 0909e49..4a55127 100644
--- a/graf3d/g3d/inc/TPolyLine3D.h
+++ b/graf3d/g3d/inc/TPolyLine3D.h
@@ -38,13 +38,12 @@
 #endif
 
 
-class TPolyLine3D : public TObject, public TAttLine, public TAtt3D {
-
+class TPolyLine3D : public TObject, public TAttLine, public TAtt3D
+{
 protected:
    Int_t        fN;            //Number of points
    Float_t     *fP;            //[3*fN] Array of 3-D coordinates  (x,y,z)
    TString      fOption;       //options
-   UInt_t       fGLList;       //!The list number for OpenGL view
    Int_t        fLastPoint;    //The index of the last filled point
 
 public:
diff --git a/graf3d/g3d/inc/TPolyMarker3D.h b/graf3d/g3d/inc/TPolyMarker3D.h
index 4d49754..5d5a501 100644
--- a/graf3d/g3d/inc/TPolyMarker3D.h
+++ b/graf3d/g3d/inc/TPolyMarker3D.h
@@ -37,13 +37,12 @@
 class TH1;
 class TCollection;
 
-class TPolyMarker3D : public TObject, public TAttMarker, public TAtt3D {
-
+class TPolyMarker3D : public TObject, public TAttMarker, public TAtt3D
+{
 protected:
    Int_t            fN;            //number of points
    Float_t         *fP;            //[3*fN] Array of X,Y,Z coordinates
    TString          fOption;       //options
-   UInt_t           fGLList;       //!The list number for OpenGL view
    Int_t            fLastPoint;    //The index of the last filled point
    TString          fName;         //name of polymarker
 
diff --git a/graf3d/g3d/inc/TXTRU.h b/graf3d/g3d/inc/TXTRU.h
index d8f8970..1433658 100644
--- a/graf3d/g3d/inc/TXTRU.h
+++ b/graf3d/g3d/inc/TXTRU.h
@@ -24,7 +24,7 @@
 class TXTRU : public TShape {
 public:
    TXTRU();
-   TXTRU(const Text_t *name, const Text_t *title, const Text_t *material,
+   TXTRU(const char *name, const char *title, const char *material,
          Int_t nyx, Int_t nz);
    TXTRU(const TXTRU &xtru);
    virtual ~TXTRU();
diff --git a/graf3d/g3d/src/TPointSet3D.cxx b/graf3d/g3d/src/TPointSet3D.cxx
index 7434e1b..7f717f9 100644
--- a/graf3d/g3d/src/TPointSet3D.cxx
+++ b/graf3d/g3d/src/TPointSet3D.cxx
@@ -14,7 +14,6 @@
 #include "TClass.h"
 
 //______________________________________________________________________
-// TPointSet3D
 //
 // TPolyMarker3D using TPointSet3DGL for direct OpenGL rendering.
 // Supports only elementary marker types:
@@ -39,18 +38,11 @@ ClassImp(TPointSet3D);
 
 //______________________________________________________________________________
 TPointSet3D::TPointSet3D(const TPointSet3D &t) :
-   TPolyMarker3D(t), TAttBBox(t), fOwnIds(t.fOwnIds), fIds()
+   TPolyMarker3D(t), TAttBBox(t), fOwnIds(kFALSE), fIds()
 {
    // Copy constructor.
 
-   fIds.Expand(t.fIds.GetSize());
-   if (fOwnIds) {
-      for (Int_t i=0; i<t.fIds.GetSize(); ++i)
-         fIds.AddAt(t.fIds.At(i)->Clone(), i);
-   } else {
-      for (Int_t i=0; i<t.fIds.GetSize(); ++i)
-         fIds.AddAt(t.fIds.At(i), i);
-   }
+   CopyIds(t);
 }
 
 //______________________________________________________________________________
@@ -62,6 +54,22 @@ TPointSet3D::~TPointSet3D()
 }
 
 //______________________________________________________________________________
+void TPointSet3D::CopyIds(const TPointSet3D& t)
+{
+   // Copy id objects from point-set 't'.
+
+   fOwnIds = t.fOwnIds;
+   fIds.Expand(t.fIds.GetSize());
+   if (fOwnIds) {
+      for (Int_t i=0; i<t.fIds.GetSize(); ++i)
+         fIds.AddAt(t.fIds.At(i)->Clone(), i);
+   } else {
+      for (Int_t i=0; i<t.fIds.GetSize(); ++i)
+         fIds.AddAt(t.fIds.At(i), i);
+   }
+}
+
+//______________________________________________________________________________
 TPointSet3D& TPointSet3D::operator=(const TPointSet3D& t)
 {
    // Assignement operator.
@@ -69,15 +77,7 @@ TPointSet3D& TPointSet3D::operator=(const TPointSet3D& t)
    if (this != &t) {
       ClearIds();
       TPolyMarker3D::operator=(t);
-      fOwnIds = t.fOwnIds;
-      fIds.Expand(t.fIds.GetSize());
-      if (fOwnIds) {
-         for (Int_t i=0; i<t.fIds.GetSize(); ++i)
-            fIds.AddAt(t.fIds.At(i)->Clone(), i);
-      } else {
-         for (Int_t i=0; i<t.fIds.GetSize(); ++i)
-            fIds.AddAt(t.fIds.At(i), i);
-      }
+      CopyIds(t);
    }
    return *this;
 }
diff --git a/graf3d/g3d/src/TPolyLine3D.cxx b/graf3d/g3d/src/TPolyLine3D.cxx
index e012832..7dbe503 100644
--- a/graf3d/g3d/src/TPolyLine3D.cxx
+++ b/graf3d/g3d/src/TPolyLine3D.cxx
@@ -22,8 +22,7 @@
 
 #include <assert.h>
 
-ClassImp(TPolyLine3D)
-
+ClassImp(TPolyLine3D);
 
 //______________________________________________________________________________
 // PolyLine3D is a 3-dimensional polyline. It has 4 different constructors.
@@ -247,7 +246,6 @@ TPolyLine3D& TPolyLine3D::operator=(const TPolyLine3D& pl)
       fN=pl.fN;
       fP=pl.fP;
       fOption=pl.fOption;
-      fGLList=pl.fGLList;
       fLastPoint=pl.fLastPoint;
    } 
    return *this;
diff --git a/graf3d/g3d/src/TPolyMarker3D.cxx b/graf3d/g3d/src/TPolyMarker3D.cxx
index 2fe7263..e02f288 100644
--- a/graf3d/g3d/src/TPolyMarker3D.cxx
+++ b/graf3d/g3d/src/TPolyMarker3D.cxx
@@ -159,7 +159,6 @@ TPolyMarker3D& TPolyMarker3D::operator=(const TPolyMarker3D& tp3)
       fN=tp3.fN;
       fP=tp3.fP;
       fOption=tp3.fOption;
-      fGLList=tp3.fGLList;
       fLastPoint=tp3.fLastPoint;
       fName=tp3.fName;
    }
diff --git a/graf3d/g3d/src/TXTRU.cxx b/graf3d/g3d/src/TXTRU.cxx
index 3d6ee2c..ce43c3d 100644
--- a/graf3d/g3d/src/TXTRU.cxx
+++ b/graf3d/g3d/src/TXTRU.cxx
@@ -78,7 +78,7 @@ TXTRU::TXTRU()
 
 
 //______________________________________________________________________________
-TXTRU::TXTRU(const Text_t *name, const Text_t *title, const Text_t *material,
+TXTRU::TXTRU(const char *name, const char *title, const char *material,
              Int_t nxy, Int_t nz)
    : TShape (name,title,material)
 {
diff --git a/graf3d/gl/inc/LinkDef.h b/graf3d/gl/inc/LinkDef.h
index 46eda75..6112597 100644
--- a/graf3d/gl/inc/LinkDef.h
+++ b/graf3d/gl/inc/LinkDef.h
@@ -64,6 +64,7 @@
 #pragma link C++ class TGLOverlayElement+;
 #pragma link C++ class TGLOverlayList+;
 #pragma link C++ class TGLOverlayButton+;
+#pragma link C++ class TGLAnnotation+;
 
 #pragma link C++ class TGLViewerBase+;
 #pragma link C++ class TGLViewer+;
@@ -92,7 +93,6 @@
 #pragma link C++ class TGLSphere;
 #pragma link C++ class TGLText;
 #pragma link C++ class TGLAxis;
-#pragma link C++ class TGLAxisAttrib;
 #pragma link C++ class TGLAxisPainter;
 
 #pragma link C++ class TGLSelectionBuffer;
diff --git a/graf3d/gl/inc/TGLAnnotation.h b/graf3d/gl/inc/TGLAnnotation.h
new file mode 100644
index 0000000..97bbf91
--- /dev/null
+++ b/graf3d/gl/inc/TGLAnnotation.h
@@ -0,0 +1,77 @@
+// @(#)root/gl:$Id: root-5.22-00d-fireworks-graf3d-gui.patch,v 1.5 2010/10/09 09:42:53 eulisse Exp $
+// Author:  Matevz and Alja Tadel  20/02/2009
+
+/*************************************************************************
+ * Copyright (C) 1995-2004, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#ifndef ROOT_TGLAnnotation
+#define ROOT_TGLAnnotation
+
+#include "TGLOverlay.h"
+#include "TGLUtil.h"
+#include "TGLFontManager.h"
+
+class TGLViewer;
+class TGLViewerBase;
+class TGLFont;
+class TGTextEdit;
+class TGMainFrame;
+
+class TGLAnnotation : public TGLOverlayElement
+{
+private:
+   TGLAnnotation(const TGLAnnotation&);            // Not implemented
+   TGLAnnotation& operator=(const TGLAnnotation&); // Not implemented
+
+   void MakeEditor();
+
+protected:
+   TGMainFrame      *fMainFrame;
+   TGTextEdit       *fTextEdit;
+
+   TGLViewer        *fParent;
+
+   TString           fText;           // annotation text
+   Float_t           fLabelFontSize;  // relative font size
+   TGLFont           fLabelFont;      // font used to render labels
+   TGLFont           fMenuFont;       // font used to render menu buttons
+
+   Pixel_t           fBackColor;      // background color
+   Pixel_t           fBackHighColor;  // background active color
+   Pixel_t           fTextColor;      // text color
+   Pixel_t           fTextHighColor;  // text active color
+   Float_t           fAlpha;          // label transparency
+
+   Float_t           fPosX;           // x position [0, 1]
+   Float_t           fPosY;           // y position [0, 1]
+
+   Int_t             fMouseX, fMouseY; //! last mouse position
+   Bool_t            fInDrag;          //!
+
+   TGLVector3        fPointer;         // picked location in 3D space
+   Bool_t            fActive;          // active item identifier
+
+public:
+   TGLAnnotation(TGLViewerBase *parent, const char *text, Float_t posx, Float_t posy, TGLVector3 ref);
+   virtual ~TGLAnnotation();
+
+   virtual Bool_t MouseEnter(TGLOvlSelectRecord& selRec);
+   virtual Bool_t Handle(TGLRnrCtx& rnrCtx, TGLOvlSelectRecord& selRec,
+                         Event_t* event);
+   virtual void   MouseLeave();
+
+   void CloseEditor();
+
+   void UpdateText();
+
+   virtual void   Render(TGLRnrCtx& rnrCtx);
+
+   ClassDef(TGLAnnotation, 0); // GL-annotation.
+};
+
+#endif
diff --git a/graf3d/gl/inc/TGLAxisPainter.h b/graf3d/gl/inc/TGLAxisPainter.h
index 4c37113..85dd79f 100644
--- a/graf3d/gl/inc/TGLAxisPainter.h
+++ b/graf3d/gl/inc/TGLAxisPainter.h
@@ -2,126 +2,118 @@
 // Author: Matevz Tadel 2007
 
 /*************************************************************************
- * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
- * All rights reserved.                                                  *
- *                                                                       *
- * For the licensing terms see $ROOTSYS/LICENSE.                         *
- * For the list of contributors see $ROOTSYS/README/CREDITS.             *
- *************************************************************************/
+* Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+* All rights reserved.                                                  *
+*                                                                       *
+* For the licensing terms see $ROOTSYS/LICENSE.                         *
+* For the list of contributors see $ROOTSYS/README/CREDITS.             *
+*************************************************************************/
 
 #ifndef ROOT_TGLAxisPainter
 #define ROOT_TGLAxisPainter
 
-#include "TAttAxis.h"
 #include "TGLUtil.h"
-#include "TString.h"
 #include "TGLFontManager.h"
 
+class TAttAxis;
+class TAxis;
 class TGLRnrCtx;
-class TGLFont;
 
-class TGLAxisAttrib: public TAttAxis
+class TGLAxisPainter
 {
-   friend class TGLAxisPainter;
-
-protected:
-   TGLVector3   fDir;
-   Double_t     fMin;
-   Double_t     fMax;
-
-   Float_t      fTMScale[3];
-   TGLVector3   fTMOff[3];
-   Int_t        fTMNDim;
-
-   TGLFont::ETextAlign_e  fTextAlign;
-
-   Bool_t       fRelativeFontSize;
-   Int_t        fAbsLabelFontSize;
-   Int_t        fAbsTitleFontSize;
-
-   TString      fLabelFontName;
-   TString      fTitleFontName;
-
-   TString      fTitle;
-   TString      fTitleUnits;
-   TGLVector3   fTitlePos;
-
 public:
-   TGLAxisAttrib();
-   virtual ~TGLAxisAttrib(){}
+   typedef std::pair  <Float_t, Float_t>    Lab_t; // label <pos, value> pair
+   typedef std::vector<Lab_t>               LabVec_t;
+   typedef std::pair  <Float_t, Int_t>      TM_t;  // tick-mark <pos, order> pair
+   typedef std::vector<TM_t>                TMVec_t; // vector od tick lines
 
-   // Getters && Setters
+private:
+   TGLAxisPainter(const TGLAxisPainter&);            // Not implemented
+   TGLAxisPainter& operator=(const TGLAxisPainter&); // Not implemented
 
-   TGLVector3&  RefDir() { return fDir; }
-   void SetRng(Double_t min, Double_t max) { fMin=min; fMax=max;}
-   void GetRng(Double_t &min, Double_t &max) {min=fMin; max=fMax;}
+   // Print format derived from attributers.
+   Int_t fExp;
+   Int_t fMaxDigits;
+   Int_t fDecimals;
+   char  fFormat[8];
 
-   TGLVector3&  RefTMOff(Int_t i) { return fTMOff[i]; }
-   void SetTMNDim(Int_t i) {fTMNDim=i;}
-   Int_t GetTMNDim() {return fTMNDim;}
+   // Font derived from axis attributes.
+   TGLFont fLabelFont;
+   TGLFont fTitleFont;
 
-   void SetTextAlign(TGLFont::ETextAlign_e a) {fTextAlign=a;}
-   TGLFont::ETextAlign_e GetTextAlign() const { return fTextAlign;}
+   // Print format.
+   void LabelsLimits(const char *label, Int_t &first, Int_t &last) const;
+   void FormAxisValue(Double_t x, TString &s) const;
 
-   void SetRelativeFontSize(Bool_t x) { fRelativeFontSize=x; }
-   Bool_t GetRelativeFontSize() const {return fRelativeFontSize;}
+protected:
+   TAttAxis        *fAttAxis;    // Model.
+   TGLFont::EMode   fFontMode;   // Later in AttAxis
+   LabVec_t         fLabVec;     // List of Labels position-value pairs
+   TMVec_t          fTMVec;      // List of tick-mark position-value pairs
 
-   void  SetAbsLabelFontSize(Int_t fs) {fAbsLabelFontSize=fs;}
-   Int_t GetAbsLabelFontSize()const {return fAbsLabelFontSize;}
-   void  SetAbsTitleFontSize(Int_t fs) {fAbsTitleFontSize=fs;}
-   Int_t GetAbsTitleFontSize() const {return fAbsTitleFontSize;}
+   //
+   // Additional axis attributes required for GL rendering:
 
-   void SetLabelFontName(const char* name) { fLabelFontName = name; }
-   const char*  GetLabelFontName() const {return fLabelFontName.Data();}
-   void SetTitleFontName(const char* name) { fTitleFontName = name; }
-   const char*  GetTitleFontName() const {return fTitleFontName.Data();}
+   // Orientation
+   TGLVector3 fDir;
+   TGLVector3 fTMOff[3];
+   Int_t      fTMNDim;
 
-   void SetTitle(const char* title) {fTitle = title;}
-   const char* GetTitle() const {return fTitle.Data();}
+   // Font.
+   Int_t    fLabelPixelFontSize;
+   Double_t fLabel3DFontSize;
+   Int_t    fTitlePixelFontSize;
+   Double_t fTitle3DFontSize;
 
-   void SetTitleUnits(const char* un) {fTitleUnits = un;}
-   const char* GetTitleUnits() const {return fTitleUnits.Data();}
+   // Labels options. Allready exist in TAttAxis, but can't be set.
+   TGLFont::ETextAlign_e fLabelAlign;
+   TGLVector3 fTitlePos;
 
+public:
+   TGLAxisPainter();
+   virtual ~TGLAxisPainter();
 
-   TGLVector3& RefTitlePos() {return fTitlePos;}
+   // GetSets.
+   Int_t        GetTMNDim() const { return fTMNDim; }
+   void         SetTMNDim(Int_t x) { fTMNDim = x; }
 
-   // override TAttAxis function
-   virtual void	SetNdivisions(Int_t n, Bool_t /*optim*/=kTRUE) { fNdivisions =n; }
+   TGLVector3&  RefDir() { return fDir; }
+   TGLVector3&  RefTMOff(Int_t i) { return fTMOff[i]; }
 
-   ClassDef(TGLAxisAttrib, 0); // GL axis attributes.
-};
+   TGLFont::EMode GetFontMode() const { return fFontMode; }
+   void  SetFontMode(TGLFont::EMode m) { fFontMode=m; }
 
-/**************************************************************************/
+   // this setter not necessary
+   void         SetLabelPixelFontSize(Int_t fs) { fLabelPixelFontSize=fs; }
+   Int_t        GetLabelPixelFontSize() const { return fLabelPixelFontSize; }
+   void         SetTitlePixelFontSize(Int_t fs) { fTitlePixelFontSize=fs; }
+   Int_t        GetTitlePixelFontSize() const { return fTitlePixelFontSize; }
 
-class TGLAxisPainter
-{
-private:
-   TGLAxisPainter(const TGLAxisPainter&);            // Not implemented
-   TGLAxisPainter& operator=(const TGLAxisPainter&); // Not implemented
+   TGLVector3&  RefTitlePos() { return fTitlePos; }
 
-protected:
-   void DrawTick(TGLVector3 &tv, Int_t order) const;
 
-   void RnrText(const char* txt, TGLVector3 pos, TGLFont &font) const;
-   void LabelsLimits(const char *label, Int_t &first, Int_t &last) const;
+   TGLFont::ETextAlign_e GetLabelAlign() const { return fLabelAlign; }
+   void         SetLabelAlign(TGLFont::ETextAlign_e x) { fLabelAlign = x; }
 
+   LabVec_t& RefLabVec() { return fLabVec; }
+   TMVec_t&  RefTMVec()  { return fTMVec; }
 
-   TGLAxisAttrib* fAtt;
+   void      SetAttAxis(TAttAxis* a) { fAttAxis = a; }
+   TAttAxis* GetAttAxis() { return fAttAxis; }
 
-   Int_t          fMaxDigits;
-   Int_t          fDecimals;  // cached
-   char           fFormat[8]; // cached
-   Int_t          fExp;        //cached
+   // Utility.
+   void SetLabelFont(TGLRnrCtx &rnrCtx, const char* fontName, Int_t pixelSize = 64, Double_t font3DSize = -1);
+   void SetTitleFont(TGLRnrCtx &rnrCtx, const char* fontName, Int_t pixelSize = 64, Double_t font3DSize = -1);
 
-public:
-   TGLAxisPainter();
-   virtual ~TGLAxisPainter() {}
+   void SetTextFormat(Double_t min, Double_t max, Double_t binWidth);
 
-   void Paint(TGLRnrCtx& ctx, TGLAxisAttrib &atrib);
+   // Renderers.
+   void RnrText( const char* txt, const TGLVector3 &pos, const TGLFont::ETextAlign_e align, const TGLFont &font) const;
+   void RnrTitle(const char* title, TGLVector3 &pos, TGLFont::ETextAlign_e align) const;
+   void RnrLabels() const;
+   void RnrLines() const;
 
-   void SetTextFormat(Double_t binWidth);
-   void SetAxisAtt(TGLAxisAttrib* axa){ fAtt = axa; }
-   void FormAxisValue(Float_t x, char* lab) const;
+   void PaintAxis(TGLRnrCtx& ctx, TAxis* ax);
 
    ClassDef(TGLAxisPainter, 0); // GL axis painter.
 };
diff --git a/graf3d/gl/inc/TGLCamera.h b/graf3d/gl/inc/TGLCamera.h
index fae447a..df7554f 100644
--- a/graf3d/gl/inc/TGLCamera.h
+++ b/graf3d/gl/inc/TGLCamera.h
@@ -135,6 +135,7 @@ public:
 
    virtual Bool_t Dolly(Int_t delta, Bool_t mod1, Bool_t mod2);
    virtual Bool_t Zoom (Int_t delta, Bool_t mod1, Bool_t mod2) = 0;
+   virtual Bool_t Truck(Double_t xDelta, Double_t yDelta);
    virtual Bool_t Truck(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2) = 0;
    virtual Bool_t Rotate(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2);
    virtual Bool_t RotateRad(Double_t hRotate, Double_t vRotate);
diff --git a/graf3d/gl/inc/TGLCameraOverlay.h b/graf3d/gl/inc/TGLCameraOverlay.h
index 9114b03..cbf70af 100644
--- a/graf3d/gl/inc/TGLCameraOverlay.h
+++ b/graf3d/gl/inc/TGLCameraOverlay.h
@@ -12,9 +12,15 @@
 #ifndef ROOT_TGLCameraOverlay
 #define ROOT_TGLCameraOverlay
 
-#include "TGLOverlay.h"
-#include "TGLAxisPainter.h"
 #include "TAttAxis.h"
+#include "TGLOverlay.h"
+#include "TGLUtil.h"
+
+class TGLAxisPainter;
+class TGLFont;
+
+class TAttAxis;
+class TAxis;
 
 class TGLCameraOverlay : public TGLOverlayElement
 {
@@ -25,6 +31,8 @@ private:
    TGLCameraOverlay(const TGLCameraOverlay&);            // Not implemented
    TGLCameraOverlay& operator=(const TGLCameraOverlay&); // Not implemented
 
+   Double_t       fFrustum[4];
+
 protected:
    Bool_t         fShowOrthographic;
    Bool_t         fShowPerspective;
@@ -32,32 +40,26 @@ protected:
    EMode          fOrthographicMode;
    EMode          fPerspectiveMode;
 
-   TGLAxisPainter fAxisPainter;
-   TGLAxisAttrib   fAxisAtt;
-
-   Float_t          fAxisExtend;
-   TGLPlane      fExternalRefPlane;
-   Bool_t           fUseExternalRefPlane;
+   TGLAxisPainter *fAxisPainter;
+   TAxis          *fAxis;
+   Float_t         fAxisExtend;
 
-  Double_t         fFrustum[4]; // cached
+   TGLPlane       fExternalRefPlane;
+   Bool_t         fUseExternalRefPlane;
 
-   void    RenderPlaneIntersect(TGLRnrCtx& rnrCtx, const TGLFont &font);
+   void    RenderPlaneIntersect(TGLRnrCtx& rnrCtx);
    void    RenderAxis(TGLRnrCtx& rnrCtx);
-   void    RenderBar(TGLRnrCtx& rnrCtx, const TGLFont &font);
+   void    RenderBar(TGLRnrCtx& rnrCtx);
 
 public:
    TGLCameraOverlay(Bool_t showOrtho=kTRUE, Bool_t showPersp=kFALSE);
-   virtual ~TGLCameraOverlay() {}
+   virtual ~TGLCameraOverlay();
 
    virtual  void   Render(TGLRnrCtx& rnrCtx);
 
-   TGLAxisAttrib&  RefAxisAttrib() { return fAxisAtt; }
-   Float_t GetAxisExtend() const { return fAxisExtend; }
-   void    SetAxisExtend(Float_t x) { fAxisExtend = x; }
-
    TGLPlane& RefExternalRefPlane() { return fExternalRefPlane; }
-   void  UseExternalRefPlane(Bool_t x) { fUseExternalRefPlane=x; }
-   Bool_t GetUseExternalRefPlane() const { return fUseExternalRefPlane; }
+   void      UseExternalRefPlane(Bool_t x) { fUseExternalRefPlane=x; }
+   Bool_t    GetUseExternalRefPlane() const { return fUseExternalRefPlane; }
 
    Int_t    GetPerspectiveMode() const { return fPerspectiveMode;}
    void     SetPerspectiveMode(EMode m) {fPerspectiveMode = m;}
@@ -69,6 +71,7 @@ public:
    Bool_t   GetShowPerspective() const { return fShowPerspective; }
    void     SetShowPerspective(Bool_t x) {fShowPerspective =x;}
 
+   TAttAxis* GetAttAxis();
 
    ClassDef(TGLCameraOverlay, 1); // Show coorinates of current camera frustum.
 };
diff --git a/graf3d/gl/inc/TGLFontManager.h b/graf3d/gl/inc/TGLFontManager.h
index 379bb59..df524bf 100644
--- a/graf3d/gl/inc/TGLFontManager.h
+++ b/graf3d/gl/inc/TGLFontManager.h
@@ -64,19 +64,25 @@ public:
 
    void  SetFont(FTFont *f) { fFont =f;}
    const FTFont* GetFont() const { return fFont; }
-   void  SetManager(TGLFontManager *mng) {fManager = mng;}
+   void  SetManager(TGLFontManager *mng)    { fManager = mng;  }
    const TGLFontManager* GetManager() const { return fManager; }
 
-   Float_t GetDepth() const { return fDepth;}
-   void  SetDepth(Float_t d) { fDepth = d; }
+   Float_t GetDepth()    const { return fDepth; }
+   void    SetDepth(Float_t d) { fDepth = d;    }
 
    // FTGL wrapper functions
-   void  BBox(const Text_t* txt,
-               Float_t& llx, Float_t& lly, Float_t& llz,
-               Float_t& urx, Float_t& ury, Float_t& urz) const;
+   Float_t GetAscent() const;
+   Float_t GetDescent() const;
+   Float_t GetLineHeight() const;
+   void    MeasureBaseLineParams(Float_t& ascent, Float_t& descent, Float_t& line_height,
+                                 const char* txt="Xj") const;
 
-   void  Render(const Text_t* txt) const;
-   void  RenderBitmap(const Text_t* txt, Float_t x, Float_t y, Float_t zs, ETextAlign_e align) const;
+   void  BBox(const char* txt,
+              Float_t& llx, Float_t& lly, Float_t& llz,
+              Float_t& urx, Float_t& ury, Float_t& urz) const;
+
+   void  Render(const char* txt) const;
+   void  RenderBitmap(const char* txt, Float_t x, Float_t y, Float_t zs, ETextAlign_e align) const;
 
    // helper gl draw functions
    virtual void PreRender(Bool_t autoLight=kTRUE, Bool_t lightOn=kFALSE) const;
@@ -131,7 +137,7 @@ public:
    virtual ~TGLFontManager();
 
    void   RegisterFont(Int_t size, Int_t file, TGLFont::EMode mode, TGLFont& out);
-   void   RegisterFont(Int_t size, const Text_t* name, TGLFont::EMode mode, TGLFont& out);
+   void   RegisterFont(Int_t size, const char* name, TGLFont::EMode mode, TGLFont& out);
    void   ReleaseFont(TGLFont& font);
 
    static TObjArray*        GetFontFileArray();
diff --git a/graf3d/gl/inc/TGLIsoMesh.h b/graf3d/gl/inc/TGLIsoMesh.h
new file mode 100644
index 0000000..8470812
--- /dev/null
+++ b/graf3d/gl/inc/TGLIsoMesh.h
@@ -0,0 +1,77 @@
+#ifndef ROOT_TGLIsoMesh
+#define ROOT_TGLIsoMesh
+
+#include <vector>
+
+#ifndef ROOT_Rtypes
+#include "Rtypes.h"
+#endif
+
+namespace Rgl {
+namespace Mc {
+
+/*
+TIsoMesh - set of vertices, per-vertex normals, "triangles". 
+Each "triangle" is a triplet of indices, pointing into vertices 
+and normals arrays. For example, triangle t = {1, 4, 6}
+has vertices &fVerts[1 * 3], &fVerts[4 * 3], &fVerts[6 * 3];
+and normals &fNorms[1 * 3], &fNorms[4 * 3], &fNorms[6 * 3]
+"V" parameter should be Float_t or Double_t (or some
+integral type?).
+
+Prefix "T" in a class name only for code-style checker.
+*/
+
+template<class V>
+class TIsoMesh {
+public:
+   UInt_t AddVertex(const V *v)
+   {
+      const UInt_t index = UInt_t(fVerts.size() / 3);
+      fVerts.push_back(v[0]);
+      fVerts.push_back(v[1]);
+      fVerts.push_back(v[2]);
+
+      return index;
+   }
+
+   void AddNormal(const V *n)
+   {
+      fNorms.push_back(n[0]);
+      fNorms.push_back(n[1]);
+      fNorms.push_back(n[2]);
+   }
+
+   UInt_t AddTriangle(const UInt_t *t)
+   {
+      const UInt_t index = UInt_t(fTris.size() / 3);
+      fTris.push_back(t[0]);
+      fTris.push_back(t[1]);
+      fTris.push_back(t[2]);
+
+      return index;
+   }
+
+   void Swap(TIsoMesh &rhs)
+   {
+      std::swap(fVerts, rhs.fVerts);
+      std::swap(fNorms, rhs.fNorms);
+      std::swap(fTris, rhs.fTris);
+   }
+
+   void ClearMesh()
+   {
+      fVerts.clear();
+      fNorms.clear();
+      fTris.clear();
+   }
+
+   std::vector<V>      fVerts;
+   std::vector<V>      fNorms;
+   std::vector<UInt_t> fTris;
+};
+
+}//namespace Mc
+}//namespace Rgl
+
+#endif
diff --git a/graf3d/gl/inc/TGLLightSetEditor.h b/graf3d/gl/inc/TGLLightSetEditor.h
index 59cfd1c..2036e90 100644
--- a/graf3d/gl/inc/TGLLightSetEditor.h
+++ b/graf3d/gl/inc/TGLLightSetEditor.h
@@ -35,7 +35,7 @@ protected:
 
    TGButton         *fSpecularLight;
 
-   TGButton* MakeLampButton(const Text_t* name, Int_t wid, TGCompositeFrame* parent);
+   TGButton* MakeLampButton(const char* name, Int_t wid, TGCompositeFrame* parent);
 
 public:
    TGLLightSetSubEditor(const TGWindow* p);
diff --git a/graf3d/gl/inc/TGLMarchingCubes.h b/graf3d/gl/inc/TGLMarchingCubes.h
new file mode 100644
index 0000000..ee82f29
--- /dev/null
+++ b/graf3d/gl/inc/TGLMarchingCubes.h
@@ -0,0 +1,454 @@
+#ifndef ROOT_TGLMarchingCubes
+#define ROOT_TGLMarchingCubes
+
+#include <vector>
+
+#ifndef ROOT_TH3
+#include "TH3.h"
+#endif
+
+#ifndef ROOT_TGLIsoMesh
+#include "TGLIsoMesh.h"
+#endif
+
+/*
+Implementation of "marching cubes" algortihm for GL module. Used by 
+TGLTF3Painter and TGLIsoPainter. 
+Good and clear algorithm explanation can be found here: 
+http://local.wasp.uwa.edu.au/~pbourke/geometry/polygonise/
+*/
+
+class TF3;
+
+namespace Rgl {
+namespace Mc {
+
+/*
+"T" prefix in class names is only for code-style checker.
+*/
+
+/*
+TCell is a cube from marching cubes algorithm.
+It has "type" - defines, which vertices
+are under iso level, which are above.
+
+Vertices numeration:
+
+           |z
+           |
+           4____________7
+          /|           /|
+         / |          / |
+        /  |         /  |
+       /   |        /   |
+      5____|_______6    | 
+      |    0_______|____3______ y
+      |   /        |   /
+      |  /         |  /
+      | /          | /
+      |/           |/
+      1____________2
+     /
+    /x
+
+TCell's "type" is 8-bit number, one bit per vertex.
+So, if vertex 1 and 2 are under iso-surface, type
+will be:
+
+ 7 6 5 4 3 2 1 0 (bit number)
+[0 0 0 0 0 1 1 0] bit pattern
+
+type == 6.
+
+Edges numeration:
+
+           |z
+           |
+           |_____7______
+          /|           /|
+         / |          / |
+       4/  8         6  11
+       /   |        /   |
+      /____|5______/    | 
+      |    |_____3_|____|______ y
+      |   /        |   /
+      9  /        10  /
+      | /0         | /2
+      |/           |/
+      /____________/
+     /      1
+    /x
+
+There are 12 edges, any of them can be intersected by iso-surface
+(not all 12 simultaneously). Edge's intersection is a vertex in 
+iso-mesh's vertices array, cell holds index of this vertex in 
+fIds array.
+fVals holds "scalar field" or density values in vertices [0, 7].
+
+"V" parameter is the type to hold such values.
+*/
+
+template<class V>
+class TCell {
+public:
+   TCell() : fType(), fIds(), fVals()
+   {
+      //TCell ctor.
+      //Such mem-initializer list can produce
+      //warnings with some versions of MSVC,
+      //but this list is what I want.
+   }
+
+   UInt_t     fType;
+   UInt_t     fIds[12];
+   V          fVals[8];
+};
+
+/*
+TSlice of marching cubes' grid. Has W * H cells. 
+If you have TH3 hist, GetNbinsX() is W and GetNbinsY() is H.
+*/
+template<class V>
+class TSlice {
+public:
+   TSlice()
+   {
+   }
+
+   void ResizeSlice(UInt_t w, UInt_t h)
+   {
+      fCells.resize(w * h);
+   }
+
+   std::vector<TCell<V> > fCells;
+private:
+   TSlice(const TSlice &rhs);
+   TSlice & operator = (const TSlice &rhs);
+};
+
+/*
+Mesh builder requires generic "data source": it can 
+be a wrapped TH3 object, a wrapped TF3 object or some 
+"density estimator" object.
+Mesh builder inherits this data source type.
+
+TH3Adapter is one of such data sources.
+It has _direct_ access to TH3 internal data. 
+GetBinContent(i, j, k) is a virtual function 
+and it calls two other virtual functions - this 
+is very expensive if you call GetBinContent 
+several million times as I do in marching cubes.
+
+"H" parameter is one of TH3 classes,
+"E" is the type of internal data.
+
+For example, H == TH3C, E == Char_t.
+*/
+
+template<class H, class E>
+class TH3Adapter {
+protected:
+
+   typedef E    ElementType_t;
+
+   TH3Adapter() 
+      : fSrc(0), fW(0), fH(0), fD(0), fSliceSize(0)
+   {
+   }
+
+   UInt_t GetW()const
+   {
+      return fW - 2;
+   }
+
+   UInt_t GetH()const
+   {
+      return fH - 2;
+   }
+
+   UInt_t GetD()const
+   {
+      return fD - 2;
+   }
+
+   void SetDataSource(const H *hist)
+   {
+      fSrc = hist->GetArray();
+      fW   = hist->GetNbinsX() + 2;
+      fH   = hist->GetNbinsY() + 2;
+      fD   = hist->GetNbinsZ() + 2;
+      fSliceSize = fW * fH;
+   }
+
+   ElementType_t GetData(UInt_t i, UInt_t j, UInt_t k)const
+   {
+      i += 1;
+      j += 1;
+      k += 1;
+      return fSrc[k * fSliceSize + j * fW + i];
+   }
+
+   const ElementType_t *fSrc;
+   UInt_t fW;
+   UInt_t fH;
+   UInt_t fD;
+   UInt_t fSliceSize;
+};
+
+/*
+TGridGeometry describes ranges and cell steps (scales are 
+already in steps and ranges).
+*/
+template<class V>
+class TGridGeometry {
+public:
+   TGridGeometry() : fMinX(0), fStepX(0),
+                     fMinY(0), fStepY(0),
+                     fMinZ(0), fStepZ(0)
+   {
+   }
+
+   V fMinX;
+   V fStepX;
+
+   V fMinY;
+   V fStepY;
+
+   V fMinZ;
+   V fStepZ;
+};
+
+/*
+TF3Adapter. Lets TMeshBuilder to use TF3 as a 3d array.
+TF3Adapter, TF3EdgeSplitter (see below) and TMeshBuilder<TF3, ValueType>
+need TGridGeometry<ValueType>, so TGridGeometry is a virtual base.
+*/
+
+class TF3Adapter : protected virtual TGridGeometry<Double_t> {
+protected:
+   typedef Double_t ElementType_t;
+
+   TF3Adapter() : fTF3(0), fW(0), fH(0), fD(0)
+   {
+   }
+
+   UInt_t GetW()const
+   {
+      return fW;
+   }
+
+   UInt_t GetH()const
+   {
+      return fH;
+   }
+
+   UInt_t GetD()const
+   {
+      return fD;
+   }
+
+   void SetDataSource(const TF3 *f);
+   Double_t GetData(UInt_t i, UInt_t j, UInt_t k)const;
+
+   const TF3 *fTF3;//TF3 data source.
+   //TF3 grid's dimensions.
+   UInt_t     fW;
+   UInt_t     fH;
+   UInt_t     fD;
+};
+
+/*
+TSourceAdapterSelector is aux. class used by TMeshBuilder to 
+select "data-source" base depending on data-source type.
+*/
+template<class> class TSourceAdapterSelector;
+
+template<>
+class TSourceAdapterSelector<TH3C> {
+public:
+   typedef TH3Adapter<TH3C, Char_t> Type_t;
+};
+
+template<>
+class TSourceAdapterSelector<TH3S> {
+public:
+   typedef TH3Adapter<TH3S, Short_t> Type_t;
+};
+
+template<>
+class TSourceAdapterSelector<TH3I> {
+public:
+   typedef TH3Adapter<TH3I, Int_t> Type_t;
+};
+
+template<>
+class TSourceAdapterSelector<TH3F> {
+public:
+   typedef TH3Adapter<TH3F, Float_t> Type_t;
+};
+
+template<>
+class TSourceAdapterSelector<TH3D> {
+public:
+   typedef TH3Adapter<TH3D, Double_t> Type_t;
+};
+
+template<>
+class TSourceAdapterSelector<TF3> {
+public:
+   typedef TF3Adapter Type_t;
+};
+
+/*
+Edge splitter is the second base class for TMeshBuilder.
+Its task is to split cell's edge by adding new vertex
+into mesh. 
+*/
+
+template<class H, class E, class V>
+class TH3EdgeSplitter : protected TGridGeometry<V> {
+protected:
+   void SetNormalEvaluator(const H * /*hist*/)
+   {
+   }
+   void SplitEdge(TCell<E> & cell, TIsoMesh<V> * mesh, UInt_t i, 
+                  V x, V y, V z, V iso)const;
+};
+
+/*
+TF3's edge splitter. Calculates new vertex and surface normal
+in this vertex using TF3.
+*/
+
+class TF3EdgeSplitter : protected virtual TGridGeometry<Double_t> {
+protected:
+   TF3EdgeSplitter() : fTF3(0)
+   {
+   }
+
+   void SetNormalEvaluator(const TF3 *tf3)
+   {
+      fTF3 = tf3;
+   }
+
+   void SplitEdge(TCell<Double_t> & cell, TIsoMesh<Double_t> * mesh, UInt_t i,
+                  Double_t x, Double_t y, Double_t z, Double_t iso)const;
+   
+   const TF3 *fTF3;
+};
+
+/*
+TSplitterSelector is aux. class to select "edge-splitter" base
+for TMeshBuilder.
+*/
+
+template<class, class> class TSplitterSelector;
+
+template<class V>
+class TSplitterSelector<TH3C, V> {
+public:
+   typedef TH3EdgeSplitter<TH3C, Char_t, V> Type_t; 
+};
+
+template<class V>
+class TSplitterSelector<TH3S, V> {
+public:
+   typedef TH3EdgeSplitter<TH3S, Short_t, V> Type_t; 
+};
+
+template<class V>
+class TSplitterSelector<TH3I, V> {
+public:
+   typedef TH3EdgeSplitter<TH3I, Int_t, V> Type_t; 
+};
+
+template<class V>
+class TSplitterSelector<TH3F, V> {
+public:
+   typedef TH3EdgeSplitter<TH3F, Float_t, V> Type_t; 
+};
+
+template<class V>
+class TSplitterSelector<TH3D, V> {
+public:
+   typedef TH3EdgeSplitter<TH3D, Double_t, V> Type_t; 
+};
+
+template<class V>
+class TSplitterSelector<TF3, V> {
+public:
+   typedef TF3EdgeSplitter Type_t; 
+};
+
+/*
+Mesh builder. Polygonizes scalar field - TH3, TF3 or
+something else (some density estimator as data-source).
+
+ValueType is Float_t or Double_t - the type of vertex'
+x,y,z components.
+*/
+
+template<class DataSource, class ValueType>
+class TMeshBuilder : public TSourceAdapterSelector<DataSource>::Type_t,
+                     public TSplitterSelector<DataSource, ValueType>::Type_t
+{
+private:
+   //Two base classes.
+   typedef typename TSourceAdapterSelector<DataSource>::Type_t       DataSourceBase_t;
+   typedef typename TSplitterSelector<DataSource, ValueType>::Type_t SplitterBase_t;
+   //Using declarations required, since these are
+   //type-dependant names in template.
+   using DataSourceBase_t::GetW;
+   using DataSourceBase_t::GetH;
+   using DataSourceBase_t::GetD;
+   using DataSourceBase_t::GetData;
+   
+   typedef typename DataSourceBase_t::ElementType_t ElementType_t;
+
+   typedef TCell<ElementType_t>  CellType_t;
+   typedef TSlice<ElementType_t> SliceType_t;
+   typedef TIsoMesh<ValueType>   MeshType_t;
+
+public:
+   TMeshBuilder(Bool_t averagedNormals, ValueType eps = 1e-7)
+      : fAvgNormals(averagedNormals), fMesh(0), fIso(), fEpsilon(eps)
+   {
+   }
+
+   void BuildMesh(const DataSource *src, const TGridGeometry<ValueType> &geom,
+                  MeshType_t *mesh, ValueType iso);
+
+private:
+
+   Bool_t      fAvgNormals;
+   SliceType_t fSlices[2];
+   MeshType_t *fMesh;
+   ValueType   fIso;
+   ValueType   fEpsilon;
+
+   void NextStep(UInt_t depth, const SliceType_t *prevSlice, 
+                 SliceType_t *curr)const;
+
+   void BuildFirstCube(SliceType_t *slice)const;
+   void BuildRow(SliceType_t *slice)const;
+   void BuildCol(SliceType_t *slice)const;
+   void BuildSlice(SliceType_t *slice)const;
+   void BuildFirstCube(UInt_t depth, const SliceType_t *prevSlice,
+                       SliceType_t *slice)const;
+   void BuildRow(UInt_t depth, const SliceType_t *prevSlice,
+                 SliceType_t *slice)const;
+   void BuildCol(UInt_t depth, const SliceType_t *prevSlice,
+                 SliceType_t *slice)const;
+   void BuildSlice(UInt_t depth, const SliceType_t *prevSlice, 
+                   SliceType_t *slice)const;
+
+   void BuildNormals()const;
+
+   TMeshBuilder(const TMeshBuilder &rhs);
+   TMeshBuilder & operator = (const TMeshBuilder &rhs);
+};
+
+}//namespace Mc
+}//namespace Rgl
+
+#endif
diff --git a/graf3d/gl/inc/TGLOrthoCamera.h b/graf3d/gl/inc/TGLOrthoCamera.h
index 7ab0955..6279a8c 100644
--- a/graf3d/gl/inc/TGLOrthoCamera.h
+++ b/graf3d/gl/inc/TGLOrthoCamera.h
@@ -82,6 +82,7 @@ public:
 
    virtual Bool_t Dolly(Int_t delta, Bool_t mod1, Bool_t mod2);
    virtual Bool_t Zoom (Int_t delta, Bool_t mod1, Bool_t mod2);
+   using   TGLCamera::Truck;
    virtual Bool_t Truck(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2);
    virtual Bool_t Rotate(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2);
    virtual void   Apply(const TGLBoundingBox & sceneBox, const TGLRect * pickRect = 0) const;
diff --git a/graf3d/gl/inc/TGLPerspectiveCamera.h b/graf3d/gl/inc/TGLPerspectiveCamera.h
index 3cd0395..7a8ed8e 100644
--- a/graf3d/gl/inc/TGLPerspectiveCamera.h
+++ b/graf3d/gl/inc/TGLPerspectiveCamera.h
@@ -47,6 +47,7 @@ public:
    virtual void   Setup(const TGLBoundingBox & box, Bool_t reset=kTRUE);
    virtual void   Reset();
    virtual Bool_t Zoom (Int_t delta, Bool_t mod1, Bool_t mod2);
+   using   TGLCamera::Truck;
    virtual Bool_t Truck(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2);
    virtual void   Apply(const TGLBoundingBox & box, const TGLRect * pickRect = 0) const;
 
diff --git a/graf3d/gl/inc/TGLPlotPainter.h b/graf3d/gl/inc/TGLPlotPainter.h
index baeb974..32cb479 100644
--- a/graf3d/gl/inc/TGLPlotPainter.h
+++ b/graf3d/gl/inc/TGLPlotPainter.h
@@ -75,6 +75,17 @@ public:
 
    Bool_t IsInCut(Double_t xMin, Double_t xMax, Double_t yMin, Double_t yMax,
                   Double_t zMin, Double_t zMax)const;
+
+   template<class V>
+   Bool_t IsInCut(const V * v) const
+   {
+      //Check, if box defined by xmin/xmax etc. is in cut.
+      if (v[0] >= fXRange.first && v[0] < fXRange.second &&
+          v[1] >= fYRange.first && v[1] < fYRange.second &&
+          v[2] >= fZRange.first && v[2] < fZRange.second)
+         return kTRUE;
+      return kFALSE;
+   }
 private:
    void AdjustBox();
 
diff --git a/graf3d/gl/inc/TGLRnrCtx.h b/graf3d/gl/inc/TGLRnrCtx.h
index 750d348..38998dd 100644
--- a/graf3d/gl/inc/TGLRnrCtx.h
+++ b/graf3d/gl/inc/TGLRnrCtx.h
@@ -217,7 +217,7 @@ public:
    void SetGLCtxIdentity(TGLContextIdentity* cid) { fGLCtxIdentity = cid; }
 
    void  RegisterFont(Int_t size, Int_t file, Int_t mode, TGLFont& out);
-   void  RegisterFont(Int_t size, const Text_t* name, Int_t mode, TGLFont& out);
+   void  RegisterFont(Int_t size, const char* name, Int_t mode, TGLFont& out);
    void  ReleaseFont(TGLFont& font);
 
    GLUquadric* GetGluQuadric() { return fQuadric; }
diff --git a/graf3d/gl/inc/TGLTF3Painter.h b/graf3d/gl/inc/TGLTF3Painter.h
index 04faacd..3a603de 100644
--- a/graf3d/gl/inc/TGLTF3Painter.h
+++ b/graf3d/gl/inc/TGLTF3Painter.h
@@ -7,6 +7,9 @@
 #ifndef ROOT_TGLPlotPainter
 #include "TGLPlotPainter.h"
 #endif
+#ifndef ROOT_TGLIsoMesh
+#include "TGLIsoMesh.h"
+#endif
 #ifndef ROOT_TGLUtil
 #include "TGLUtil.h"
 #endif
@@ -14,6 +17,10 @@
 class TGLOrthoCamera;
 class TF3;
 
+/*
+Draw TF3 using marching cubes.
+*/
+
 class TGLTF3Painter : public TGLPlotPainter {
 private:
    enum ETF3Style {
@@ -25,14 +32,7 @@ private:
 
    ETF3Style fStyle;
 
-public:
-   struct TriFace_t {
-      TGLVertex3 fXYZ[3];
-      TGLVector3 fNormals[3];
-   };
-
-private:
-   std::vector<TriFace_t> fMesh;
+   Rgl::Mc::TIsoMesh<Double_t> fMesh;
    TF3 *fF3;
 
    TGLTH3Slice fXOZSlice;
@@ -53,6 +53,11 @@ public:
 private:
    void    InitGL()const;
    void    DrawPlot()const;
+   //
+   void    DrawToSelectionBuffer()const;
+   void    DrawDefaultPlot()const;
+   void    DrawMaplePlot()const;
+   //
 
    void    SetSurfaceColor()const;
    Bool_t  HasSections()const;
@@ -72,68 +77,35 @@ private:
 */
 
 class TGLIsoPainter : public TGLPlotPainter {
-public:
-   //Triangle face of iso mesh.
-   struct TriFace_t {
-      TGLVertex3 fXYZ[3];
-      TGLVector3 fNormal;//Flat normal.
-      TGLVector3 fPerVertexNormals[3];//Smoothed normals for each vertex.
-   };
-   //Each of cubes (marching-cubes) has a
-   //corresponding set of triangles in a mesh, possibly empty.
-   //fFirst is the number of the first triangle,
-   //fLast is the end of the range (excluded).
-   struct Range_t {
-      Range_t() : fFirst(-1), fLast(0)
-      {
-      }
-      Range_t(Int_t f, Int_t l) : fFirst(f), fLast(l)
-      {
-      }
-      Int_t fFirst;
-      Int_t fLast;
-   };
-   struct Mesh_t {
-      //std::vector<Range_t>   fBoxRanges;
-      std::vector<TriFace_t> fMesh;
-      void Swap(Mesh_t &rhs)
-      {
-         //std::swap(fBoxRanges, rhs.fBoxRanges);
-         std::swap(fMesh,      rhs.fMesh);
-      }
-   };
-
 private:
-   TGLTH3Slice fXOZSlice;
-   TGLTH3Slice fYOZSlice;
-   TGLTH3Slice fXOYSlice;
-
-   Mesh_t                                    fDummyMesh;
-
+   typedef Rgl::Mc::TIsoMesh<Float_t>        Mesh_t;
    typedef std::list<Mesh_t>                 MeshList_t;
    typedef std::list<Mesh_t>::iterator       MeshIter_t;
    typedef std::list<Mesh_t>::const_iterator ConstMeshIter_t;
 
+   TGLTH3Slice           fXOZSlice;
+   TGLTH3Slice           fYOZSlice;
+   TGLTH3Slice           fXOYSlice;
+
+   Mesh_t                fDummyMesh;
    //List of meshes.
-   MeshList_t                                fIsos;
-   //Cheched meshes (will be used if geometry must be rebuilt
+   MeshList_t            fIsos;
+   //Cached meshes (will be used if geometry must be rebuilt
    //after TPad::PaintModified)
-   MeshList_t                                fCache;
+   MeshList_t            fCache;
    //Min and max bin contents.
-   Rgl::Range_t                              fMinMax;
+   Rgl::Range_t          fMinMax;
    //Palette. One color per iso-surface.
-   TGLLevelPalette                           fPalette;
+   TGLLevelPalette       fPalette;
    //Iso levels. Equidistant or user-defined.
-   std::vector<Double_t>                     fColorLevels;
-
+   std::vector<Double_t> fColorLevels;
    //Now meshes are initialized only once.
    //To be changed in future.
-   Bool_t                                    fInit;
+   Bool_t                fInit;
 
 public:
    TGLIsoPainter(TH1 *hist, TGLOrthoCamera *camera, TGLPlotCoordinates *coord,
                  TGLPaintDevice *dev = 0);
-
    //TGLPlotPainter final-overriders.
    char    *GetPlotInfo(Int_t px, Int_t py);
    Bool_t   InitGeometry();
@@ -154,7 +126,6 @@ private:
    void     SetSurfaceColor(Int_t ind)const;
    void     SetMesh(Mesh_t &mesh, Double_t isoValue);
    void     DrawMesh(const Mesh_t &mesh, Int_t level)const;
-   void     CheckBox(const std::vector<TriFace_t> &mesh, TriFace_t &face, const Range_t &box);
    void     FindMinMax();
 
    TGLIsoPainter(const TGLIsoPainter &);
diff --git a/graf3d/gl/inc/TGLUtil.h b/graf3d/gl/inc/TGLUtil.h
index 1dd9f13..c96826b 100644
--- a/graf3d/gl/inc/TGLUtil.h
+++ b/graf3d/gl/inc/TGLUtil.h
@@ -758,6 +758,8 @@ public:
 
    void Translate(const TGLVector3 & vect);
    void MoveLF(Int_t ai, Double_t amount);
+   void Move3LF(Double_t x, Double_t y, Double_t z);
+
    void Scale(const TGLVector3 & scale);
    void Rotate(const TGLVertex3 & pivot, const TGLVector3 & axis, Double_t angle);
    void RotateLF(Int_t i1, Int_t i2, Double_t amount);
diff --git a/graf3d/gl/inc/TGLViewer.h b/graf3d/gl/inc/TGLViewer.h
index fa117d4..14e1187 100644
--- a/graf3d/gl/inc/TGLViewer.h
+++ b/graf3d/gl/inc/TGLViewer.h
@@ -103,7 +103,7 @@ protected:
    // Mouse ineraction
 public:
    enum EPushAction   { kPushStd,
-                        kPushCamCenter };
+                        kPushCamCenter, kPushAnnotate };
    enum EDragAction   { kDragNone,
                         kDragCameraRotate, kDragCameraTruck, kDragCameraDolly,
                         kDragOverlay };
@@ -166,6 +166,8 @@ public:
    TGLViewer(TVirtualPad* pad);
    virtual ~TGLViewer();
 
+   void ResetInitGL();
+
    // TVirtualViewer3D interface ... mostly a facade
 
    // Forward to TGLScenePad
@@ -219,6 +221,7 @@ public:
    void SetDrawCameraCenter(Bool_t x);
    Bool_t GetDrawCameraCenter() { return fDrawCameraCenter; }
    void   PickCameraCenter()    { fPushAction = kPushCamCenter; RefreshPadEditor(this); }
+   void   PickAnnotate()        { fPushAction = kPushAnnotate;  RefreshPadEditor(this); }
    TGLCameraOverlay* GetCameraOverlay() const { return fCameraOverlay; }
    void SetCameraOverlay(TGLCameraOverlay* m) { fCameraOverlay = m; }
 
@@ -285,6 +288,8 @@ public:
    TGEventHandler *GetEventHandler() const { return fEventHandler; }
    virtual void    SetEventHandler(TGEventHandler *handler);
 
+   virtual void RemoveOverlayElement(TGLOverlayElement* el);
+
    TGLSelectRecord&    GetSelRec()    { return fSelRec; }
    TGLOvlSelectRecord& GetOvlSelRec() { return fOvlSelRec; }
    TGLOverlayElement*  GetCurrentOvlElm() const { return fCurrentOvlElm; }
diff --git a/graf3d/gl/inc/TGLViewerBase.h b/graf3d/gl/inc/TGLViewerBase.h
index c98936d..00077ac 100644
--- a/graf3d/gl/inc/TGLViewerBase.h
+++ b/graf3d/gl/inc/TGLViewerBase.h
@@ -39,12 +39,13 @@ private:
 
 protected:
    typedef std::list<TGLSceneInfo*>             SceneInfoList_t;
-   typedef std::list<TGLSceneInfo*>::iterator   SceneInfoList_i;
+   typedef SceneInfoList_t::iterator            SceneInfoList_i;
 
    typedef std::vector<TGLSceneInfo*>           SceneInfoVec_t;
-   typedef std::vector<TGLSceneInfo*>::iterator SceneInfoVec_i;
+   typedef SceneInfoVec_t::iterator             SceneInfoVec_i;
 
    typedef std::vector<TGLOverlayElement*>      OverlayElmVec_t;
+   typedef OverlayElmVec_t::iterator            OverlayElmVec_i;
 
    SceneInfoList_i FindScene(TGLSceneBase* scene);
 
@@ -87,8 +88,9 @@ public:
 
    TGLSceneInfo* GetSceneInfo(TGLSceneBase* scene);
 
-   void AddOverlayElement(TGLOverlayElement* el);
-   void RemoveOverlayElement(TGLOverlayElement* el);
+   virtual void AddOverlayElement(TGLOverlayElement* el);
+   virtual void RemoveOverlayElement(TGLOverlayElement* el);
+   virtual void DeleteOverlayAnnotations();
 
    TGLClip* Clip()         const { return fClip; }
    void     SetClip(TGLClip *p)  { fClip = p;    }
diff --git a/graf3d/gl/inc/TGLViewerEditor.h b/graf3d/gl/inc/TGLViewerEditor.h
index d982756..a88986e 100644
--- a/graf3d/gl/inc/TGLViewerEditor.h
+++ b/graf3d/gl/inc/TGLViewerEditor.h
@@ -52,6 +52,8 @@ private:
    TGNumberEntry    *fCameraCenterY;
    TGNumberEntry    *fCameraCenterZ;
 
+   TGCheckButton*    fCaptureAnnotate;
+
    Int_t             fAxesType;
    TGButtonGroup    *fAxesContainer;
    TGRadioButton    *fAxesNone;
@@ -105,6 +107,7 @@ public:
    void UpdateMaxDrawTimes();
    void DoCameraCenterExt();
    void DoCaptureCenter();
+   void DoAnnotation();
    void DoDrawCameraCenter();
    void UpdateCameraCenter();
    //Axis manipulation
diff --git a/graf3d/gl/inc/TH2GL.h b/graf3d/gl/inc/TH2GL.h
index 83af6d7..b5e6fd1 100644
--- a/graf3d/gl/inc/TH2GL.h
+++ b/graf3d/gl/inc/TH2GL.h
@@ -15,7 +15,7 @@
 #include <TGLObject.h>
 
 class TGLRnrCtx;
-class TH2;
+class TH1;
 
 #include "TGLPlotPainter.h"
 
@@ -26,7 +26,7 @@ private:
    TH2GL& operator=(const TH2GL&); // Not implemented
 
 protected:
-   TH2                *fM; // fModel dynamic-casted to TH2
+   TH1                *fM; // fModel dynamic-casted to TH2
 
    TGLPlotPainter     *fPlotPainter;
    TGLPlotCoordinates  fCoord;
diff --git a/graf3d/gl/src/TF2GL.cxx b/graf3d/gl/src/TF2GL.cxx
index 705bf8a..6305f75 100644
--- a/graf3d/gl/src/TF2GL.cxx
+++ b/graf3d/gl/src/TF2GL.cxx
@@ -98,8 +98,12 @@ void TF2GL::DirectDraw(TGLRnrCtx & /*rnrCtx*/) const
    // Render the object.
 
    fPlotPainter->RefBackBox().FindFrontPoint();
+
    glPushAttrib(GL_ENABLE_BIT | GL_LIGHTING_BIT);
+
    glEnable(GL_NORMALIZE);
+   glDisable(GL_COLOR_MATERIAL);
+
    fPlotPainter->InitGL();
    fPlotPainter->DrawPlot();
 
diff --git a/graf3d/gl/src/TGLAnnotation.cxx b/graf3d/gl/src/TGLAnnotation.cxx
new file mode 100644
index 0000000..2ed9b18
--- /dev/null
+++ b/graf3d/gl/src/TGLAnnotation.cxx
@@ -0,0 +1,442 @@
+// @(#)root/gl:$Id: root-5.22-00d-fireworks-graf3d-gui.patch,v 1.5 2010/10/09 09:42:53 eulisse Exp $
+// Author:  Matevz and Alja Tadel  20/02/2009
+
+/*************************************************************************
+ * Copyright (C) 1995-2004, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#include "TGLAnnotation.h"
+
+#include "TGLIncludes.h"
+#include "TColor.h"
+#include "TGLUtil.h"
+#include "TGLCamera.h"
+#include "TGLRnrCtx.h"
+#include "TGLSelectRecord.h"
+#include "TGLViewerBase.h"
+#include "TObjString.h"
+#include "TGFrame.h"
+#include "TGTextEdit.h"
+#include "TGButton.h"
+#include "TGLViewer.h"
+
+#include <KeySymbols.h>
+
+//______________________________________________________________________________
+//
+//
+// GL-overaly annotation.
+//
+//
+
+ClassImp(TGLAnnotation);
+
+//______________________________________________________________________________
+TGLAnnotation::TGLAnnotation(TGLViewerBase *parent, const char *text, Float_t posx, Float_t posy, TGLVector3 ref) :
+   TGLOverlayElement(),
+   fMainFrame(0), fTextEdit(0),
+   fParent(0),
+   fText(text),
+   fLabelFontSize(0.02),
+   fBackColor(0x4872fa),
+   fBackHighColor(0x488ffa),
+   fTextColor(0xfbbf84),
+   fTextHighColor(0xf1da44),
+   fAlpha(0.6),
+   fPosX(posx), fPosY(posy),
+   fMouseX(0),  fMouseY(0),
+   fInDrag(kFALSE),
+   fActive(kFALSE)
+{
+   // Constructor.
+
+   fPointer = ref;
+   parent->AddOverlayElement(this);
+   fParent = (TGLViewer*)parent;
+}
+
+//______________________________________________________________________________
+TGLAnnotation::~TGLAnnotation()
+{
+   // Destructor.
+
+   fParent->RemoveOverlayElement(this);
+   delete fMainFrame;
+}
+
+//______________________________________________________________________
+Bool_t TGLAnnotation::Handle(TGLRnrCtx&          rnrCtx,
+                             TGLOvlSelectRecord& selRec,
+                             Event_t*            event)
+{
+   // Handle overlay event.
+   // Return TRUE if event was handled.
+
+   if (selRec.GetN() < 2) return kFALSE;
+   Int_t recID = selRec.GetItem(1);
+
+   switch (event->fType)
+   {
+      case kButtonPress:
+      {
+         // Chech selRec ... if pressed in 'X', 'E'
+         if (recID == 2)
+         {
+            delete this;
+         }
+         else if (recID == 3)
+         {
+            MakeEditor();
+         }
+         else
+         {
+            fMouseX = event->fX;
+            fMouseY = event->fY;
+            fInDrag = kTRUE;
+         }
+         return kTRUE;
+      }
+      case kButtonRelease:
+      {
+         fInDrag = kFALSE;
+         return kTRUE;
+      }
+      case kMotionNotify:
+      {
+         if (fInDrag)
+         {
+            const TGLRect& vp = rnrCtx.RefCamera().RefViewport();
+            fPosX += (Float_t)(event->fX - fMouseX) / vp.Width();
+            fPosY -= (Float_t)(event->fY - fMouseY) / vp.Height();
+            fMouseX = event->fX;
+            fMouseY = event->fY;
+         }
+         return kTRUE;
+      }
+      case kGKeyPress:
+      {
+         switch (rnrCtx.GetEventKeySym())
+         {
+            case kKey_E: case kKey_e:
+               MakeEditor();
+               return kTRUE;
+            case kKey_X: case kKey_x:
+               delete this;
+               return kTRUE;
+            default:
+               return kFALSE;
+         }
+      }
+      default:
+      {
+         return kFALSE;
+      }
+   }
+}
+
+//______________________________________________________________________________
+Bool_t TGLAnnotation::MouseEnter(TGLOvlSelectRecord& /*rec*/)
+{
+   // Mouse has entered overlay area.
+
+   fActive = kTRUE;
+   return kTRUE;
+}
+
+//______________________________________________________________________
+void TGLAnnotation::MouseLeave()
+{
+   // Mouse has left overlay area.
+
+   fActive = kFALSE;
+}
+
+/**************************************************************************/
+void TGLAnnotation::Render(TGLRnrCtx& rnrCtx)
+{
+   // Render the annotation.
+
+   glDisable(GL_LIGHTING);
+
+   glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT | GL_POINT_BIT);
+   Float_t r, g, b;
+   // button
+   //
+   {
+      glMatrixMode(GL_PROJECTION);
+      glPushMatrix();
+      glLoadIdentity();
+      if (rnrCtx.Selection())
+      {
+         TGLRect rect(*rnrCtx.GetPickRectangle());
+         rnrCtx.GetCamera()->WindowToViewport(rect);
+         gluPickMatrix(rect.X(), rect.Y(), rect.Width(), rect.Height(),
+                       (Int_t*) rnrCtx.GetCamera()->RefViewport().CArr());
+      }
+      const TGLRect& vp = rnrCtx.RefCamera().RefViewport();
+      glOrtho(vp.X(), vp.Width(), vp.Y(), vp.Height(), 0, 1);
+      glMatrixMode(GL_MODELVIEW);
+      glPushMatrix();
+      glLoadIdentity();
+
+      TGLCapabilitySwitch lights_off(GL_LIGHTING, kFALSE);
+      glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
+      glDisable(GL_CULL_FACE);
+      glEnable(GL_BLEND);
+      glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+      glShadeModel(GL_FLAT);
+      glClearColor(0.0, 0.0, 0.0, 0.0);
+
+      Float_t posX = vp.Width()  * fPosX;
+      Float_t posY = vp.Height() * fPosY;
+
+      // Text rendering
+      Float_t cfs = fLabelFontSize*vp.Width();
+      Int_t fs = TGLFontManager::GetFontSize(cfs);
+      if (fLabelFont.GetMode() == TGLFont::kUndef)
+      {
+         rnrCtx.RegisterFont(fs, "arial",  TGLFont::kPixmap, fLabelFont);
+      }
+      else if (fLabelFont.GetSize() != fs)
+      {
+         rnrCtx.ReleaseFont(fLabelFont);
+         rnrCtx.RegisterFont(fs, "arial",  TGLFont::kPixmap, fLabelFont);
+      }
+
+      // move to picked location
+      glTranslatef(posX, posY, -0.99);
+
+      glEnable(GL_POLYGON_OFFSET_FILL);
+      glPolygonOffset(1, 1);
+
+      glLineWidth(1);
+
+      // get size of bg area
+      Float_t ascent, descent, line_height;
+      fLabelFont.MeasureBaseLineParams(ascent, descent, line_height);
+
+      Float_t llx, lly, llz, urx, ury, urz;
+
+      TObjArray* lines = fText.Tokenize("\n");
+      Float_t width  = 0;
+      Float_t height = 0;
+      TIter  lit(lines);
+      TObjString* osl;
+      while ((osl = (TObjString*) lit()) != 0)
+      {
+         fLabelFont.BBox(osl->GetString().Data(), llx, lly, llz, urx, ury, urz);
+         width = TMath::Max(width, urx);
+         height += line_height + descent;
+      }
+      width  += 2 * descent;
+      height += 2 * descent;
+
+      // polygon background
+      Float_t padT =  2;
+      Int_t   padF = 10;
+      Float_t padM = padF + 2 * padT;
+
+      {
+         glPushName(0);
+
+         TColor::Pixel2RGB(fActive ? fBackHighColor : fBackColor, r, g, b);
+         TGLUtil::Color4f(r, g, b, fAlpha);
+
+         // bg plain
+         glLoadName(1);
+         glBegin(GL_QUADS);
+         glVertex2f(0, 0);
+         glVertex2f(0, height);
+         glVertex2f(width, height);
+         glVertex2f(width, 0);
+         glEnd();
+
+         // outline
+         TColor::Pixel2RGB(fActive?fTextHighColor:fTextColor, r, g, b);
+         TGLUtil::Color4f(r, g, b, fAlpha);
+
+         glBegin(GL_LINE_LOOP);
+         glVertex2f(0, 0);
+         glVertex2f(0, height);
+         glVertex2f(width, height);
+         glVertex2f(width, 0);
+         glEnd();
+
+         // edit area
+         if (fActive)
+         {
+            Float_t y = height;
+            Float_t x = 0;
+            TColor::Pixel2RGB(fBackHighColor, r, g, b);
+            TGLUtil::Color4f(r, g, b, fAlpha);
+
+            // edit button
+            glLoadName(2);
+            glBegin(GL_QUADS);
+            glVertex2f(x + padM, y);
+            glVertex2f(x,        y);
+            glVertex2f(x,        y + padM);
+            glVertex2f(x + padM, y + padM);
+            glEnd();
+            // close button
+            glLoadName(3);
+            x = padM;
+            TColor::Pixel2RGB(fBackHighColor, r, g, b);
+            TGLUtil::Color4f(r, g, b, fAlpha);
+            glBegin(GL_QUADS);
+            glVertex2f(x + padM, y);
+            glVertex2f(x,        y);
+            glVertex2f(x,        y + padM);
+            glVertex2f(x + padM, y + padM);
+            glEnd();
+
+            // outlines
+            TColor::Pixel2RGB(fTextHighColor, r, g, b);
+            TGLUtil::Color4f(r, g, b, fAlpha);
+            // left
+            x = 0;
+            glBegin(GL_LINE_LOOP);
+            glVertex2f(x + padM, y);
+            glVertex2f(x,        y);
+            glVertex2f(x,        y + padM);
+            glVertex2f(x + padM, y + padM);
+            glEnd();
+            // right
+            x = padM;
+            glBegin(GL_LINE_LOOP);
+            glVertex2f(x + padM, y);
+            glVertex2f(x,        y);
+            glVertex2f(x,        y + padM);
+            glVertex2f(x + padM, y + padM);
+            glEnd();
+         }
+         glPopName();
+      }
+
+      glDisable(GL_POLYGON_OFFSET_FILL);
+
+      // labels
+      fLabelFont.PreRender();
+      TColor::Pixel2RGB(fActive?fTextHighColor:fTextColor, r, g, b);
+      TGLUtil::Color3f(r, g, b);
+      TIter  next_base(lines);
+      TObjString* os;
+      glPushMatrix();
+      glTranslatef(descent, height, 0);
+      while ((os = (TObjString*) next_base()) != 0)
+      {
+         glTranslatef(0, -(line_height + descent), 0);
+         fLabelFont.BBox(os->GetString().Data(), llx, lly, llz, urx, ury, urz);
+         glRasterPos2i(0, 0);
+         glBitmap(0, 0, 0, 0, 0, 0, 0);
+         fLabelFont.Render(os->GetString().Data());
+      }
+      glPopMatrix();
+      fLabelFont.PostRender();
+
+      // menu
+      if (fMenuFont.GetMode() == TGLFont::kUndef)
+      {
+         rnrCtx.RegisterFont(padF, "arial",  TGLFont::kPixmap, fMenuFont);
+      }
+
+      if (fActive)
+      {
+         TColor::Pixel2RGB(fTextHighColor, r, g, b);
+         TGLUtil::Color3f(r, g, b);
+         Float_t x = padT;
+         Float_t y = height + padT + 0.5*padF;
+         fMenuFont.PreRender();
+         fMenuFont.RenderBitmap("X", x, y, 0, TGLFont::kLeft);
+         x += padM + padT;
+         fMenuFont.RenderBitmap("E", x, y, 0, TGLFont::kLeft);
+         fMenuFont.PostRender();
+      }
+
+      glMatrixMode(GL_PROJECTION);
+      glPopMatrix();
+      glMatrixMode(GL_MODELVIEW);
+      glPopMatrix();
+   }
+
+   // line
+   //
+   glLineWidth(2);
+   TColor::Pixel2RGB(fActive ?fBackHighColor : fBackColor, r, g, b);
+   TGLUtil::Color4f(r, g, b, fAlpha);
+   glBegin(GL_LINES);
+   TGLRect& vp = rnrCtx.RefCamera().RefViewport();
+   TGLVertex3 v = rnrCtx.RefCamera().ViewportToWorld(TGLVertex3(fPosX*vp.Width(), fPosY*vp.Height(), 0));
+
+   glVertex3dv(v.Arr());
+   glVertex3dv(fPointer.Arr());
+   glEnd();
+   glPopAttrib();
+}
+
+//______________________________________________________________________________
+void TGLAnnotation::MakeEditor()
+{
+   // Show the annotation editor.
+
+   if (fMainFrame == 0)
+   {
+      fMainFrame = new TGMainFrame(gClient->GetRoot(), 1000, 1000);
+      fMainFrame->SetWindowName("Annotation Editor");
+
+      TGVerticalFrame* vf = new TGVerticalFrame(fMainFrame);
+
+      fTextEdit = new TGTextEdit(vf,  1000, 1000, kSunkenFrame);
+      vf->AddFrame(fTextEdit,  new TGLayoutHints(kLHintsExpandX|kLHintsExpandY));
+
+      TGHorizontalFrame* hf = new TGHorizontalFrame(vf);
+
+      TGTextButton* btt1 = new TGTextButton(hf, "OK");
+      hf->AddFrame(btt1, new TGLayoutHints(kLHintsExpandX, 2, 2, 2, 2));
+
+      TGTextButton* btt2 = new TGTextButton(hf, "Cancel");
+      hf->AddFrame(btt2, new TGLayoutHints(kLHintsExpandX, 2, 2, 2, 2));
+
+      btt1->Connect("Clicked()", "TGLAnnotation", this, "UpdateText()");
+      btt2->Connect("Clicked()", "TGLAnnotation", this, "CloseEditor()");
+
+      vf->AddFrame(hf, new TGLayoutHints(kLHintsBottom | kLHintsRight | kLHintsExpandX, 2, 2, 5, 1));
+
+      fMainFrame->AddFrame(vf,  new TGLayoutHints(kLHintsExpandX|kLHintsExpandY));
+      fMainFrame->SetCleanup(kDeepCleanup);
+      fMainFrame->MapSubwindows();
+   }
+
+   TGText *tgt = new TGText();
+   tgt->LoadBuffer(fText.Data());
+   fTextEdit->SetText(tgt);
+
+   Int_t nrow = tgt->RowCount();
+   Int_t h = nrow*20;
+   Int_t w = fTextEdit->ReturnLongestLineWidth();
+   fMainFrame->Resize(TMath::Max(100, w+30), TMath::Max(100, h+40));
+
+   fMainFrame->Layout();
+   fMainFrame->MapWindow();
+}
+
+//______________________________________________________________________________
+void TGLAnnotation::CloseEditor()
+{
+   // Close the annotation editor.
+
+   fMainFrame->UnmapWindow();
+}
+
+//______________________________________________________________________________
+void TGLAnnotation::UpdateText()
+{
+   // Modify the annotation text from the text-edit widget.
+
+   fText = fTextEdit->GetText()->AsString();
+   fParent->RequestDraw();
+}
diff --git a/graf3d/gl/src/TGLAxisPainter.cxx b/graf3d/gl/src/TGLAxisPainter.cxx
index 589eb15..683ce0e 100644
--- a/graf3d/gl/src/TGLAxisPainter.cxx
+++ b/graf3d/gl/src/TGLAxisPainter.cxx
@@ -16,66 +16,43 @@
 #include "TGLIncludes.h"
 #include "TGLRnrCtx.h"
 #include "TGLFontManager.h"
+
+#include "TAttAxis.h"
 #include "TAxis.h"
 #include "THLimitsFinder.h"
 
 #include "TMath.h"
-
+#include "TPRegexp.h"
 
 //______________________________________________________________________________
-// Axis attributes required to be drawn in GL.
 //
+// Utility class to paint axis in GL.
 
-ClassImp(TGLAxisAttrib);
+
+ClassImp(TGLAxisPainter);
 
 //______________________________________________________________________________
-TGLAxisAttrib::TGLAxisAttrib() :
-   TAttAxis(),
+TGLAxisPainter::TGLAxisPainter():
+   fExp(0),
+   fMaxDigits(5),
+   fDecimals(0),
 
-   fDir(1, 0, 0),
-   fMin(0),
-   fMax(100),
+   fAttAxis(0),
 
+   fFontMode(TGLFont::kTexture),
+   fDir(1, 0, 0),
    fTMNDim(1),
-
-   fTextAlign(TGLFont::kCenterDown),
-
-   fRelativeFontSize(kFALSE),
-   fAbsLabelFontSize(24),
-   fAbsTitleFontSize(24),
-
-   fLabelFontName("arial"),
-   fTitleFontName("arial")
+   fLabelPixelFontSize(14),
+   fTitlePixelFontSize(14)
 {
    // Constructor.
-
-   fNdivisions = 510;
-   fLabelSize = 0.04;
-
-   fLabelColor = kWhite;
-   fTitleColor = kWhite;
-
-   fTMScale[0] = 1;
-   fTMScale[1] = 0.5;
-   fTMScale[2] = 0.25;
 }
 
-//______________________________________________________________________________
-//
-// Utility class to paint axis in GL.
-
-
-ClassImp(TGLAxisPainter);
 
 //______________________________________________________________________________
-TGLAxisPainter::TGLAxisPainter():
-   fAtt(0),
-
-   fMaxDigits(5),
-   fDecimals(0),
-   fExp(0)
+TGLAxisPainter::~TGLAxisPainter()
 {
-   // Constructor.
+   // Destructor.
 
 }
 
@@ -84,340 +61,411 @@ void TGLAxisPainter::LabelsLimits(const char *label, Int_t &first, Int_t &last)
 {
    // Find first and last character of a label.
 
-   last = strlen(label)-1;
-   for (Int_t i=0; i<=last; i++) {
-      if (strchr("1234567890-+.", label[i]) ) { first = i; return; }
+   last = strlen(label) - 1;
+   for (Int_t i = 0; i <= last; i++) {
+      if (strchr("1234567890-+.", label[i])) {
+         first = i;
+         return;
+      }
    }
    Error("LabelsLimits", "attempt to draw a blank label");
 }
 
 //______________________________________________________________________________
-inline void TGLAxisPainter::DrawTick(TGLVector3 &tv, Int_t order) const
-{
-   // Draw tick-marks in supprted dimensions.
-
-   for (Int_t dim=0; dim < fAtt->fTMNDim; dim++)
-   {
-      glVertex3dv(tv.Arr());
-      glVertex3dv((tv+fAtt->fTMOff[dim]*fAtt->fTMScale[order]).Arr());
-   }
-}
-
-//______________________________________________________________________________
-void TGLAxisPainter::FormAxisValue(Float_t wlabel, char* label) const
+void TGLAxisPainter::FormAxisValue(Double_t  val, TString &s) const
 {
    // Returns formatted text suitable for display of value.
 
-   sprintf(label,&fFormat[0],wlabel);
-   Int_t first, last;
-   LabelsLimits(label, first, last);
+   static char label[256];
 
-   char chtemp[256];
-   if (label[first] == '.') { //check if '.' is preceeded by a digit
-      strcpy(chtemp, "0");
-      strcat(chtemp, &label[first]);
-      strcpy(label, chtemp);
-      first = 1; last = strlen(label);
-   }
-   if (label[first] == '-' && label[first+1] == '.') {
-      strcpy(chtemp, "-0");
-      strcat(chtemp, &label[first+1]);
-      strcpy(label, chtemp);
-      first = 1; last = strlen(label);
-   }
+   sprintf(label, &fFormat[0], val);
+   s =  label;
 
-   //  We eliminate the non significant 0 after '.'
-   if (fDecimals) {
-      char *adot = strchr(label,'.');
-      if (adot) adot[fDecimals] = 0;
-   } else {
-      while (label[last] == '0') { label[last] = 0; last--;}
-   }
-   // We eliminate the dot, unless dot is forced.
-   if (label[last] == '.') {
-      label[last] = 0; last--;
+   if (s == "-." || s == "-0")
+   {
+      s  = "0";
+      return;
    }
 
-   //  Make sure the label is not "-0"
-   if (last-first == 1 && label[first] == '-' && label[last]  == '0') {
-      strcpy(label, "0");
-      label[last] = 0;
-   }
+   if (s.EndsWith("."))
+      s += '0';
+
+   Ssiz_t ld = s.Last('.');
+   if (s.Length() - ld > fDecimals)
+      s.Remove(ld + fDecimals);
+
+   TPMERegexp zeroes("[-+]?0\\.0*$");
+   zeroes.Substitute(s, "0");   
 }
 
 //______________________________________________________________________________
-void TGLAxisPainter::SetTextFormat(Double_t bw1)
+void TGLAxisPainter::SetTextFormat(Double_t min, Double_t max, Double_t bw1)
 {
    // Construct print format from given primary bin width.
 
-   Double_t absMax = TMath::Max(TMath::Abs(fAtt->fMin),TMath::Abs(fAtt->fMax));
+   Double_t absMax = TMath::Max(TMath::Abs(min), TMath::Abs(max));
    Double_t epsilon = 1e-5;
    Double_t absMaxLog = TMath::Log10(absMax) + epsilon;
 
    fExp   = 0;
    Int_t if1, if2;
-   Double_t xmicros = TMath::Power(10,-fMaxDigits);
-   if ( bw1 < xmicros && absMaxLog<0)
-   {
+   Double_t xmicros = TMath::Power(10, -fMaxDigits);
+   if (bw1 < xmicros && absMaxLog < 0) {
       // First case : bin width less than 0.001
       fExp = (Int_t)absMaxLog;
-      if (fExp%3 == 1) fExp += TMath::Sign(2, fExp);
-      if (fExp%3 == 2) fExp += TMath::Sign(1, fExp);
+      if (fExp % 3 == 1) fExp += TMath::Sign(2, fExp);
+      if (fExp % 3 == 2) fExp += TMath::Sign(1, fExp);
       if1     = fMaxDigits;
-      if2     = fMaxDigits-2;
-   }
-   else
-   {
+      if2     = fMaxDigits - 2;
+   } else {
       // Use x 10 n format. (only powers of 3 allowed)
-      Float_t af = (absMax > 1) ? absMaxLog : TMath::Log10(absMax*0.0001);
+      Float_t af = (absMax > 1) ? absMaxLog : TMath::Log10(absMax * 0.0001);
       af += epsilon;
-      Int_t clog = Int_t(af)+1;
+      Int_t clog = Int_t(af) + 1;
 
       if (clog > fMaxDigits) {
          while (1) {
             fExp++;
             absMax    /= 10;
-            if (fExp%3 == 0 && absMax <= TMath::Power(10,fMaxDigits-1)) break;
+            if (fExp % 3 == 0 && absMax <= TMath::Power(10, fMaxDigits - 1)) break;
          }
-      }
-      else if (clog < -fMaxDigits) {
-         Double_t rne   = 1/TMath::Power(10,fMaxDigits-2);
+      } else if (clog < -fMaxDigits) {
+         Double_t rne   = 1 / TMath::Power(10, fMaxDigits - 2);
          while (1) {
             fExp--;
             absMax  *= 10;
-            if (fExp%3 == 0 && absMax >= rne) break;
+            if (fExp % 3 == 0 && absMax >= rne) break;
          }
       }
 
       Int_t na = 0;
-      for (Int_t i=fMaxDigits-1; i>0; i--) {
-         if (TMath::Abs(absMax) < TMath::Power(10,i)) na = fMaxDigits-i;
+      for (Int_t i = fMaxDigits - 1; i > 0; i--) {
+         if (TMath::Abs(absMax) < TMath::Power(10, i)) na = fMaxDigits - i;
       }
-      Double_t size =  TMath::Abs(fAtt->fMax - fAtt->fMin);
-      Int_t ndyn = (Int_t)(size/bw1);
+      Double_t size =  TMath::Abs(max - min);
+      Int_t ndyn = (Int_t)(size / bw1);
       while (ndyn) {
-         if ( size/ndyn <= 0.999 && na < fMaxDigits-2) {
+         if (size / ndyn <= 0.999 && na < fMaxDigits - 2) {
             na++;
             ndyn /= 10;
-         }
-         else break;
+         } else break;
       }
       if2 = na;
-      if1 = TMath::Max(clog+na,fMaxDigits)+1;
+      if1 = TMath::Max(clog + na, fMaxDigits) + 1;
    }
 
    // compose text format
-   if (TMath::Min(fAtt->fMin,fAtt->fMax) < 0)if1 = if1+1;
-   if1 = TMath::Min(if1,32);
+   if (TMath::Min(min, max) < 0)if1 = if1 + 1;
+   if1 = TMath::Min(if1, 32);
 
    // In some cases, if1 and if2 are too small....
-   Double_t dwlabel = bw1*TMath::Power(10, -fExp);
-   while (dwlabel < TMath::Power(10,-if2)) {
+   Double_t dwlabel = bw1 * TMath::Power(10, -fExp);
+   while (dwlabel < TMath::Power(10, -if2)) {
       if1++;
       if2++;
    }
-   if (if1 > 14) if1=14;
-   if (if2 > 14) if2=14;
-   if (if2) sprintf(fFormat,"%%%d.%df",if1,if2);
-   else     sprintf(fFormat,"%%%d.%df",if1+1,1);
+   if (if1 > 14) if1 = 14;
+   if (if2 > 14) if2 = 14;
+   if (if2) sprintf(fFormat, "%%%d.%df", if1, if2);
+   else     sprintf(fFormat, "%%%d.%df", if1 + 1, 1);
 
    // get decimal number
    char chtemp[8];
-   sprintf(chtemp,"%g",dwlabel);
+   sprintf(chtemp, "%g", dwlabel);
    fDecimals = 0;
-   char *dot = strchr(chtemp,'.');
-   if (dot) fDecimals = chtemp + strlen(chtemp) -dot;
+   char *dot = strchr(chtemp, '.');
+   if (dot) fDecimals = chtemp + strlen(chtemp) - dot;
 }
 
+/**************************************************************************/
+/**************************************************************************/
+/**************************************************************************/
+/**************************************************************************/
+
+//
+// Utility functions.
+
+
 
 //______________________________________________________________________________
-void TGLAxisPainter::RnrText(const char* txt, TGLVector3 pos, TGLFont &font) const
+void TGLAxisPainter::RnrText( const char* txt, const TGLVector3 &pos, const TGLFont::ETextAlign_e align, const TGLFont &font) const
 {
    // Render text at the given position. Offset depends of text aligment.
 
    glPushMatrix();
-   glTranslatef(pos.X(), pos.Y(), pos.Z());
 
+   glTranslatef(pos.X(), pos.Y(), pos.Z());
    Float_t llx, lly, llz, urx, ury, urz;
    font.BBox(txt, llx, lly, llz, urx, ury, urz);
-   if (txt[0] == '-')
-      urx += (urx-llx)/strlen(txt);
 
    Float_t x=0, y=0;
-
-   switch (fAtt->fTextAlign)
+   switch (align)
    {
-      case TGLFont::kCenterDown:
+      case TGLFont::kCenterUp:
+         if (txt[0] == '-')
+            urx += (urx-llx)/strlen(txt);
          x = -urx*0.5; y = -ury;
          break;
-      case TGLFont::kCenterUp:
-         x = -urx; y = 0;
+      case TGLFont::kCenterDown:
+         if (txt[0] == '-')
+            urx += (urx-llx)/strlen(txt);
+         x = -urx*0.5; y = 0;
          break;
-      case TGLFont::kLeft:
+      case TGLFont::kRight:
          x = -urx; y =(lly -ury)*0.5;
          break;
-      case TGLFont::kRight:
+      case TGLFont::kLeft:
          x = 0; y = -ury*0.5;
          break;
       default:
          break;
    };
 
-   glRasterPos2i(0, 0);
-   glBitmap(0, 0, 0, 0, x, y, 0);
-   font.Render(txt);
 
+   if (fFontMode == TGLFont::kPixmap || fFontMode ==  TGLFont::kBitmap)
+   {
+      glRasterPos2i(0, 0);
+      glBitmap(0, 0, 0, 0, x, y, 0);
+   }
+   else
+   {
+      Double_t sc = fLabel3DFontSize/fLabelPixelFontSize;
+      glScaled(sc, sc, 1);
+      glTranslatef(x, y, 0);
+   }
+
+   font.Render(txt);
    glPopMatrix();
 }
 
 //______________________________________________________________________________
-void TGLAxisPainter::Paint(TGLRnrCtx &rnrCtx, TGLAxisAttrib &att)
+void TGLAxisPainter::SetLabelFont(TGLRnrCtx &rnrCtx, const char* fontName, Int_t fontSize, Double_t size3d)
 {
-   // Paint axis body, tickmarks and labels.
+   // Set label font derived from TAttAxis.
 
-   if (rnrCtx.Selection() || rnrCtx.Highlight())
-      return;
+   fLabelPixelFontSize = TGLFontManager::GetFontSize(fontSize, 10, 128);
+   fLabel3DFontSize = size3d;
 
-   fAtt = &att;
+   if (fLabelFont.GetMode() == TGLFont::kUndef)
+   {
+      rnrCtx.RegisterFont(fontSize, fontName, fFontMode, fLabelFont);
+   }
+   else if (fLabelFont.GetSize() != fontSize|| fLabelFont.GetFile() != fAttAxis->GetLabelFont() || fLabelFont.GetMode() != fFontMode )
+   {
+      rnrCtx.ReleaseFont(fLabelFont);
+      rnrCtx.RegisterFont(fLabelPixelFontSize, fontName, fFontMode, fLabelFont);
+   }
+}
 
-   TGLVector3 start = att.fDir*att.fMin;
-   TGLVector3 end = att.fDir*att.fMax;
+//______________________________________________________________________________
+void TGLAxisPainter::RnrLabels() const
+{
+   // Render label reading prepared list ov value-pos pairs.
 
-   // optimise
-   Int_t n1a = TMath::FloorNint(att.fNdivisions/100);
-   Int_t n2a = att.fNdivisions-n1a*100;
-   Int_t bn1, bn2;
-   Double_t bw1, bw2; // bin with
-   Double_t bl1, bh1, bl2, bh2; // bin low, high
+   TGLUtil::Color(fAttAxis->GetLabelColor());
 
-   THLimitsFinder::Optimize(att.fMin, att.fMax, n1a, bl1, bh1, bn1, bw1);
-   THLimitsFinder::Optimize(bl1, bl1+bw1, n2a, bl2, bh2, bn2, bw2);
+   glPushMatrix();
 
-   //______________________________________________________________________________
+   Float_t off = fAttAxis->GetLabelOffset() +  fAttAxis->GetTickLength();
+   TGLVector3 offVec = fTMOff[0] * off;
+   glTranslated(offVec.X(), offVec.Y(), offVec.Z());
+
+   fLabelFont.PreRender();
+   Double_t p = 0.;
+   TString s;
+   for (LabVec_t::const_iterator it = fLabVec.begin(); it != fLabVec.end(); ++it) {
+      FormAxisValue((*it).second, s);
+      p = (*it).first;
+      RnrText(s.Data(), fDir*p, fLabelAlign, fLabelFont);
+   }
+
+   fLabelFont.PostRender();
+   glPopMatrix();
+}
+
+//______________________________________________________________________________
+void TGLAxisPainter::SetTitleFont(TGLRnrCtx &rnrCtx, const char* fontName, Int_t fontSize, Double_t size3d)
+{
+   // Set title font derived from TAttAxis.
+
+   fTitlePixelFontSize = TGLFontManager::GetFontSize(fontSize, 10, 128);
+   fTitle3DFontSize = size3d;
 
-   TGLFont font;
-   Double_t len=0;
-   if (att.fRelativeFontSize)
+   if (fTitleFont.GetMode() == TGLFont::kUndef)
    {
-      GLdouble mm[16];
-      GLdouble pm[16];
-      GLint    vp[4];
-      glGetDoublev(GL_MODELVIEW_MATRIX,  mm);
-      glGetDoublev(GL_PROJECTION_MATRIX, pm);
-      glGetIntegerv(GL_VIEWPORT, vp);
+      rnrCtx.RegisterFont(fontSize, fontName, fFontMode, fTitleFont);
+   }
+   else if (fTitleFont.GetSize() != fontSize|| fTitleFont.GetFile() != fAttAxis->GetTitleFont() || fTitleFont.GetMode() != fFontMode )
+   {
+      rnrCtx.ReleaseFont(fTitleFont);
+      rnrCtx.RegisterFont(fTitlePixelFontSize, fontName, fFontMode, fTitleFont);
+   }
+}
 
-      GLdouble dn[3];
-      GLdouble up[3];
-      gluProject(start.X(), start.Y(), start.Z(), mm, pm, vp, &dn[0], &dn[1], &dn[2]);
-      gluProject(end.X(), end.Y(), end.Z(), mm, pm, vp, &up[0], &up[1], &up[2]);
-      len = TMath::Sqrt((  up[0]-dn[0])*(up[0]-dn[0])
-                        + (up[1]-dn[1])*(up[1]-dn[1])
-                        + (up[2]-dn[2])*(up[2]-dn[2]));
+//______________________________________________________________________________
+void TGLAxisPainter::RnrTitle(const char* txt, TGLVector3 &pos , TGLFont::ETextAlign_e align) const
+{
+   // Draw title at given position.
+
+   TGLUtil::Color(fAttAxis->GetTitleColor());
+   const char* title = (fExp) ? Form("%s [10^%d]", fExp, txt) : txt;
+   fTitleFont.PreRender();
+   RnrText(title, pos, align, fTitleFont);
+   fTitleFont.PostRender();
+}
+
+//______________________________________________________________________________
+void TGLAxisPainter::RnrLines() const
+{
+   // Render axis main line and tickmarks.
+
+   TGLUtil::Color(fAttAxis->GetAxisColor());
+   glBegin(GL_LINES);
+
+   // Main line.
+   //
+   Float_t min = fTMVec.front().first;
+   Float_t max = fTMVec.back().first;
+   TGLVector3 start = fDir * min;
+   TGLVector3 end   = fDir * max;
+   glVertex3dv(start.Arr());
+   glVertex3dv(end.Arr());
+
+   // Tick-marks.
+   // Support three possible directions and two orders.
+   //
+   Float_t tmsOrderFirst  = fAttAxis->GetTickLength();
+   Float_t tmsOrderSecond = tmsOrderFirst * 0.5;
+   TGLVector3 pos;
+   TMVec_t::const_iterator it = fTMVec.begin();
+   Int_t nt =  fTMVec.size()-1;
+   it++;
+   for (Int_t t = 1; t < nt; ++t, ++it) {
+      pos = fDir * ((*it).first);
+      for (Int_t dim = 0; dim < fTMNDim; dim++) {
+         glVertex3dv(pos.Arr());
+         if ((*it).second)
+            glVertex3dv((pos + fTMOff[dim]*tmsOrderSecond).Arr());
+         else
+            glVertex3dv((pos + fTMOff[dim]*tmsOrderFirst).Arr());
+      }
    }
+   glEnd();
+}
 
-   // labels
+//______________________________________________________________________________
+void TGLAxisPainter::PaintAxis(TGLRnrCtx &rnrCtx, TAxis* ax)
+{
+   // GL render TAxis.
+
+   fAttAxis = ax;
+   Double_t min = ax->GetXmin();
+   Double_t max = ax->GetXmax();
+   if (min == max)
    {
-      Int_t fs = att.fRelativeFontSize ? Int_t(att.GetLabelSize()*len):att.fAbsLabelFontSize;
-      att.fAbsLabelFontSize = TGLFontManager::GetFontSize(fs, 8, 36);
-      rnrCtx.RegisterFont(att.fAbsLabelFontSize, att.fLabelFontName.Data(), TGLFont::kPixmap, font);
-
-      TGLUtil::Color(att.fLabelColor);
-      glPushMatrix();
-      TGLVector3 off = (att.fTMOff[0])*2.5; // tmp
-      glTranslated (off.X(), off.Y(), off.Z());
-
-      font.PreRender();
-      TGLVector3 pos  = att.fDir*bl1;
-      TGLVector3 step = att.fDir*bw1;
-      SetTextFormat(bw1);
-      Double_t lab0 = bl1*TMath::Power(10, -fExp);
-      Double_t labStep = bw1*TMath::Power(10, -fExp);
-      char chtemp[10];
-      for (Int_t i=0; i<=bn1; i++)
-      {
-         FormAxisValue(lab0+i*labStep, &chtemp[0]);
-         font.RenderBitmap(chtemp, pos.X(), pos.Y(), pos.Z(), att.fTextAlign);
-         pos += step;
-      }
-      font.PostRender();
-      glPopMatrix();
-      rnrCtx.ReleaseFont(font);
+      Error("TGLAxisPainter::PaintAxis", "axis without range");
+      return;
    }
 
-   // title
-   if (att.fTitle.Length())
+   //______________________________________________________________________________
+   // Fill lablels value-pos and tick-marks position-length.
+
+   Int_t n1a = TMath::FloorNint(fAttAxis->GetNdivisions() / 100);
+   Int_t n2a = fAttAxis->GetNdivisions() - n1a * 100;
+   Int_t bn1, bn2;
+   Double_t bw1, bw2; // primary , secondary bin width
+   Double_t bl1, bh1, bl2, bh2; // bin low, high values
+
+   // Read limits from users range
+   THLimitsFinder::Optimize(min, max, n1a, bl1, bh1, bn1, bw1);
+   THLimitsFinder::Optimize(bl1, bl1 + bw1, n2a, bl2, bh2, bn2, bw2);
+
+   //______________________________________________________________________________
+
+   // Get TM. First and last values are reserved for axis range
+   //
+   fTMVec.clear();
+   fLabVec.clear();
+
+   fTMVec.push_back(TM_t(min, -1));
+
+   Double_t v1 = bl1;
+   Double_t v2 = 0;
+   for (Int_t t1 = 0; t1 <= bn1; t1++)
    {
-      Int_t fs = (att.fRelativeFontSize)? Int_t(att.GetTitleSize()*len) : att.fAbsTitleFontSize;
-      att.fAbsTitleFontSize = TGLFontManager::GetFontSize(fs, 12, 36);
-
-      rnrCtx.RegisterFont(TGLFontManager::GetFontSize(fs, 12, 36),
-                          att.fTitleFontName.Data(), TGLFont::kPixmap, font);
-      TGLUtil::Color(att.fTitleColor);
-      font.PreRender();
-      TGLVector3 pos = att.fTitlePos;
-      pos  += att.fTMOff[0]*2.5; //tmp
-
-      TString title = att.fTitle;
-      if (att.fTitleUnits.Length())
+      fTMVec.push_back(TM_t(v1, 0));
+      fLabVec.push_back(Lab_t(v1, v1));
+      v2 = v1 + bw2;
+      for (Int_t t2 = 1; t2 < bn2; t2++)
       {
-         if (fExp)
-            title += Form("[10^%d %s]", fExp, att.fTitleUnits.Data());
-         else
-            title += Form("[%s]", att.fTitleUnits.Data());
+         if (v2 > max) break;
+         fTMVec.push_back(TM_t(v2, 1));
+         v2 += bw2;
       }
-      RnrText(title.Data(), pos, font);
+      v1 += bw1;
+   }
+
+   // complete low edges for 1.st order TM
+   v2 = bl1 -bw2;
+   while (v2 > min) {
+      fTMVec.push_back(TM_t(v2, 1));
+      v2 -= bw2;
+   }
 
-      font.PostRender();
-      rnrCtx.ReleaseFont(font);
+   fTMVec.push_back(TM_t(max, -1));
+
+   //______________________________________________________________________________
+   // Get labels. In this case trivial one-one mapping.
+
+   Double_t p = bl1;
+   fLabVec.clear();
+   SetTextFormat(min, max, bw1);
+   for (Int_t i = 0; i <= bn1; i++) {
+      fLabVec.push_back(Lab_t(p, p));
+      p += bw1;
    }
 
    //______________________________________________________________________________
+   // Set font.
 
-   TGLUtil::Color(att.fAxisColor);
-   glBegin(GL_LINES);
-   // body
+   // First projected axis length needed if use realtive font size.
+   const char* labFontName = TGLFontManager::GetFontNameFromId(fAttAxis->GetLabelFont());
+   const char* titleFontName = TGLFontManager::GetFontNameFromId(fAttAxis->GetTitleFont());
+
+   if (fFontMode == TGLFont::kPolygon || fFontMode == TGLFont::kTexture)
    {
-      glVertex3dv(start.Arr());
-      glVertex3dv(end.Arr());
+      // get sensible pixel resolution relative to projected axis length
+      // in pixmap for this is given explicitly
+      Double_t len = 0;
+      GLdouble mm[16];
+      GLdouble pm[16];
+      GLint    vp[4];
+      glGetDoublev(GL_MODELVIEW_MATRIX,  mm);
+      glGetDoublev(GL_PROJECTION_MATRIX, pm);
+      glGetIntegerv(GL_VIEWPORT, vp);
+
+      GLdouble dn[3];
+      GLdouble up[3];
+      gluProject(fDir.X()*min, fDir.Y()*min, fDir.Z()*min, mm, pm, vp, &dn[0], &dn[1], &dn[2]);
+      gluProject(fDir.X()*max, fDir.Y()*max, fDir.Z()*max, mm, pm, vp, &up[0], &up[1], &up[2]);
+      len = TMath::Sqrt((up[0] - dn[0]) * (up[0] - dn[0])
+                        + (up[1] - dn[1]) * (up[1] - dn[1])
+                        + (up[2] - dn[2]) * (up[2] - dn[2]));
+
+      fLabelPixelFontSize = TMath::CeilNint(len*fAttAxis->GetLabelSize());
+      fTitlePixelFontSize = TMath::CeilNint(len*fAttAxis->GetTitleSize());
    }
 
-   // tick-marks
-   {
-      TGLVector3 tmStep1 = att.fDir*bw1;
-      TGLVector3 tmStep2 = att.fDir*bw2;
-      TGLVector3 tv1 = att.fDir*bl1;
-      TGLVector3 tv2;
-      for (Int_t t1=0; t1<bn1; t1++)
-      {
-         DrawTick(tv1, 0);
-         tv2 = tv1 + att.fDir*(bl2-bl1);
-         for (Int_t t2=0; t2<=bn2; t2++)
-         {
-            DrawTick(tv2, 1);
-            tv2 += tmStep2;
-         }
-         tv1 += tmStep1;
-      }
+   SetLabelFont(rnrCtx, labFontName, fLabelPixelFontSize,   (max -min)*fAttAxis->GetLabelSize());
+   SetTitleFont(rnrCtx, titleFontName, fTitlePixelFontSize, (max -min)*fAttAxis->GetTitleSize());
 
-      // complete last
-      DrawTick(tv1, 0);
+   //______________________________________________________________________________
+   // Draw.
 
-      // complete up edges for first order
-      Int_t nc = Int_t((att.fMax-bh1)/bw2);
-      tv2 = att.fDir*bh1;
-      for(Int_t t2=0; t2<=nc; t2++)
-      {
-         DrawTick(tv2, 1);
-         tv2 += tmStep2;
-      }
-      // complete low edges for first order
-      nc = Int_t((bl1-att.fMin)/bw2);
-      tv2 = att.fDir*bl1;
-      for(Int_t t2=0; t2<=nc; t2++)
-      {
-         DrawTick(tv2, 1);
-         tv2 -= tmStep2;
-      }
-   }
-   glEnd();
+   glDisable(GL_LIGHTING);
+   RnrLines();
+   RnrLabels();
+
+   if (ax->GetTitle())
+      RnrTitle(ax->GetTitle(), fTitlePos, fLabelAlign);
 }
diff --git a/graf3d/gl/src/TGLCamera.cxx b/graf3d/gl/src/TGLCamera.cxx
index 4d1d779..f76ed2b 100644
--- a/graf3d/gl/src/TGLCamera.cxx
+++ b/graf3d/gl/src/TGLCamera.cxx
@@ -842,7 +842,26 @@ Double_t TGLCamera::GetTheta() const
 }
 
 //______________________________________________________________________________
+Bool_t TGLCamera::Truck(Double_t xDelta, Double_t yDelta)
+{
+   // Truck the camera - 'move camera parallel to film plane'.
+   // Returns kTRUE is redraw required (camera change), kFALSE otherwise.
+
+   if (xDelta != 0 || yDelta != 0)
+   {
+      fCamTrans.MoveLF(2, xDelta);
+      fCamTrans.MoveLF(3, yDelta);
+
+      IncTimeStamp();
+      return kTRUE;
+   }
+   else
+   {
+      return kFALSE;
+   }
+}
 
+//______________________________________________________________________________
 Bool_t TGLCamera::Rotate(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2)
 {
    // Rotate the camera round view volume center established in Setup().
diff --git a/graf3d/gl/src/TGLCameraOverlay.cxx b/graf3d/gl/src/TGLCameraOverlay.cxx
index 8079e78..35cb5bd 100644
--- a/graf3d/gl/src/TGLCameraOverlay.cxx
+++ b/graf3d/gl/src/TGLCameraOverlay.cxx
@@ -16,8 +16,10 @@
 #include "TGLSelectRecord.h"
 #include "TGLUtil.h"
 #include "TGLRnrCtx.h"
-#include "TGLFontManager.h"
+#include "TGLAxisPainter.h"
+
 #include "TMath.h"
+#include "TAxis.h"
 
 //______________________________________________________________________________
 // A GL overlay element which displays camera furstum.
@@ -35,25 +37,44 @@ TGLCameraOverlay::TGLCameraOverlay(Bool_t showOrtho, Bool_t showPersp) :
    fOrthographicMode(kAxis),
    fPerspectiveMode(kPlaneIntersect),
 
-   fAxisPainter(),
-   fAxisAtt(),
-   fAxisExtend(0.8),
+   fAxisPainter(0),
+   fAxis(0),
+   fAxisExtend(0.9),
 
    fExternalRefPlane(),
    fUseExternalRefPlane(kFALSE)
 {
    // Constructor.
 
-   fAxisAtt.SetAxisColor(kWhite);
-   fAxisAtt.SetLabelSize(0.02);
-   fAxisAtt.SetNdivisions(810);
+   fAxis = new TAxis();
+   fAxis->SetNdivisions(710);
+   fAxis->SetLabelOffset(0.01);
+   fAxis->SetAxisColor(kGray+1);
+   fAxis->SetLabelColor(kGray+1);
+
+   fAxisPainter = new TGLAxisPainter();
+   fAxisPainter->SetFontMode(TGLFont::kTexture);
 }
 
 //______________________________________________________________________________
-void TGLCameraOverlay::RenderPlaneIntersect(TGLRnrCtx& rnrCtx, const TGLFont &font)
+TGLCameraOverlay::~TGLCameraOverlay()
 {
-   // Print corss section coordinates in top right corner of screen.
+   // Destructor.
 
+   delete  fAxisPainter;
+   delete  fAxis;
+}
+
+//______________________________________________________________________________
+TAttAxis* TGLCameraOverlay::GetAttAxis()
+{
+   return (TAttAxis*) fAxis;
+}
+
+//______________________________________________________________________________
+void TGLCameraOverlay::RenderPlaneIntersect(TGLRnrCtx& rnrCtx)
+{
+   // Print corss section coordinates in top right corner of screen.
    TGLCamera &cam = rnrCtx.RefCamera();
    // get eye line
    const TGLMatrix& mx =  cam.GetCamBase() * cam.GetCamTrans();
@@ -70,20 +91,7 @@ void TGLCameraOverlay::RenderPlaneIntersect(TGLRnrCtx& rnrCtx, const TGLFont &fo
    if (intersection.first)
    {
       TGLVertex3 v = intersection.second;
-      // get print format
-      Float_t m = TMath::Sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2] );
-      fAxisAtt.SetRng(-m, m);
-      fAxisPainter.SetAxisAtt(&fAxisAtt);
-      fAxisPainter.SetTextFormat(m);
-      char l0[100];
-      char l1[100];
-      char l2[100];
-      fAxisPainter.FormAxisValue(v[0], l0);
-      fAxisPainter.FormAxisValue(v[1], l1);
-      fAxisPainter.FormAxisValue(v[2], l2);
-      const char* txt = Form("(%s, %s, %s)", l0, l1, l2);
-
-      TGLUtil::Color(fAxisAtt.GetLabelColor());
+
       glMatrixMode(GL_PROJECTION);
       glPushMatrix();
       glLoadIdentity();
@@ -92,14 +100,20 @@ void TGLCameraOverlay::RenderPlaneIntersect(TGLRnrCtx& rnrCtx, const TGLFont &fo
       glPushMatrix();
       glLoadIdentity();
 
+      TGLRect &vp = rnrCtx.GetCamera()->RefViewport();
+      TGLFont font;
+      Int_t fs = TGLFontManager::GetFontSize((vp.Width()+vp.Height())*0.01, 10, 128);
+      rnrCtx.RegisterFont(fs, "arial", TGLFont::kPixmap, font);
       Float_t bb[6];
+      const char* txt = Form("(%f, %f, %f)", v[0], v[1], v[2]);
       font.BBox(txt, bb[0], bb[1], bb[2], bb[3], bb[4], bb[5]);
-      TGLRect &vp = rnrCtx.GetCamera()->RefViewport();
       Float_t off = 1.5*bb[4];
       off /= vp.Height() ;
+      TGLUtil::Color(kGray);
       font.RenderBitmap(txt, 1 -off, 1-off, 0,TGLFont::kRight);
 
       // render cross
+      TGLUtil::Color(kRed);
       Float_t w = 0.02;  // cross size
       Float_t ce = 0.15; // empty space
       glBegin(GL_LINES);
@@ -129,59 +143,75 @@ void TGLCameraOverlay::RenderAxis(TGLRnrCtx& rnrCtx)
 {
    // Draw axis on four edges.
 
-   TGLCamera &cam = rnrCtx.RefCamera();
-   Int_t minPix = 5; // minimum tick-mark size in pixels
-   Float_t relTM = 0.015;  // tick-mark size relative to axis range
-   Float_t tms;
-   TGLVertex3 worldRef;
-
-   // vertical
-   fAxisAtt.RefDir().Set(0, 1, 0);
-   Float_t off = (fFrustum[3]-fFrustum[1])*0.5*(1-fAxisExtend);
-   fAxisAtt.SetRng(fFrustum[1]+off, fFrustum[3]-off);
-   tms = (fFrustum[2]-fFrustum[0])*relTM;
-   TGLVertex3 hOff = cam.ViewportDeltaToWorld(worldRef, minPix, 0);
-   if (tms > hOff.X()) tms = hOff.X();
-   // left
-   glPushMatrix();
-   glTranslated(fFrustum[0], 0, 0);
-   fAxisAtt.RefTMOff(0).Set(tms, 0, 0);
-   fAxisAtt.SetTextAlign(TGLFont::kLeft);
-   fAxisPainter.Paint(rnrCtx, fAxisAtt);
-   glPopMatrix();
-   // right
-   glPushMatrix();
-   glTranslatef(fFrustum[2], 0, 0);
-   fAxisAtt.SetTextAlign(TGLFont::kRight);
-   fAxisAtt.RefTMOff(0).Set(-tms, 0, 0);
-   fAxisPainter.Paint(rnrCtx, fAxisAtt);
-   glPopMatrix();
+   // All four axis has to have same font.
+   // Size of font calculated relative to viewport diagonal
+   fAxisPainter->SetAttAxis(fAxis);
+   GLint   vp[4]; glGetIntegerv(GL_VIEWPORT, vp);
+   Float_t rl = 0.5 *((vp[2]-vp[0]) + (vp[3]-vp[1]));
+   Float_t als = 0.025;
+   Float_t sizeX = als*rl/(vp[2]-vp[0]);
+   Float_t sizeY = als*rl/(vp[3]-vp[1]);
+   Float_t tlY = 0.015*rl/(vp[2]-vp[0]);
+   Float_t tlX = 0.015*rl/(vp[3]-vp[1]);
 
-   // horizontal
-   fAxisAtt.RefDir().Set(1, 0, 0);
-   off = (fFrustum[2]-fFrustum[0])*0.5*(1-fAxisExtend);
-   fAxisAtt.SetRng(fFrustum[0]+off, fFrustum[2]-off);
-   tms = (fFrustum[3]-fFrustum[1])*relTM;
-   TGLVertex3 vOff = cam.ViewportDeltaToWorld(worldRef,  0, minPix);
-   if (tms > vOff.Y()) tms = vOff.Y();
-   // bottom
-   glPushMatrix();
-   glTranslatef(0, fFrustum[1], 0);
-   fAxisAtt.SetTextAlign(TGLFont::kCenterDown);
-   fAxisAtt.RefTMOff(0).Set( 0, tms,  0);
-   fAxisPainter.Paint(rnrCtx, fAxisAtt);
-   glPopMatrix();
-   // top
-   glPushMatrix();
-   glTranslatef(0, fFrustum[3], 0);
-   fAxisAtt.SetTextAlign(TGLFont::kCenterUp);
-   fAxisAtt.RefTMOff(0).Set( 0, -tms,  0);
-   fAxisPainter.Paint(rnrCtx, fAxisAtt);
-   glPopMatrix();
+
+   // horizontal X
+   //
+   {
+      fAxis->SetLabelSize(sizeX);
+      fAxis->SetTickLength(tlX);
+      fAxisPainter->RefDir().Set(1, 0, 0);
+      Float_t axisXOff = (fFrustum[2] - fFrustum[0]) * (1 - fAxisExtend);
+      fAxis->SetLimits(fFrustum[0] + axisXOff, fFrustum[2] - axisXOff);
+      fAxis->SetRangeUser(fFrustum[0] + axisXOff, fFrustum[2] - axisXOff);
+      // bottom
+
+      glPushMatrix();
+      glTranslatef(0, fFrustum[1], 0);
+      fAxisPainter->SetLabelAlign(TGLFont::kCenterDown);
+      fAxisPainter->RefTMOff(0).Set(0, fFrustum[3] - fFrustum[1],  0);
+      fAxisPainter->PaintAxis(rnrCtx, fAxis);
+      glPopMatrix();
+
+      // top
+      glPushMatrix();
+      glTranslatef(0, fFrustum[3], 0);
+      fAxisPainter->SetLabelAlign(TGLFont::kCenterUp);
+      fAxisPainter->RefTMOff(0).Negate();
+      fAxisPainter->RnrLabels();
+      fAxisPainter->RnrLines();
+      glPopMatrix();
+   }
+
+   //
+   // vertical Y
+   {
+      fAxis->SetLabelSize(sizeY);
+      fAxis->SetTickLength(tlY);
+      fAxisPainter->RefDir().Set(0, 1, 0);
+      Float_t axisYOff = (fFrustum[3] - fFrustum[1]) * (1 - fAxisExtend);
+      fAxis->SetLimits(fFrustum[1] + axisYOff, fFrustum[3] - axisYOff);
+      // left
+
+      glPushMatrix();
+      glTranslated(fFrustum[0], 0, 0);
+      fAxisPainter->RefTMOff(0).Set(fFrustum[2] - fFrustum[0], 0, 0);
+      fAxisPainter->SetLabelAlign(TGLFont::kLeft);
+      fAxisPainter->PaintAxis(rnrCtx, fAxis);
+      glPopMatrix();
+      // right
+      glPushMatrix();
+      glTranslatef(fFrustum[2], 0, 0);
+      fAxisPainter->SetLabelAlign(TGLFont::kRight);
+      fAxisPainter->RefTMOff(0).Negate();
+      fAxisPainter->RnrLabels();
+      fAxisPainter->RnrLines();
+      glPopMatrix();
+   }
 }
 
 //______________________________________________________________________________
-void TGLCameraOverlay::RenderBar(TGLRnrCtx&  rnrCtx, const TGLFont &font)
+void TGLCameraOverlay::RenderBar(TGLRnrCtx&  rnrCtx)
 {
    // Show frustum size with fixed screen line length and printed value.
 
@@ -206,12 +236,15 @@ void TGLCameraOverlay::RenderBar(TGLRnrCtx&  rnrCtx, const TGLFont &font)
    TGLUtil::Color(kWhite);
    const char* txt = Form("%.*f", (exp < 0) ? -exp : 0, red);
    Float_t bb[6];
+   TGLFont font;
+   rnrCtx.RegisterFont(12, "arial", TGLFont::kPixmap, font);
    font.BBox(txt, bb[0], bb[1], bb[2], bb[3], bb[4], bb[5]);
    TGLRect &vp = rnrCtx.GetCamera()->RefViewport();
    Double_t mH = (fFrustum[3]-fFrustum[1])*bb[4]/vp.Height();
    glPushMatrix();
    glTranslatef(fFrustum[2] -barsize, fFrustum[3] - (mH*1.5), 0);
    glRasterPos2i(0,0);
+   TGLUtil::Color(kGray);
    font.Render(txt);
    glPopMatrix();
 
@@ -248,9 +281,11 @@ void TGLCameraOverlay::Render(TGLRnrCtx& rnrCtx)
 
    TGLCamera &cam = rnrCtx.RefCamera();
    if ( rnrCtx.Selection() || (cam.IsPerspective()  && ! fShowPerspective) ||
-       (cam.IsOrthographic() && ! fShowOrthographic))
+        (cam.IsOrthographic() && ! fShowOrthographic))
       return;
 
+   TGLCapabilitySwitch lights_off(GL_LIGHTING, kFALSE);
+
    const GLdouble *pm = rnrCtx.RefCamera().RefLastNoPickProjM().CArr();
    GLdouble mm[16];
    GLint    vp[4];
@@ -264,23 +299,9 @@ void TGLCameraOverlay::Render(TGLRnrCtx& rnrCtx)
    fFrustum[2]=r;
    fFrustum[3]=t;
 
-   // font size
-   Int_t fs = TGLFontManager::GetFontSize(cam.RefViewport().Height()*fAxisAtt.GetLabelSize());
-   fAxisAtt.SetRelativeFontSize(kFALSE);
-   fAxisAtt.SetAbsLabelFontSize(fs);
-   TGLFont font;
-   rnrCtx.RegisterFont(fs, fAxisAtt.GetLabelFontName(), TGLFont::kPixmap, font);
-   TGLCapabilitySwitch lights_off(GL_LIGHTING, kFALSE);
-
    if (cam.IsOrthographic())
-   {
-      if (fOrthographicMode == kBar)
-         RenderBar(rnrCtx, font);
-      else
-         RenderAxis(rnrCtx);
-   }
+      (fOrthographicMode == kBar) ? RenderBar(rnrCtx) :  RenderAxis(rnrCtx);
    else
-   {
-      RenderPlaneIntersect(rnrCtx, font);
-   }
+      RenderPlaneIntersect(rnrCtx);
 }
+
diff --git a/graf3d/gl/src/TGLEmbeddedViewer.cxx b/graf3d/gl/src/TGLEmbeddedViewer.cxx
index b21546d..5b86773 100644
--- a/graf3d/gl/src/TGLEmbeddedViewer.cxx
+++ b/graf3d/gl/src/TGLEmbeddedViewer.cxx
@@ -69,6 +69,8 @@ void TGLEmbeddedViewer::CreateGLWidget()
       return;
    }
 
+   ResetInitGL();
+
    fGLWidget = TGLWidget::Create(fFrame, kTRUE, kTRUE, 0, 10, 10);
    fGLWidget->SetEventHandler(fEventHandler);
 
@@ -90,7 +92,10 @@ void TGLEmbeddedViewer::DestroyGLWidget()
       return;
    }
 
+   ResetInitGL();
+
    fGLWidget->UnmapWindow();
+   fGLWidget->SetEventHandler(0);
 
    fFrame->RemoveFrame(fGLWidget);
    fGLWidget->DeleteWindow();
diff --git a/graf3d/gl/src/TGLEventHandler.cxx b/graf3d/gl/src/TGLEventHandler.cxx
index 6d6899f..e0dfbfb 100644
--- a/graf3d/gl/src/TGLEventHandler.cxx
+++ b/graf3d/gl/src/TGLEventHandler.cxx
@@ -32,6 +32,7 @@
 #include "TContextMenu.h"
 #include "TGToolTip.h"
 #include "KeySymbols.h"
+#include "TGLAnnotation.h"
 
 //______________________________________________________________________________
 //
@@ -299,7 +300,7 @@ Bool_t TGLEventHandler::HandleButton(Event_t * event)
    if (fGLViewer->IsLocked()) {
       if (gDebug>2) {
          Info("TGLEventHandler::HandleButton", "ignored - viewer is %s",
-            fGLViewer->LockName(fGLViewer->CurrentLock()));
+              fGLViewer->LockName(fGLViewer->CurrentLock()));
       }
       return kFALSE;
    }
@@ -316,20 +317,29 @@ Bool_t TGLEventHandler::HandleButton(Event_t * event)
       eventSt.fY = event->fY;
       eventSt.fCode = event->fCode;
 
-      if (fGLViewer->GetPushAction() == TGLViewer::kPushCamCenter)
+      if ( fGLViewer->GetPushAction() != TGLViewer::kPushStd )
       {
-         fGLViewer->fPushAction = TGLViewer::kPushStd;
          fGLViewer->RequestSelect(event->fX, event->fY);
          if (fGLViewer->fSelRec.GetN() > 0)
          {
             TGLVector3 v(event->fX, event->fY, 0.5*fGLViewer->fSelRec.GetMinZ());
             fGLViewer->CurrentCamera().WindowToViewport(v);
             v = fGLViewer->CurrentCamera().ViewportToWorld(v);
-            fGLViewer->CurrentCamera().SetExternalCenter(kTRUE);
-            fGLViewer->CurrentCamera().SetCenterVec(v.X(), v.Y(), v.Z());
+            if (fGLViewer->GetPushAction() == TGLViewer::kPushCamCenter)
+            {
+               fGLViewer->CurrentCamera().SetExternalCenter(kTRUE);
+               fGLViewer->CurrentCamera().SetCenterVec(v.X(), v.Y(), v.Z());
+            }
+            else
+            { 
+               TGLSelectRecord& rec = fGLViewer->GetSelRec();
+               TObject* obj = rec.GetObject();
+               TGLRect& vp = fGLViewer->CurrentCamera().RefViewport();
+               new TGLAnnotation(fGLViewer, obj->GetTitle(),  eventSt.fX*1.f/vp.Width(),  1 - eventSt.fY*1.f/vp.Height(), v);
+            }
+
             fGLViewer->RequestDraw();
          }
-         fGLViewer->RefreshPadEditor(this);
          return kTRUE;
       }
 
@@ -435,7 +445,14 @@ Bool_t TGLEventHandler::HandleButton(Event_t * event)
          fInPointerGrab = kFALSE;
       }
 
-      if (fGLViewer->fDragAction == TGLViewer::kDragOverlay)
+      if (fGLViewer->GetPushAction() !=  TGLViewer::kPushStd)
+      {
+         // This should be 'tool' dependant.
+         fGLViewer->fPushAction = TGLViewer::kPushStd;
+         fGLViewer->RefreshPadEditor(fGLViewer);
+         return kTRUE;
+      }
+      else if (fGLViewer->fDragAction == TGLViewer::kDragOverlay && fGLViewer->fCurrentOvlElm)
       {
          fGLViewer->fCurrentOvlElm->Handle(*fGLViewer->fRnrCtx, fGLViewer->fOvlSelRec, event);
          fGLViewer->OverlayDragFinished();
@@ -471,10 +488,13 @@ Bool_t TGLEventHandler::HandleButton(Event_t * event)
       }
       fGLViewer->fDragAction = TGLViewer::kDragNone;
       if (fGLViewer->fGLDevice != -1)
+      {
          gGLManager->MarkForDirectCopy(fGLViewer->fGLDevice, kFALSE);
+      }
       if ((event->fX == eventSt.fX) &&
           (event->fY == eventSt.fY) &&
-          (eventSt.fCode == event->fCode)) {
+          (eventSt.fCode == event->fCode))
+      {
          TObject *obj = 0;
          fGLViewer->RequestSelect(fLastPos.fX, fLastPos.fY, kFALSE);
          TGLPhysicalShape *phys_shape = fGLViewer->fSelRec.GetPhysShape();
@@ -488,7 +508,8 @@ Bool_t TGLEventHandler::HandleButton(Event_t * event)
          eventSt.fCode = 0;
          eventSt.fState = 0;
       }
-      if (event->fCode == kButton1 && fMouseTimer) {
+      if (event->fCode == kButton1 && fMouseTimer)
+      {
          fMouseTimer->TurnOn();
       }
    }
@@ -860,10 +881,25 @@ void TGLEventHandler::TriggerTooltip(const char* text)
 {
    // Trigger display of tooltip.
 
+   static UInt_t screenW = 0, screenH = 0;
    fTooltipPos   = fLastGlobalPos;
    fTooltipShown = kTRUE;
    fTooltip->SetText(text);
-   fTooltip->SetPosition(fTooltipPos.fX + 16, fTooltipPos.fY - 16);
+   Int_t x = fTooltipPos.fX + 16, y = fTooltipPos.fY + 16;
+   if (screenW == 0 || screenH == 0) {
+      screenW = gClient->GetDisplayWidth();
+      screenH = gClient->GetDisplayHeight();
+   }
+   if (x + 5 + fTooltip->GetWidth() > screenW) {
+      x = screenW - fTooltip->GetWidth() - 5;
+      if (y + 5 + fTooltip->GetHeight() > screenH) {
+         y -= (25 + fTooltip->GetHeight());
+      }
+   }
+   if (y + 5 + fTooltip->GetHeight() > screenH) {
+      y = screenH - fTooltip->GetHeight() - 10;
+   }
+   fTooltip->SetPosition(x, y);
    fTooltip->Reset();
 }
 
diff --git a/graf3d/gl/src/TGLFontManager.cxx b/graf3d/gl/src/TGLFontManager.cxx
index fd38a6f..97a7305 100644
--- a/graf3d/gl/src/TGLFontManager.cxx
+++ b/graf3d/gl/src/TGLFontManager.cxx
@@ -102,7 +102,48 @@ void TGLFont::CopyAttributes(const TGLFont &o)
 /******************************************************************************/
 
 //______________________________________________________________________________
-void TGLFont::BBox(const char* txt, Float_t& llx, Float_t& lly, Float_t& llz, Float_t& urx, Float_t& ury, Float_t& urz) const
+Float_t TGLFont::GetAscent() const
+{
+   // Get font's ascent.
+
+   return fFont->Ascender();
+}
+
+//______________________________________________________________________________
+Float_t TGLFont::GetDescent() const
+{
+   // Get font's descent. The returned value is positive.
+
+   return -fFont->Descender();
+}
+
+//______________________________________________________________________________
+Float_t TGLFont::GetLineHeight() const
+{
+   // Get font's line-height.
+
+   return fFont->LineHeight();
+}
+
+//______________________________________________________________________________
+void TGLFont::MeasureBaseLineParams(Float_t& ascent, Float_t& descent, Float_t& line_height,
+                                    const char* txt) const
+{
+   // Measure font's base-line parameters from the passed text.
+   // Note that the measured parameters are not the same as the ones
+   // returned by get-functions - those were set by the font designer.
+
+   Float_t dum, lly, ury;
+   const_cast<FTFont*>(fFont)->BBox(txt, dum, lly, dum, dum, ury, dum);
+   ascent      =  ury;
+   descent     = -lly;
+   line_height =  ury - lly;
+}
+
+//______________________________________________________________________________
+void TGLFont::BBox(const char* txt,
+                   Float_t& llx, Float_t& lly, Float_t& llz,
+                   Float_t& urx, Float_t& ury, Float_t& urz) const
 {
    // Get bounding box.
 
@@ -309,7 +350,7 @@ void TGLFontManager::RegisterFont(Int_t size, Int_t fileID, TGLFont::EMode mode,
 }
 
 //______________________________________________________________________________
-void TGLFontManager::RegisterFont(Int_t size, const Text_t* name, TGLFont::EMode mode, TGLFont &out)
+void TGLFontManager::RegisterFont(Int_t size, const char* name, TGLFont::EMode mode, TGLFont &out)
 {
    // Get mapping from ttf id to font names. Table taken from TTF.cxx.
 
@@ -397,25 +438,12 @@ Int_t TGLFontManager::GetFontSize(Float_t ds, Int_t min, Int_t max)
 //______________________________________________________________________________
 const char* TGLFontManager::GetFontNameFromId(Int_t id)
 {
-   static const char *fonttable[] = {
-      /* 0 */  "arialbd",
-      /* 1 */  "timesi",
-      /* 2 */  "timesbd",
-      /* 3 */  "timesbi",
-      /* 4 */  "arial",
-      /* 5 */  "ariali",
-      /* 6 */  "arialbd",
-      /* 7 */  "arialbi",
-      /* 8 */  "cour",
-      /* 9 */  "couri",
-      /*10 */  "courbd",
-      /*11 */  "courbi",
-      /*12 */  "symbol",
-      /*13 */  "times",
-      /*14 */  "wingding"
-   };
+   // Get font name from TAttAxis font id.
+
+   if (fgStaticInitDone == kFALSE) InitStatics();
 
-   return fonttable[id / 10];
+   TObjString* os = (TObjString*)fgFontFileArray[id / 10];
+   return os->GetString().Data();
 }
 
 //______________________________________________________________________________
@@ -423,25 +451,25 @@ void TGLFontManager::InitStatics()
 {
    // Create a list of available font files and allowed font sizes.
 
-   const char *ttpath = gEnv->GetValue("Root.TTFontPath",
-# ifdef TTFFONTDIR
-                                       TTFFONTDIR);
-# else
-                                       "$(ROOTSYS)/fonts");
-# endif
-
-   void *dir = gSystem->OpenDirectory(ttpath);
-   const char* name = 0;
-   TString s;
-   while ((name = gSystem->GetDirEntry(dir))) {
-      s = name;
-      if (s.EndsWith(".ttf")) {
-         s.Resize(s.Sizeof() -5);
-         fgFontFileArray.Add(new TObjString(s.Data()));
-      }
-   }
-   fgFontFileArray.Sort();
-   gSystem->FreeDirectory(dir);
+   fgFontFileArray.Add(new TObjString("arialbd"));  //   0
+
+   fgFontFileArray.Add(new TObjString("timesi"));   //  10
+   fgFontFileArray.Add(new TObjString("timesbd"));  //  20
+   fgFontFileArray.Add(new TObjString("timesbi"));  //  30
+ 
+   fgFontFileArray.Add(new TObjString("arial"));    //  40
+   fgFontFileArray.Add(new TObjString("ariali"));   //  50
+   fgFontFileArray.Add(new TObjString("arialbd"));  //  60
+   fgFontFileArray.Add(new TObjString("arialbi"));  //  70
+
+   fgFontFileArray.Add(new TObjString("cour"));     //  80
+   fgFontFileArray.Add(new TObjString("couri"));    //  90
+   fgFontFileArray.Add(new TObjString("courbd"));   // 100
+   fgFontFileArray.Add(new TObjString("courbi"));   // 110
+
+   fgFontFileArray.Add(new TObjString("symbol"));   // 120
+   fgFontFileArray.Add(new TObjString("times"));    // 130
+   fgFontFileArray.Add(new TObjString("wingding")); // 140
 
 
    // font sizes
diff --git a/graf3d/gl/src/TGLLightSetEditor.cxx b/graf3d/gl/src/TGLLightSetEditor.cxx
index 97450f9..0963a48 100644
--- a/graf3d/gl/src/TGLLightSetEditor.cxx
+++ b/graf3d/gl/src/TGLLightSetEditor.cxx
@@ -66,7 +66,7 @@ TGLLightSetSubEditor::TGLLightSetSubEditor(const TGWindow *p) :
 }
 
 //______________________________________________________________________________
-TGButton* TGLLightSetSubEditor::MakeLampButton(const Text_t* name, Int_t wid,
+TGButton* TGLLightSetSubEditor::MakeLampButton(const char* name, Int_t wid,
                                                TGCompositeFrame* parent)
 {
    // Create a button for given lamp and set it up.
diff --git a/graf3d/gl/src/TGLMarchingCubes.cxx b/graf3d/gl/src/TGLMarchingCubes.cxx
new file mode 100644
index 0000000..bafd7fc
--- /dev/null
+++ b/graf3d/gl/src/TGLMarchingCubes.cxx
@@ -0,0 +1,1156 @@
+#include <algorithm>
+#include <cmath>
+
+#include "TError.h"
+#include "TF3.h"
+
+#include "TGLMarchingCubes.h"
+
+/*
+Implementation of "marching cubes" algortihm for GL module. Used by 
+TF3GLPainter and TGLIsoPainter. 
+Good and clear algorithm explanation can be found here: 
+http://local.wasp.uwa.edu.au/~pbourke/geometry/polygonise/
+*/
+
+namespace Rgl {
+namespace Mc {
+
+namespace {
+
+/*
+Some routines, values and tables for marching cube method.
+*/
+extern const UInt_t  eInt[256];
+extern const Float_t vOff[8][3];
+extern const UChar_t eConn[12][2];
+extern const Float_t eDir[12][3];
+extern const Int_t   conTbl[256][16];
+
+enum ECubeBitMasks {
+   k0  = 0x1,
+   k1  = 0x2,
+   k2  = 0x4,
+   k3  = 0x8,
+   k4  = 0x10,
+   k5  = 0x20,
+   k6  = 0x40,
+   k7  = 0x80,
+   k8  = 0x100,
+   k9  = 0x200,
+   k10 = 0x400,
+   k11 = 0x800,
+   //
+   k1_5            = k1 | k5,
+   k2_6            = k2 | k6,
+   k3_7            = k3 | k7,
+   k4_5_6_7        = k4 | k5 | k6 | k7,
+   k5_6            = k5 | k6,
+   k0_1_2_3_7_8_11 = k0 | k1 | k2 | k3 | k7 | k8 | k11,
+   k6_7            = k6 | k7
+};
+
+//_________________________________________________________________
+template<class E, class V>
+V GetOffset(E val1, E val2, V iso)
+{
+   const V delta = val2 - val1;
+   if (!delta)
+      return 0.5f;
+   return (iso - val1) / delta;
+}
+
+//______________________________________________________________________
+template<class E, class V>
+void ConnectTriangles(TCell<E> &cell, TIsoMesh<V> *mesh, V eps)
+{
+   UInt_t t[3];
+   for (UInt_t i = 0; i < 5; ++i) {
+      if (conTbl[cell.fType][3 * i] < 0)
+         break;
+      for (Int_t j = 2; j >= 0; --j)
+         t[j] = cell.fIds[conTbl[cell.fType][3 * i + j]];
+
+      const V *v0 = &mesh->fVerts[t[0] * 3];
+      const V *v1 = &mesh->fVerts[t[1] * 3];
+      const V *v2 = &mesh->fVerts[t[2] * 3];
+
+      if (std::abs(v0[0] - v1[0]) < eps && 
+          std::abs(v0[1] - v1[1]) < eps &&
+          std::abs(v0[2] - v1[2]) < eps)
+         continue;
+
+      if (std::abs(v2[0] - v1[0]) < eps && 
+          std::abs(v2[1] - v1[1]) < eps &&
+          std::abs(v2[2] - v1[2]) < eps)
+         continue;
+
+      if (std::abs(v0[0] - v2[0]) < eps && 
+          std::abs(v0[1] - v2[1]) < eps &&
+          std::abs(v0[2] - v2[2]) < eps)
+         continue;
+
+      mesh->AddTriangle(t);
+   }
+}
+
+}//unnamed namespace.
+
+/*
+TF3Adapter.
+*/
+//______________________________________________________________________
+void TF3Adapter::SetDataSource(const TF3 *f3)
+{
+   fTF3 = f3;
+   fW = f3->GetXaxis()->GetNbins();//f3->GetNpx();
+   fH = f3->GetYaxis()->GetNbins();//f3->GetNpy();
+   fD = f3->GetZaxis()->GetNbins();//f3->GetNpz();
+}
+
+//______________________________________________________________________
+Double_t TF3Adapter::GetData(UInt_t i, UInt_t j, UInt_t k)const
+{
+   return fTF3->Eval(fMinX + i * fStepX, 
+                     fMinY + j * fStepY, 
+                     fMinZ + k * fStepZ);
+}
+
+/*
+TH3 split edge implementation.
+"this->" is used with type-dependant names
+in templates.
+*/
+//______________________________________________________________________
+template<class H, class E, typename V>
+void TH3EdgeSplitter<H, E, V>::SplitEdge(TCell<E> & cell, TIsoMesh<V> * mesh, UInt_t i, 
+                                         V x, V y, V z, V iso)const
+{
+   V v[3];
+   const V offset = GetOffset(cell.fVals[eConn[i][0]], 
+                              cell.fVals[eConn[i][1]], 
+                              iso);
+   v[0] = x + (vOff[eConn[i][0]][0] + offset * eDir[i][0]) * this->fStepX;
+   v[1] = y + (vOff[eConn[i][0]][1] + offset * eDir[i][1]) * this->fStepY;
+   v[2] = z + (vOff[eConn[i][0]][2] + offset * eDir[i][2]) * this->fStepZ;
+   cell.fIds[i] = mesh->AddVertex(v);
+}
+
+/*
+TF3 split edge implementation.
+*/
+//______________________________________________________________________
+void TF3EdgeSplitter::SplitEdge(TCell<Double_t> & cell, TIsoMesh<Double_t> * mesh, UInt_t i,
+                                Double_t x, Double_t y, Double_t z, Double_t iso)const
+{
+   //Split the edge and find normal in a new vertex.
+   Double_t v[3];
+   const Double_t ofst = GetOffset(cell.fVals[eConn[i][0]], cell.fVals[eConn[i][1]], iso);
+   v[0] = x + (vOff[eConn[i][0]][0] + ofst * eDir[i][0]) * fStepX;
+   v[1] = y + (vOff[eConn[i][0]][1] + ofst * eDir[i][1]) * fStepY;
+   v[2] = z + (vOff[eConn[i][0]][2] + ofst * eDir[i][2]) * fStepZ;
+   cell.fIds[i] = mesh->AddVertex(v);
+   //Find normals.
+   Double_t n[3];
+   n[0] = fTF3->Eval(v[0] - 0.1 * fStepX, v[1], v[2]) -
+          fTF3->Eval(v[0] + 0.1 * fStepX, v[1], v[2]);
+   n[1] = fTF3->Eval(v[0], v[1] - 0.1 * fStepY, v[2]) -
+          fTF3->Eval(v[0], v[1] + 0.1 * fStepY, v[2]);
+   n[2] = fTF3->Eval(v[0], v[1], v[2] - 0.1 * fStepZ) -
+          fTF3->Eval(v[0], v[1], v[2] + 0.1 * fStepZ);
+
+   const Double_t len = std::sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]);
+   if (len > 1e-7) {
+      n[0] /= len;
+      n[1] /= len;
+      n[2] /= len;
+   }
+
+   mesh->AddNormal(n);
+}
+/*
+TMeshBuilder's implementation.
+"this->" is used with type-dependant names
+in templates.
+*/
+//______________________________________________________________________
+template<class D, class V>
+void TMeshBuilder<D, V>::BuildMesh(const D *s, const TGridGeometry<V> &g,
+                                   MeshType_t *m, V iso)
+{
+   //Build iso-mesh using marching cubes.
+   static_cast<TGridGeometry<V> &>(*this) = g;
+
+   this->SetDataSource(s);
+
+   if (GetW() < 2 || GetH() < 2 || GetD() < 2) {
+      Error("TMeshBuilder::BuildMesh", 
+            "Bad grid size, one of dimensions is less than 2");
+      return;
+   }
+
+   fSlices[0].ResizeSlice(GetW() - 1, GetH() - 1);
+   fSlices[1].ResizeSlice(GetW() - 1, GetH() - 1);
+
+   this->SetNormalEvaluator(s);
+
+   fMesh = m;
+   fIso  = iso;
+
+   SliceType_t *slice1 = fSlices;
+   SliceType_t *slice2 = fSlices + 1;
+
+   NextStep(0, 0, slice1);
+
+   for (UInt_t i = 1, e = GetD(); i < e - 1; ++i) {
+      NextStep(i, slice1, slice2);
+      std::swap(slice1, slice2);
+   }
+
+   if(fAvgNormals)
+      BuildNormals();
+}
+
+//______________________________________________________________________
+template<class D, class V>
+void TMeshBuilder<D, V>::NextStep(UInt_t depth, const SliceType_t *prevSlice, 
+                                  SliceType_t *curr)const
+{
+   //Fill slice with vertices and triangles.
+
+   if (!prevSlice) {
+      //The first slice in mc grid.
+      BuildFirstCube(curr);
+      BuildRow(curr);
+      BuildCol(curr);
+      BuildSlice(curr);
+   } else {
+      BuildFirstCube(depth, prevSlice, curr);
+      BuildRow(depth, prevSlice, curr);
+      BuildCol(depth, prevSlice, curr);
+      BuildSlice(depth, prevSlice, curr);
+   }
+}
+
+//______________________________________________________________________
+template<class D, class V>
+void TMeshBuilder<D, V>::BuildFirstCube(SliceType_t *s)const
+{
+   //The first cube in a grid. nx == 0, ny == 0, nz ==0.
+   CellType_t & cell = s->fCells[0];
+   cell.fVals[0] = GetData(0, 0, 0);
+   cell.fVals[1] = GetData(1, 0, 0);
+   cell.fVals[2] = GetData(1, 1, 0);
+   cell.fVals[3] = GetData(0, 1, 0);
+   cell.fVals[4] = GetData(0, 0, 1);
+   cell.fVals[5] = GetData(1, 0, 1);
+   cell.fVals[6] = GetData(1, 1, 1);
+   cell.fVals[7] = GetData(0, 1, 1);
+
+   cell.fType = 0;
+   for (UInt_t i = 0; i < 8; ++i) {
+      if (cell.fVals[i] <= fIso)
+         cell.fType |= 1 << i;
+   }
+
+   for (UInt_t i = 0, edges = eInt[cell.fType]; i < 12; ++i) {
+      if (edges & (1 << i))
+         SplitEdge(cell, fMesh, i, this->fMinX, this->fMinY, this->fMinZ, fIso);
+   }
+
+   ConnectTriangles(cell, fMesh, fEpsilon);
+}
+
+//______________________________________________________________________
+template<class D, class V>
+void TMeshBuilder<D, V>::BuildRow(SliceType_t *s)const
+{
+   //The first row (along x) in the first slice:
+   //ny == 0, nz == 0, nx : [1, W - 1].
+   //Each cube has previous cube.
+   //Values 0, 3, 4, 7 are taken from the previous cube.
+   //Edges 3, 7, 8, 11 are taken from the previous cube.
+   for (UInt_t i = 1, e = GetW() - 1; i < e; ++i) {
+      const CellType_t &prev = s->fCells[i - 1];
+      CellType_t &cell = s->fCells[i];
+      cell.fType = 0;
+
+      cell.fVals[0] = prev.fVals[1], cell.fVals[4] = prev.fVals[5];
+      cell.fVals[7] = prev.fVals[6], cell.fVals[3] = prev.fVals[2];
+      cell.fType |= (prev.fType & k1_5) >> 1;
+      cell.fType |= (prev.fType & k2_6) << 1;
+
+      if ((cell.fVals[1] = GetData(i + 1, 0, 0)) <= fIso)
+         cell.fType |= k1;
+      if ((cell.fVals[2] = GetData(i + 1, 1, 0)) <= fIso)
+         cell.fType |= k2;
+      if ((cell.fVals[5] = GetData(i + 1, 0, 1)) <= fIso)
+         cell.fType |= k5;
+      if ((cell.fVals[6] = GetData(i + 1, 1, 1)) <= fIso)
+         cell.fType |= k6;
+
+      const UInt_t edges = eInt[cell.fType];
+      if (!edges)
+         continue;
+      //1. Take edges 3, 7, 8, 11 from the previous cube.
+      if (edges & k3)
+         cell.fIds[3]  = prev.fIds[1];
+      if (edges & k7)
+         cell.fIds[7]  = prev.fIds[5];
+      if (edges & k8)
+         cell.fIds[8]  = prev.fIds[9];
+      if (edges & k11)
+         cell.fIds[11] = prev.fIds[10];
+      //2. Intersect edges 0, 1, 2, 4, 5, 6, 9, 10.
+      const V x = this->fMinX + i * this->fStepX;
+      if (edges & k0)
+         SplitEdge(cell, fMesh, 0, x, this->fMinY, this->fMinZ, fIso);
+      if (edges & k1)
+         SplitEdge(cell, fMesh, 1, x, this->fMinY, this->fMinZ, fIso);
+      if (edges & k2)
+         SplitEdge(cell, fMesh, 2, x, this->fMinY, this->fMinZ, fIso);
+      if (edges & k4)
+         SplitEdge(cell, fMesh, 4, x, this->fMinY, this->fMinZ, fIso);
+      if (edges & k5)
+         SplitEdge(cell, fMesh, 5, x, this->fMinY, this->fMinZ, fIso);
+      if (edges & k6)
+         SplitEdge(cell, fMesh, 6, x, this->fMinY, this->fMinZ, fIso);
+      if (edges & k9)
+         SplitEdge(cell, fMesh, 9, x, this->fMinY, this->fMinZ, fIso);
+      if (edges & k10)
+         SplitEdge(cell, fMesh, 10, x, this->fMinY, this->fMinZ, fIso);
+      //3. Connect new triangles.
+      ConnectTriangles(cell, fMesh, fEpsilon);
+   }
+}
+
+//______________________________________________________________________
+template<class D, class V>
+void TMeshBuilder<D, V>::BuildCol(SliceType_t *s)const
+{
+   //"Col" (column) consists of cubes along y axis
+   //on the first slice (nx == 0, nz == 0).
+   //Each cube has a previous cube and shares values:
+   //0, 1, 4, 5 (in prev.: 3, 2, 7, 6); and edges:
+   //0, 4, 8, 9 (in prev.: 2, 6, 10, 11).
+   const UInt_t w = GetW();
+   const UInt_t h = GetH();
+
+   for (UInt_t i = 1; i < h - 1; ++i) {
+      const CellType_t &prev = s->fCells[(i - 1) * (w - 1)];
+      CellType_t &cell = s->fCells[i * (w - 1)];
+      cell.fType = 0;
+      //Take values 0, 1, 4, 5 from the prev. cube.
+      cell.fVals[0] = prev.fVals[3], cell.fVals[1] = prev.fVals[2];
+      cell.fVals[4] = prev.fVals[7], cell.fVals[5] = prev.fVals[6];
+      cell.fType |= (prev.fType & k2_6) >> 1;
+      cell.fType |= (prev.fType & k3_7) >> 3;
+      //Calculate values 2, 3, 6, 7.
+      if((cell.fVals[2] = GetData(1, i + 1, 0)) <= fIso)
+         cell.fType |= k2;
+      if((cell.fVals[3] = GetData(0, i + 1, 0)) <= fIso)
+         cell.fType |= k3;
+      if((cell.fVals[6] = GetData(1, i + 1, 1)) <= fIso)
+         cell.fType |= k6;
+      if((cell.fVals[7] = GetData(0, i + 1, 1)) <= fIso)
+         cell.fType |= k7;
+
+      const UInt_t edges = eInt[cell.fType];
+      if(!edges)
+         continue;
+      //Take edges from the previous cube.
+      if (edges & k0)
+         cell.fIds[0] = prev.fIds[2];
+      if (edges & k4)
+         cell.fIds[4] = prev.fIds[6];
+      if (edges & k9)
+         cell.fIds[9] = prev.fIds[10];
+      if (edges & k8)
+         cell.fIds[8] = prev.fIds[11];
+      //Find the remaining edges.
+      const V y = this->fMinY + i * this->fStepY;
+
+      if (edges & k1)
+         SplitEdge(cell, fMesh, 1, this->fMinX, y, this->fMinZ, fIso);
+      if (edges & k2)
+         SplitEdge(cell, fMesh, 2, this->fMinX, y, this->fMinZ, fIso);
+      if (edges & k3)
+         SplitEdge(cell, fMesh, 3, this->fMinX, y, this->fMinZ, fIso);
+      if (edges & k5)
+         SplitEdge(cell, fMesh, 5, this->fMinX, y, this->fMinZ, fIso);
+      if (edges & k6)
+         SplitEdge(cell, fMesh, 6, this->fMinX, y, this->fMinZ, fIso);
+      if (edges & k7)
+         SplitEdge(cell, fMesh, 7, this->fMinX, y, this->fMinZ, fIso);
+      if (edges & k10)
+         SplitEdge(cell, fMesh, 10, this->fMinX, y, this->fMinZ, fIso);
+      if (edges & k11)
+         SplitEdge(cell, fMesh, 11, this->fMinX, y, this->fMinZ, fIso);
+
+      ConnectTriangles(cell, fMesh, fEpsilon);
+   }
+}
+
+//______________________________________________________________________
+template<class D, class V>
+void TMeshBuilder<D, V>::BuildSlice(SliceType_t *s)const
+{
+   //Slice with nz == 0.
+   //nx : [1, W - 1], ny : [1, H - 1].
+   //nx increased inside inner loop, ny - enclosing loop.
+   //Each cube has two neighbours: ny - 1 => "left",
+   //nx - 1 => "right".
+   const UInt_t w = GetW();
+   const UInt_t h = GetH();
+
+   for (UInt_t i = 1; i < h - 1; ++i) {
+      const V y = this->fMinY + i * this->fStepY;
+
+      for (UInt_t j = 1; j < w - 1; ++j) {
+         const CellType_t &left  = s->fCells[(i - 1) * (w - 1) + j];
+         const CellType_t &right = s->fCells[i * (w - 1) + j - 1];
+         CellType_t &cell = s->fCells[i * (w - 1) + j];
+         cell.fType = 0;
+         //Take values 0, 1, 4, 5 from left cube.
+         cell.fVals[1] = left.fVals[2];
+         cell.fVals[0] = left.fVals[3];
+         cell.fVals[5] = left.fVals[6];
+         cell.fVals[4] = left.fVals[7];
+         cell.fType |= (left.fType & k2_6) >> 1;
+         cell.fType |= (left.fType & k3_7) >> 3;
+         //3, 7 from right cube.
+         cell.fVals[3] = right.fVals[2];
+         cell.fVals[7] = right.fVals[6];
+         cell.fType |= (right.fType & k2_6) << 1;
+         //Calculate values 2, 6.
+         if((cell.fVals[2] = GetData(j + 1, i + 1, 0)) <= fIso)
+            cell.fType |= k2;
+         if((cell.fVals[6] = GetData(j + 1, i + 1, 1)) <= fIso)
+            cell.fType |= k6;
+
+         const UInt_t edges = eInt[cell.fType];
+         if(!edges)
+            continue;
+         //Take edges 0, 4, 8, 9 from the "left" cube.
+         //In left cube their indices are 2, 6, 11, 10.
+         if(edges & k0)
+            cell.fIds[0] = left.fIds[2];
+         if(edges & k4)
+            cell.fIds[4] = left.fIds[6];
+         if(edges & k8)
+            cell.fIds[8] = left.fIds[11];
+         if(edges & k9)
+            cell.fIds[9] = left.fIds[10];
+         //Take edges 3, 7, 11 from the "right" cube.
+         //Their "right" indices are 1, 5, 10.
+         if(edges & k3)
+            cell.fIds[3]  = right.fIds[1];
+         if(edges & k7)
+            cell.fIds[7]  = right.fIds[5];
+         if(edges & k11)
+            cell.fIds[11] = right.fIds[10];
+         //Calculate the remaining intersections: edges
+         //1, 2, 5, 6, 10.
+         const V x = this->fMinX + j * this->fStepX;
+         if (edges & k1)
+            SplitEdge(cell, fMesh, 1, x, y, this->fMinZ, fIso);
+         if (edges & k2)
+            SplitEdge(cell, fMesh, 2, x, y, this->fMinZ, fIso);
+         if (edges & k5)
+            SplitEdge(cell, fMesh, 5, x, y, this->fMinZ, fIso);
+         if (edges & k6)
+            SplitEdge(cell, fMesh, 6, x, y, this->fMinZ, fIso);
+         if (edges & k10)
+            SplitEdge(cell, fMesh, 10, x, y, this->fMinZ, fIso);
+
+         ConnectTriangles(cell, fMesh, fEpsilon);
+      }
+   }
+}
+
+//______________________________________________________________________
+template<class D, class V>
+void TMeshBuilder<D, V>::BuildFirstCube(UInt_t depth, const SliceType_t *prevSlice,
+                                        SliceType_t *slice)const
+{
+   //The first cube in a slice with nz == depth.
+   //Neighbour is the first cube in the previous slice.
+   //Four values and four edges come from the previous cube.
+   const CellType_t &prevCell = prevSlice->fCells[0];
+   CellType_t &cell = slice->fCells[0];
+   cell.fType = 0;
+   //Values 0, 1, 2, 3 are 4, 5, 6, 7
+   //in the previous cube.
+   cell.fVals[0] = prevCell.fVals[4];
+   cell.fVals[1] = prevCell.fVals[5];
+   cell.fVals[2] = prevCell.fVals[6];
+   cell.fVals[3] = prevCell.fVals[7];
+   cell.fType |= (prevCell.fType & k4_5_6_7) >> 4;
+   //Calculate 4, 5, 6, 7.
+   if((cell.fVals[4] = GetData(0, 0, depth + 1)) <= fIso)
+      cell.fType |= k4;
+   if((cell.fVals[5] = GetData(1, 0, depth + 1)) <= fIso)
+      cell.fType |= k5;
+   if((cell.fVals[6] = GetData(1, 1, depth + 1)) <= fIso)
+      cell.fType |= k6;
+   if((cell.fVals[7] = GetData(0, 1, depth + 1)) <= fIso)
+      cell.fType |= k7;
+
+   const UInt_t edges = eInt[cell.fType];
+   if(!edges)
+      return;
+
+   //Edges 0, 1, 2, 3 taken from the prev. cube -
+   //they have indices 4, 5, 6, 7 there.
+   if(edges & k0)
+      cell.fIds[0] = prevCell.fIds[4];
+   if(edges & k1)
+      cell.fIds[1] = prevCell.fIds[5];
+   if(edges & k2)
+      cell.fIds[2] = prevCell.fIds[6];
+   if(edges & k3)
+      cell.fIds[3] = prevCell.fIds[7];
+
+   const V z = this->fMinZ + depth * this->fStepZ;
+
+   if(edges & k4)
+      SplitEdge(cell, fMesh, 4,  this->fMinX, this->fMinY, z, fIso);
+   if(edges & k5)
+      SplitEdge(cell, fMesh, 5,  this->fMinX, this->fMinY, z, fIso);
+   if(edges & k6)
+      SplitEdge(cell, fMesh, 6,  this->fMinX, this->fMinY, z, fIso);
+   if(edges & k7)
+      SplitEdge(cell, fMesh, 7,  this->fMinX, this->fMinY, z, fIso);
+   if(edges & k8)
+      SplitEdge(cell, fMesh, 8,  this->fMinX, this->fMinY, z, fIso);
+   if(edges & k9)
+      SplitEdge(cell, fMesh, 9,  this->fMinX, this->fMinY, z, fIso);
+   if(edges & k10)
+      SplitEdge(cell, fMesh, 10, this->fMinX, this->fMinY, z, fIso);
+   if(edges & k11)
+      SplitEdge(cell, fMesh, 11, this->fMinX, this->fMinY, z, fIso);
+
+   ConnectTriangles(cell, fMesh, fEpsilon);
+}
+
+//______________________________________________________________________
+template<class D, class V>
+void TMeshBuilder<D, V>::BuildRow(UInt_t depth, const SliceType_t *prevSlice,
+                                  SliceType_t *slice)const
+{
+   //Row with ny == 0 and nz == depth, nx : [1, W - 1].
+   //Two neighbours: one from previous slice (called bottom cube here),
+   //the second is the previous cube in a row.
+   const V z = this->fMinZ + depth * this->fStepZ;
+   const UInt_t w = GetW();
+
+   for (UInt_t i = 1; i < w - 1; ++i) {
+      const CellType_t &prevCell = slice->fCells[i - 1];
+      const CellType_t &bottCell = prevSlice->fCells[i];
+      CellType_t &cell = slice->fCells[i];
+      cell.fType = 0;
+      //Value 0 is not required,
+      //only bit number 0 in fType is interesting.
+      //3, 4, 7 come from the previous box (2, 5, 6)
+      cell.fVals[3] = prevCell.fVals[2];
+      cell.fVals[4] = prevCell.fVals[5];
+      cell.fVals[7] = prevCell.fVals[6];
+      cell.fType |= (prevCell.fType & k1_5) >> 1;
+      cell.fType |= (prevCell.fType & k2_6) << 1;
+      //1, 2 can be taken from the bottom cube (5, 6).
+      cell.fVals[1] = bottCell.fVals[5];
+      cell.fVals[2] = bottCell.fVals[6];
+      cell.fType |= (bottCell.fType & k5_6) >> 4;
+      //5, 6 must be calculated.
+      if((cell.fVals[5] = GetData(i + 1, 0, depth + 1)) <= fIso)
+         cell.fType |= k5;
+      if((cell.fVals[6] = GetData(i + 1, 1, depth + 1)) <= fIso)
+         cell.fType |= k6;
+
+      UInt_t edges = eInt[cell.fType];
+
+      if(!edges)
+         continue;
+      //Take edges 3, 7, 8, 11 from the previous cube (1, 5, 9, 10).
+      if(edges & k3)
+         cell.fIds[3] = prevCell.fIds[1];
+      if(edges & k7)
+         cell.fIds[7] = prevCell.fIds[5];
+      if(edges & k8)
+         cell.fIds[8] = prevCell.fIds[9];
+      if(edges & k11)
+         cell.fIds[11] = prevCell.fIds[10];
+      //Take edges 0, 1, 2 from the bottom cube (4, 5, 6).
+      if(edges & k0)
+         cell.fIds[0] = bottCell.fIds[4];
+      if(edges & k1)
+         cell.fIds[1] = bottCell.fIds[5];
+      if(edges & k2)
+         cell.fIds[2] = bottCell.fIds[6];
+
+      edges &= ~k0_1_2_3_7_8_11;
+
+      if (edges) {
+         const V x = this->fMinX + i * this->fStepX;
+
+         if(edges & k4)
+            SplitEdge(cell, fMesh, 4,  x, this->fMinY, z, fIso);
+         if(edges & k5)
+            SplitEdge(cell, fMesh, 5,  x, this->fMinY, z, fIso);
+         if(edges & k6)
+            SplitEdge(cell, fMesh, 6,  x, this->fMinY, z, fIso);
+         if(edges & k9)
+            SplitEdge(cell, fMesh, 9,  x, this->fMinY, z, fIso);
+         if(edges & k10)
+            SplitEdge(cell, fMesh, 10, x, this->fMinY, z, fIso);
+      }
+
+      ConnectTriangles(cell, fMesh, fEpsilon);
+   }
+}
+
+//______________________________________________________________________
+template<class D, class V>
+void TMeshBuilder<D, V>::BuildCol(UInt_t depth, const SliceType_t *prevSlice,
+                                  SliceType_t *slice)const
+{
+   //nz == depth, nx == 0, ny : [1, H - 1].
+   //Two neighbours - from previous slice ("bottom" cube)
+   //and previous cube in a column.
+   const V z = this->fMinZ + depth * this->fStepZ;
+   const UInt_t w = GetW();
+   const UInt_t h = GetH();
+
+   for (UInt_t i = 1; i < h - 1; ++i) {
+      const CellType_t &left = slice->fCells[(i - 1) * (w - 1)];
+      const CellType_t &bott = prevSlice->fCells[i * (w - 1)];
+      CellType_t &cell = slice->fCells[i * (w - 1)];
+      cell.fType = 0;
+      //Value 0 is not required, only bit.
+      //Take 1, 4, 5 from left cube.
+      cell.fVals[1] = left.fVals[2];
+      cell.fVals[4] = left.fVals[7];
+      cell.fVals[5] = left.fVals[6];
+      cell.fType |= (left.fType & k2_6) >> 1;
+      cell.fType |= (left.fType & k3_7) >> 3;
+      //2, 3 from bottom.
+      cell.fVals[2] = bott.fVals[6];
+      cell.fVals[3] = bott.fVals[7];
+      cell.fType |= (bott.fType & k6_7) >> 4;
+      //Calculate 6, 7.
+      if((cell.fVals[6] = GetData(1, i + 1, depth + 1)) <= fIso)
+         cell.fType |= k6;
+      if((cell.fVals[7] = GetData(0, i + 1, depth + 1)) <= fIso)
+         cell.fType |= k7;
+
+      const UInt_t edges = eInt[cell.fType];
+      if(!edges)
+         continue;
+
+      if(edges & k0)
+         cell.fIds[0] = left.fIds[2];
+      if(edges & k4)
+         cell.fIds[4] = left.fIds[6];
+      if(edges & k8)
+         cell.fIds[8] = left.fIds[11];
+      if(edges & k9)
+         cell.fIds[9] = left.fIds[10];
+
+      if(edges & k1)
+         cell.fIds[1] = bott.fIds[5];
+      if(edges & k2)
+         cell.fIds[2] = bott.fIds[6];
+      if(edges & k3)
+         cell.fIds[3] = bott.fIds[7];
+
+      const V y = this->fMinY + i * this->fStepY;
+      
+      if(edges & k5)
+         SplitEdge(cell, fMesh, 5,  this->fMinX, y, z, fIso);
+      if(edges & k6)
+         SplitEdge(cell, fMesh, 6,  this->fMinX, y, z, fIso);
+      if(edges & k7)
+         SplitEdge(cell, fMesh, 7,  this->fMinX, y, z, fIso);
+      if(edges & k10)
+         SplitEdge(cell, fMesh, 10, this->fMinX, y, z, fIso);
+      if(edges & k11)
+         SplitEdge(cell, fMesh, 11, this->fMinX, y, z, fIso);
+
+      ConnectTriangles(cell, fMesh, fEpsilon);
+   }
+}
+
+//______________________________________________________________________
+template<class D, class V>
+void TMeshBuilder<D, V>::BuildSlice(UInt_t depth, const SliceType_t *prevSlice,
+                                    SliceType_t *slice)const
+{
+   //nz == depth, nx : [1, W - 1], ny : [1, H - 1].
+   //Each cube has 3 neighbours, "bottom" cube from
+   //the previous slice, "left" and "right" from the
+   //current slice.
+   const V z = this->fMinZ + depth * this->fStepZ;
+   const UInt_t h = GetH();
+   const UInt_t w = GetW();
+
+   for (UInt_t i = 1; i < h - 1; ++i) {
+      const V y = this->fMinY + i * this->fStepY;
+      for (UInt_t j = 1; j < w - 1; ++j) {
+         const CellType_t &left = slice->fCells[(i - 1) * (w - 1) + j];
+         const CellType_t &right = slice->fCells[i * (w - 1) + j - 1];
+         const CellType_t &bott = prevSlice->fCells[i * (w - 1) + j];
+         CellType_t &cell = slice->fCells[i * (w - 1) + j];
+         cell.fType = 0;
+
+         cell.fVals[1] = left.fVals[2];
+         cell.fVals[4] = left.fVals[7];
+         cell.fVals[5] = left.fVals[6];
+         cell.fType |= (left.fType & k2_6) >> 1;
+         cell.fType |= (left.fType & k3_7) >> 3;
+
+         cell.fVals[2] = bott.fVals[6];
+         cell.fVals[3] = bott.fVals[7];
+         cell.fType |= (bott.fType & k6_7) >> 4;
+
+         cell.fVals[7] = right.fVals[6];
+         cell.fType |= (right.fType & k6) << 1;
+
+         if ((cell.fVals[6] = GetData(j + 1, i + 1, depth + 1)) <= fIso)
+            cell.fType |= k6;
+
+         const UInt_t edges = eInt[cell.fType];
+         if (!edges)
+            continue;
+
+         if(edges & k0)
+            cell.fIds[0] = left.fIds[2];
+         if(edges & k4)
+            cell.fIds[4] = left.fIds[6];
+         if(edges & k8)
+            cell.fIds[8] = left.fIds[11];
+         if(edges & k9)
+            cell.fIds[9] = left.fIds[10];
+
+         if(edges & k3)
+            cell.fIds[3] = right.fIds[1];
+         if(edges & k7)
+            cell.fIds[7] = right.fIds[5];
+         if(edges & k11)
+            cell.fIds[11] = right.fIds[10];
+
+         if(edges & k1)
+            cell.fIds[1] = bott.fIds[5];
+         if(edges & k2)
+            cell.fIds[2] = bott.fIds[6];
+
+         const V x = this->fMinX + j * this->fStepX;
+         if(edges & k5)
+            SplitEdge(cell, fMesh, 5,  x, y, z, fIso);
+         if(edges & k6)
+            SplitEdge(cell, fMesh, 6,  x, y, z, fIso);
+         if(edges & k10)
+            SplitEdge(cell, fMesh, 10, x, y, z, fIso);
+
+         ConnectTriangles(cell, fMesh, fEpsilon);
+      }
+   }
+}
+
+//______________________________________________________________________
+template<class D, class V>
+void TMeshBuilder<D, V>::BuildNormals()const
+{
+   //Build averaged normals using vertices and
+   //trinagles.
+   typedef std::vector<UInt_t>::size_type size_type;
+   const UInt_t *t;
+   V *p1, *p2, *p3;
+   V v1[3], v2[3], n[3];
+   
+   fMesh->fNorms.assign(fMesh->fVerts.size(), V());
+
+   for (size_type i = 0, e = fMesh->fTris.size() / 3; i < e; ++i) {
+      t  = &fMesh->fTris[i * 3];
+      p1 = &fMesh->fVerts[t[0] * 3];
+      p2 = &fMesh->fVerts[t[1] * 3];
+      p3 = &fMesh->fVerts[t[2] * 3];
+      v1[0] = p2[0] - p1[0];
+      v1[1] = p2[1] - p1[1];
+      v1[2] = p2[2] - p1[2];
+      v2[0] = p3[0] - p1[0];
+      v2[1] = p3[1] - p1[1];
+      v2[2] = p3[2] - p1[2];
+      n[0] = v1[1] * v2[2] - v1[2] * v2[1];
+      n[1] = v1[2] * v2[0] - v1[0] * v2[2];
+      n[2] = v1[0] * v2[1] - v1[1] * v2[0];
+
+      const V len = std::sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]);
+
+      if (len < fEpsilon)//degenerated triangle
+         continue;
+
+      n[0] /= len;
+      n[1] /= len;
+      n[2] /= len;
+      UInt_t ind = t[0] * 3;
+      fMesh->fNorms[ind]     += n[0];
+      fMesh->fNorms[ind + 1] += n[1];
+      fMesh->fNorms[ind + 2] += n[2];
+      ind = t[1] * 3;
+      fMesh->fNorms[ind]     += n[0];
+      fMesh->fNorms[ind + 1] += n[1];
+      fMesh->fNorms[ind + 2] += n[2];
+      ind = t[2] * 3;
+      fMesh->fNorms[ind]     += n[0];
+      fMesh->fNorms[ind + 1] += n[1];
+      fMesh->fNorms[ind + 2] += n[2];
+   }
+
+   for (size_type i = 0, e = fMesh->fNorms.size() / 3; i < e; ++i) {
+      V * nn = &fMesh->fNorms[i * 3];
+      const V len = std::sqrt(nn[0] * nn[0] + nn[1] * nn[1] + nn[2] * nn[2]);
+      if (len < fEpsilon)
+         continue;
+      fMesh->fNorms[i * 3]     /= len;
+      fMesh->fNorms[i * 3 + 1] /= len;
+      fMesh->fNorms[i * 3 + 2] /= len;
+   }
+}
+
+
+namespace {
+
+/////////////////////////////////////////////////////////////////////////
+//****************************TABLES***********************************//
+/////////////////////////////////////////////////////////////////////////
+
+const UInt_t eInt[256] = 
+{
+   0x000, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c, 
+   0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,
+   0x190, 0x099, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c, 
+   0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,
+   0x230, 0x339, 0x033, 0x13a, 0x636, 0x73f, 0x435, 0x53c, 
+   0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,
+   0x3a0, 0x2a9, 0x1a3, 0x0aa, 0x7a6, 0x6af, 0x5a5, 0x4ac, 
+   0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,
+   0x460, 0x569, 0x663, 0x76a, 0x066, 0x16f, 0x265, 0x36c, 
+   0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,
+   0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0x0ff, 0x3f5, 0x2fc, 
+   0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,
+   0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x055, 0x15c, 
+   0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,
+   0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0x0cc, 
+   0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,
+   0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc, 
+   0x0cc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,
+   0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c, 
+   0x15c, 0x055, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,
+   0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc, 
+   0x2fc, 0x3f5, 0x0ff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
+   0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c, 
+   0x36c, 0x265, 0x16f, 0x066, 0x76a, 0x663, 0x569, 0x460,
+   0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac, 
+   0x4ac, 0x5a5, 0x6af, 0x7a6, 0x0aa, 0x1a3, 0x2a9, 0x3a0,
+   0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c, 
+   0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x033, 0x339, 0x230,
+   0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c, 
+   0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x099, 0x190,
+   0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c, 
+   0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x000
+};
+
+const Float_t vOff[8][3] =
+{
+   {0.f, 0.f, 0.f}, {1.f, 0.f, 0.f}, {1.f, 1.f, 0.f},
+   {0.f, 1.f, 0.f}, {0.f, 0.f, 1.f}, {1.f, 0.f, 1.f},
+   {1.f, 1.f, 1.f}, {0.f, 1.f, 1.f}
+};
+
+const UChar_t eConn[12][2] =
+{
+   {0, 1}, {1, 2}, {2, 3}, {3, 0},
+   {4, 5}, {5, 6}, {6, 7}, {7, 4},
+   {0, 4}, {1, 5}, {2, 6}, {3, 7}
+};
+   
+const Float_t eDir[12][3] =
+{
+   { 1.f,  0.f, 0.f}, {0.f,  1.f, 0.f}, {-1.f, 0.f, 0.f},
+   { 0.f, -1.f, 0.f}, {1.f,  0.f, 0.f}, { 0.f, 1.f, 0.f},
+   {-1.f,  0.f, 0.f}, {0.f, -1.f, 0.f}, { 0.f, 0.f, 1.f},
+   { 0.f,  0.f, 1.f}, {0.f,  0.f, 1.f}, { 0.f, 0.f, 1.f}
+};
+
+const Int_t conTbl[256][16] = 
+{
+   {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1},
+   {3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1},
+   {3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1},
+   {3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1},
+   {9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1},
+   {1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1},
+   {9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1},
+   {2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1},
+   {8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1},
+   {9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1},
+   {4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1},
+   {3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1},
+   {1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1},
+   {4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1},
+   {4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1},
+   {9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1},
+   {1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1},
+   {5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1},
+   {2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1},
+   {9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1},
+   {0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1},
+   {2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1},
+   {10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1},
+   {4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1},
+   {5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1},
+   {5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1},
+   {9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1},
+   {0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1},
+   {1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1},
+   {10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1},
+   {8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1},
+   {2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1},
+   {7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1},
+   {9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1},
+   {2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1},
+   {11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1},
+   {9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1},
+   {5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1},
+   {11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1},
+   {11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1},
+   {1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1},
+   {9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1},
+   {5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1},
+   {2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1},
+   {0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1},
+   {5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1},
+   {6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1},
+   {0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1},
+   {3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1},
+   {6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1},
+   {5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1},
+   {1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1},
+   {10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1},
+   {6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1},
+   {1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1},
+   {8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1},
+   {7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1},
+   {3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1},
+   {5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1},
+   {0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1},
+   {9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1},
+   {8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1},
+   {5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1},
+   {0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1},
+   {6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1},
+   {10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1},
+   {10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1},
+   {8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1},
+   {1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1},
+   {3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1},
+   {0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1},
+   {10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1},
+   {0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1},
+   {3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1},
+   {6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1},
+   {9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1},
+   {8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1},
+   {3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1},
+   {6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1},
+   {0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1},
+   {10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1},
+   {10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1},
+   {1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1},
+   {2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1},
+   {7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1},
+   {7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1},
+   {2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1},
+   {1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1},
+   {11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1},
+   {8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1},
+   {0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1},
+   {7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1},
+   {10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1},
+   {2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1},
+   {6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1},
+   {7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1},
+   {2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1},
+   {1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1},
+   {10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1},
+   {10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1},
+   {0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1},
+   {7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1},
+   {6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1},
+   {8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1},
+   {9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1},
+   {6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1},
+   {1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1},
+   {4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1},
+   {10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1},
+   {8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1},
+   {0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1},
+   {1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1},
+   {8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1},
+   {10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1},
+   {4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1},
+   {10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1},
+   {5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1},
+   {11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1},
+   {9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1},
+   {6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1},
+   {7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1},
+   {3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1},
+   {7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1},
+   {9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1},
+   {3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1},
+   {6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1},
+   {9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1},
+   {1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1},
+   {4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1},
+   {7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1},
+   {6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1},
+   {3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1},
+   {0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1},
+   {6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1},
+   {1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1},
+   {0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1},
+   {11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1},
+   {6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1},
+   {5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1},
+   {9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1},
+   {1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1},
+   {1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1},
+   {10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1},
+   {0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1},
+   {5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1},
+   {10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1},
+   {11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1},
+   {0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1},
+   {9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1},
+   {7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1},
+   {2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1},
+   {8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1},
+   {9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1},
+   {9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1},
+   {1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1},
+   {9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1},
+   {9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1},
+   {5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1},
+   {0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1},
+   {10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1},
+   {2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1},
+   {0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1},
+   {0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1},
+   {9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1},
+   {5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1},
+   {3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1},
+   {5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1},
+   {8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1},
+   {0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1},
+   {9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1},
+   {0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1},
+   {1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1},
+   {3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1},
+   {4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1},
+   {9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1},
+   {11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1},
+   {11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1},
+   {2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1},
+   {9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1},
+   {3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1},
+   {1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1},
+   {4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1},
+   {4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1},
+   {0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1},
+   {3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1},
+   {3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1},
+   {0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1},
+   {9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1},
+   {1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+   {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}
+};
+
+}//unnamed namespace
+
+
+template class TMeshBuilder<TH3C, Float_t>;
+template class TMeshBuilder<TH3S, Float_t>;
+template class TMeshBuilder<TH3I, Float_t>;
+template class TMeshBuilder<TH3F, Float_t>;
+template class TMeshBuilder<TH3D, Float_t>;
+template class TMeshBuilder<TF3, Double_t>;
+
+}//namespace Mc
+}//namespace Rgl
diff --git a/graf3d/gl/src/TGLOrthoCamera.cxx b/graf3d/gl/src/TGLOrthoCamera.cxx
index e78a9eb..898b995 100644
--- a/graf3d/gl/src/TGLOrthoCamera.cxx
+++ b/graf3d/gl/src/TGLOrthoCamera.cxx
@@ -191,11 +191,7 @@ Bool_t TGLOrthoCamera::Truck(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod
    xstep = AdjustDelta(xstep, 1.0, mod1, mod2);
    ystep = AdjustDelta(ystep, 1.0, mod1, mod2);
 
-   fCamTrans.MoveLF(2, -xstep);
-   fCamTrans.MoveLF(3, -ystep);
-
-   IncTimeStamp();
-   return kTRUE;
+   return Truck(-xstep, -ystep);
 }
 
 //______________________________________________________________________________
diff --git a/graf3d/gl/src/TGLPerspectiveCamera.cxx b/graf3d/gl/src/TGLPerspectiveCamera.cxx
index d89d5f6..b582caf 100644
--- a/graf3d/gl/src/TGLPerspectiveCamera.cxx
+++ b/graf3d/gl/src/TGLPerspectiveCamera.cxx
@@ -129,11 +129,7 @@ Bool_t TGLPerspectiveCamera::Truck(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool
    xstep = AdjustDelta(xstep, 1.0, mod1, mod2);
    ystep = AdjustDelta(ystep, 1.0, mod1, mod2);
 
-   fCamTrans.MoveLF(2, -xstep);
-   fCamTrans.MoveLF(3, -ystep);
-
-   IncTimeStamp();
-   return kTRUE;
+   return Truck(-xstep, -ystep);
 }
 
 //______________________________________________________________________________
diff --git a/graf3d/gl/src/TGLRnrCtx.cxx b/graf3d/gl/src/TGLRnrCtx.cxx
index c373ae8..95efccf 100644
--- a/graf3d/gl/src/TGLRnrCtx.cxx
+++ b/graf3d/gl/src/TGLRnrCtx.cxx
@@ -312,7 +312,7 @@ void TGLRnrCtx::RegisterFont(Int_t size, Int_t file, Int_t mode, TGLFont& out)
 }
 
 //______________________________________________________________________
-void TGLRnrCtx::RegisterFont(Int_t size, const Text_t* name, Int_t mode, TGLFont& out)
+void TGLRnrCtx::RegisterFont(Int_t size, const char* name, Int_t mode, TGLFont& out)
 {
    // Get font in the GL rendering context.
 
diff --git a/graf3d/gl/src/TGLSAViewer.cxx b/graf3d/gl/src/TGLSAViewer.cxx
index 8585286..36238e0 100644
--- a/graf3d/gl/src/TGLSAViewer.cxx
+++ b/graf3d/gl/src/TGLSAViewer.cxx
@@ -150,6 +150,7 @@ const Int_t TGLSAViewer::fgInitH = 670;
 const char *gGLSaveAsTypes[] = {"Encapsulated PostScript", "*.eps",
                                 "PDF",                     "*.pdf",
                                 "GIF",                     "*.gif",
+                                "Animated GIF",            "*.gif+",
                                 "JPEG",                    "*.jpg",
                                 "PNG",                     "*.png",
                                 0, 0};
@@ -274,6 +275,8 @@ void TGLSAViewer::CreateGLWidget()
       return;
    }
 
+   ResetInitGL();
+
    fGLWidget = TGLWidget::Create(fRightVerticalFrame, kTRUE, kTRUE, 0, 10, 10);
    fGLWidget->SetEventHandler(fEventHandler);
 
@@ -294,7 +297,10 @@ void TGLSAViewer::DestroyGLWidget()
       return;
    }
 
+   ResetInitGL();
+
    fGLWidget->UnmapWindow();
+   fGLWidget->SetEventHandler(0);
 
    fRightVerticalFrame->RemoveFrame(fGLWidget);
    fGLWidget->DeleteWindow();
@@ -541,8 +547,21 @@ Bool_t TGLSAViewer::ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t)
                fOverwrite = fi.fOverwrite;
 
                TString file = fi.fFilename;
-               if (ft.Index(".") != kNPOS)
+               Bool_t  match = kFALSE;
+               const char** fin = gGLSaveAsTypes; ++fin;
+               while (*fin != 0)
+               {
+                  if (file.EndsWith(*fin + 1))
+                  {
+                     match = kTRUE;
+                     break;
+                  }
+                  fin += 2;
+               }
+               if ( ! match)
+               {
                   file += ft(ft.Index("."), ft.Length());
+               }
                SavePicture(file);
             }
             break;
@@ -631,6 +650,9 @@ void TGLSAViewer::ToggleOrthoRotate()
    fOrthoXOYCamera.SetEnableRotate(state);
    fOrthoXOZCamera.SetEnableRotate(state);
    fOrthoZOYCamera.SetEnableRotate(state);
+   fOrthoXnOYCamera.SetEnableRotate(state);
+   fOrthoXnOZCamera.SetEnableRotate(state);
+   fOrthoZnOYCamera.SetEnableRotate(state);
 }
 
 //______________________________________________________________________________
diff --git a/graf3d/gl/src/TGLScenePad.cxx b/graf3d/gl/src/TGLScenePad.cxx
index 7444102..a00f232 100644
--- a/graf3d/gl/src/TGLScenePad.cxx
+++ b/graf3d/gl/src/TGLScenePad.cxx
@@ -32,13 +32,15 @@
 #include "TMath.h"
 
 #include "TH2.h"         // Preliminary support for GL plot painters
+#include "TH3.h"         // Preliminary support for GL plot painters
 #include "TH2GL.h"
 #include "TF2.h"
 #include "TF2GL.h"
 #include "TGLParametric.h"
 #include "TGLParametricEquationGL.h"
 
-//______________________________________________________________________
+
+//______________________________________________________________________________
 // TGLScenePad
 //
 // Implements VirtualViewer3D interface and fills the base-class
@@ -47,7 +49,8 @@
 
 ClassImp(TGLScenePad)
 
-//______________________________________________________________________
+
+//______________________________________________________________________________
 TGLScenePad::TGLScenePad(TVirtualPad* pad) :
    TVirtualViewer3D(),
    TGLScene(),
@@ -65,9 +68,10 @@ TGLScenePad::TGLScenePad(TVirtualPad* pad) :
 }
 
 
-/**************************************************************************/
+/******************************************************************************/
 // Histo import and Sub-pad traversal
-/**************************************************************************/
+/******************************************************************************/
+
 
 //______________________________________________________________________________
 void TGLScenePad::AddHistoPhysical(TGLLogicalShape* log)
@@ -90,6 +94,19 @@ void TGLScenePad::AddHistoPhysical(TGLLogicalShape* log)
    Double_t ty = gPad->GetAbsYlowNDC() * how + lh;
    TGLVector3 transVec(0, ty, tx); // For viewer convention (starts looking along -x).
 
+   // XXXX plots no longer centered at 0. Or they never were?
+   // Impossible to translate and scale them as they should be, it
+   // seems. This requers further investigation, eventually.
+   //
+   // bb.Dump();
+   // printf("lm=%f, size=%f, scale=%f, tx=%f, ty=%f\n",
+   //        lm, size, scale, tx, ty);
+   //
+   // TGLVector3 c(bb.Center().Arr());
+   // c.Negate();
+   // c.Dump();
+   // mat.Translate(c);
+
    TGLMatrix mat;
    mat.Scale(scaleVec);
    mat.Translate(transVec);
@@ -100,8 +117,12 @@ void TGLScenePad::AddHistoPhysical(TGLLogicalShape* log)
    TGLPhysicalShape* phys = new TGLPhysicalShape
       (fNextInternalPID++, *log, mat, false, rgba);
    AdoptPhysical(*phys);
+
+   // Part of XXXX above.
+   // phys->BoundingBox().Dump();
 }
 
+
 //______________________________________________________________________________
 void TGLScenePad::SubPadPaint(TVirtualPad* pad)
 {
@@ -124,6 +145,7 @@ void TGLScenePad::SubPadPaint(TVirtualPad* pad)
    gPad = padsav;
 }
 
+
 //______________________________________________________________________________
 void TGLScenePad::ObjectPaint(TObject* obj, Option_t* opt)
 {
@@ -131,12 +153,13 @@ void TGLScenePad::ObjectPaint(TObject* obj, Option_t* opt)
    // Special handling of 2D/3D histograms to activate Timur's
    // histo-painters.
 
-   if (obj->InheritsFrom(TAtt3D::Class()))
+   if (obj->InheritsFrom(TAtt3D::Class()) && !obj->InheritsFrom(TH3::Class()))
    {
+      //Since TH3's derived from TAtt3D, it should be checked here.
       //printf("normal-painting %s / %s\n", obj->GetName(), obj->ClassName());
       obj->Paint(opt);
    }
-   else if (obj->InheritsFrom(TH2::Class()))
+   else if (obj->InheritsFrom(TH2::Class()) || obj->InheritsFrom(TH3::Class()))
    {
       // printf("histo 2d\n");
       TGLObject* log = new TH2GL();
@@ -176,6 +199,7 @@ void TGLScenePad::ObjectPaint(TObject* obj, Option_t* opt)
    }
 }
 
+
 //______________________________________________________________________________
 void TGLScenePad::PadPaintFromViewer(TGLViewer* viewer)
 {
@@ -190,6 +214,7 @@ void TGLScenePad::PadPaintFromViewer(TGLViewer* viewer)
    fSmartRefresh = sr;
 }
 
+
 //______________________________________________________________________________
 void TGLScenePad::PadPaint(TVirtualPad* pad)
 {
@@ -210,9 +235,10 @@ void TGLScenePad::PadPaint(TVirtualPad* pad)
 }
 
 
-/**************************************************************************/
+/******************************************************************************/
 // VV3D
-/**************************************************************************/
+/******************************************************************************/
+
 
 //______________________________________________________________________________
 void TGLScenePad::BeginScene()
@@ -268,6 +294,7 @@ void TGLScenePad::BeginScene()
    }
 }
 
+
 //______________________________________________________________________________
 void TGLScenePad::EndScene()
 {
@@ -287,6 +314,7 @@ void TGLScenePad::EndScene()
    }
 }
 
+
 //______________________________________________________________________________
 Int_t TGLScenePad::AddObject(const TBuffer3D& buffer, Bool_t* addChildren)
 {
@@ -300,6 +328,7 @@ Int_t TGLScenePad::AddObject(const TBuffer3D& buffer, Bool_t* addChildren)
    return sections;
 }
 
+
 //______________________________________________________________________________
 Int_t TGLScenePad::AddObject(UInt_t physicalID, const TBuffer3D& buffer, Bool_t* addChildren)
 {
@@ -440,6 +469,7 @@ Int_t TGLScenePad::AddObject(UInt_t physicalID, const TBuffer3D& buffer, Bool_t*
    return TBuffer3D::kNone;
 }
 
+
 //______________________________________________________________________________
 Bool_t TGLScenePad::OpenComposite(const TBuffer3D& buffer, Bool_t* addChildren)
 {
@@ -465,6 +495,7 @@ Bool_t TGLScenePad::OpenComposite(const TBuffer3D& buffer, Bool_t* addChildren)
    }
 }
 
+
 //______________________________________________________________________________
 void TGLScenePad::CloseComposite()
 {
@@ -486,6 +517,7 @@ void TGLScenePad::CloseComposite()
    }
 }
 
+
 //______________________________________________________________________________
 void TGLScenePad::AddCompositeOp(UInt_t operation)
 {
@@ -499,6 +531,7 @@ void TGLScenePad::AddCompositeOp(UInt_t operation)
 
 // Protected methods
 
+
 //______________________________________________________________________________
 Int_t TGLScenePad::ValidateObjectBuffer(const TBuffer3D& buffer, Bool_t includeRaw) const
 {
@@ -571,6 +604,7 @@ Int_t TGLScenePad::ValidateObjectBuffer(const TBuffer3D& buffer, Bool_t includeR
    }
 }
 
+
 //______________________________________________________________________________
 TGLLogicalShape* TGLScenePad::CreateNewLogical(const TBuffer3D& buffer) const
 {
@@ -644,6 +678,7 @@ TGLLogicalShape* TGLScenePad::CreateNewLogical(const TBuffer3D& buffer) const
    return newLogical;
 }
 
+
 //______________________________________________________________________________
 TGLPhysicalShape*
 TGLScenePad::CreateNewPhysical(UInt_t ID, const TBuffer3D& buffer,
@@ -663,6 +698,7 @@ TGLScenePad::CreateNewPhysical(UInt_t ID, const TBuffer3D& buffer,
                                buffer.fReflection, rgba);
 }
 
+
 //______________________________________________________________________________
 RootCsg::TBaseMesh* TGLScenePad::BuildComposite()
 {
@@ -689,6 +725,7 @@ RootCsg::TBaseMesh* TGLScenePad::BuildComposite()
    } else return fCSTokens[fCSLevel++].second;
 }
 
+
 //______________________________________________________________________________
 TGLLogicalShape* TGLScenePad::AttemptDirectRenderer(TObject* id)
 {
diff --git a/graf3d/gl/src/TGLTF3Painter.cxx b/graf3d/gl/src/TGLTF3Painter.cxx
index eb5e8f9..07aea3d 100644
--- a/graf3d/gl/src/TGLTF3Painter.cxx
+++ b/graf3d/gl/src/TGLTF3Painter.cxx
@@ -1,3 +1,5 @@
+#include <typeinfo>
+
 #include "TVirtualGL.h"
 #include "KeySymbols.h"
 #include "TVirtualX.h"
@@ -6,23 +8,194 @@
 #include "TROOT.h"
 #include "TColor.h"
 #include "TMath.h"
-#include "TH1.h"
+#include "TH3.h"
 #include "TF3.h"
 
+#include "TGLMarchingCubes.h"
 #include "TGLOrthoCamera.h"
 #include "TGLTF3Painter.h"
 #include "TGLIncludes.h"
 
+namespace {
+
+/*
+Auxilary functions to draw iso-meshes.
+*/
+//______________________________________________________________________________
+template<class V>
+void DrawMesh(GLenum type, const std::vector<V> &vs, const std::vector<V> &ns, 
+              const std::vector<UInt_t> &ts)
+{
+   //Surface with material and lighting.
+   glEnableClientState(GL_VERTEX_ARRAY);
+   glEnableClientState(GL_NORMAL_ARRAY);
+   glVertexPointer(3, type, 0, &vs[0]);
+   glNormalPointer(type, 0, &ns[0]);
+   glDrawElements(GL_TRIANGLES, ts.size(), GL_UNSIGNED_INT, &ts[0]);
+   glDisableClientState(GL_NORMAL_ARRAY);
+   glDisableClientState(GL_VERTEX_ARRAY);
+}
+
+//______________________________________________________________________________
+template<class V>
+void DrawMesh(GLenum type, const std::vector<V> &vs, const std::vector<UInt_t> &ts)
+{
+   //Only vertices, no normal (no lighting and material).
+   glEnableClientState(GL_VERTEX_ARRAY);
+   glVertexPointer(3, type, 0, &vs[0]);
+   glDrawElements(GL_TRIANGLES, ts.size(), GL_UNSIGNED_INT, &ts[0]);
+   glDisableClientState(GL_VERTEX_ARRAY);
+}
+
+//______________________________________________________________________________
+template<class V, class GLN, class GLV>
+void DrawMesh(GLN normal3, GLV vertex3, const std::vector<V> &vs, 
+              const std::vector<V> &ns, const std::vector<UInt_t> &ts, 
+              const TGLBoxCut &box)
+{
+   //Mesh with cut.
+   //Material and lighting are enabled.
+   glBegin(GL_TRIANGLES);
+
+   for (UInt_t i = 0, e = ts.size() / 3; i < e; ++i) {
+      const UInt_t * t = &ts[i * 3];
+      if (box.IsInCut(&vs[t[0] * 3]))
+         continue;
+      if (box.IsInCut(&vs[t[1] * 3]))
+         continue;
+      if (box.IsInCut(&vs[t[2] * 3]))
+         continue;
+
+      normal3(&ns[t[0] * 3]);
+      vertex3(&vs[t[0] * 3]);
+      
+      normal3(&ns[t[1] * 3]);
+      vertex3(&vs[t[1] * 3]);
+      
+      normal3(&ns[t[2] * 3]);
+      vertex3(&vs[t[2] * 3]);
+   }
+
+   glEnd();
+}
+
+//______________________________________________________________________________
+template<class V, class GLV>
+void DrawMesh(GLV vertex3, const std::vector<V> &vs, const std::vector<UInt_t> &ts, 
+              const TGLBoxCut &box)
+{
+   //Mesh with cut.
+   //No material and lighting.
+   glBegin(GL_TRIANGLES);
+
+   for (UInt_t i = 0, e = ts.size() / 3; i < e; ++i) {
+      const UInt_t * t = &ts[i * 3];
+      if (box.IsInCut(&vs[t[0] * 3]))
+         continue;
+      if (box.IsInCut(&vs[t[1] * 3]))
+         continue;
+      if (box.IsInCut(&vs[t[2] * 3]))
+         continue;
+
+      vertex3(&vs[t[0] * 3]);
+      vertex3(&vs[t[1] * 3]);
+      vertex3(&vs[t[2] * 3]);
+   }
+
+   glEnd();
+}
+
+//______________________________________________________________________________
+void GetColor(Double_t *rfColor, const Double_t *n)
+{
+   //GetColor generates a color from a given normal
+   const Double_t x = n[0];
+   const Double_t y = n[1];
+   const Double_t z = n[2];
+   rfColor[0] = (x > 0. ? x : 0.) + (y < 0. ? -0.5 * y : 0.) + (z < 0. ? -0.5 * z : 0.);
+   rfColor[1] = (y > 0. ? y : 0.) + (z < 0. ? -0.5 * z : 0.) + (x < 0. ? -0.5 * x : 0.);
+   rfColor[2] = (z > 0. ? z : 0.) + (x < 0. ? -0.5 * x : 0.) + (y < 0. ? -0.5 * y : 0.);
+}
+
+//______________________________________________________________________________
+void DrawMapleMesh(const std::vector<Double_t> &vs, const std::vector<Double_t> &ns,
+                   const std::vector<UInt_t> &ts)
+{
+   //Colored mesh with lighting disabled.
+   Double_t color[] = {0., 0., 0., 0.15};
+
+   glBegin(GL_TRIANGLES);
+
+   for (UInt_t i = 0, e = ts.size() / 3; i < e; ++i) {
+      const UInt_t *t = &ts[i * 3];
+      const Double_t * n = &ns[t[0] * 3];
+      //
+      GetColor(color, n);
+      glColor4dv(color);
+      glVertex3dv(&vs[t[0] * 3]);
+      //
+      n = &ns[t[1] * 3];
+      GetColor(color, n);
+      glColor4dv(color);
+      glVertex3dv(&vs[t[1] * 3]);
+      //
+      n = &ns[t[2] * 3];
+      GetColor(color, n);
+      glColor4dv(color);
+      glVertex3dv(&vs[t[2] * 3]);
+   }
+
+   glEnd();
+}
+
+void DrawMapleMesh(const std::vector<Double_t> &vs, const std::vector<Double_t> &ns,
+                   const std::vector<UInt_t> &ts, const TGLBoxCut & box)
+{
+   //Colored mesh with cut and disabled lighting.
+   Double_t color[] = {0., 0., 0., 0.15};
+
+   glBegin(GL_TRIANGLES);
+
+   for (UInt_t i = 0, e = ts.size() / 3; i < e; ++i) {
+      const UInt_t *t = &ts[i * 3];
+      if (box.IsInCut(&vs[t[0] * 3]))
+         continue;
+      if (box.IsInCut(&vs[t[1] * 3]))
+         continue;
+      if (box.IsInCut(&vs[t[2] * 3]))
+         continue;
+      const Double_t * n = &ns[t[0] * 3];
+      //
+      GetColor(color, n);
+      glColor4dv(color);
+      glVertex3dv(&vs[t[0] * 3]);
+      //
+      n = &ns[t[1] * 3];
+      GetColor(color, n);
+      glColor4dv(color);
+      glVertex3dv(&vs[t[1] * 3]);
+      //
+      n = &ns[t[2] * 3];
+      GetColor(color, n);
+      glColor4dv(color);
+      glVertex3dv(&vs[t[2] * 3]);
+   }
+
+   glEnd();
+}
+
+}//Unnamed namespace.
+
 //______________________________________________________________________________
 //
-// Plot-painter implementing rendering of TF3 functions.
+// Plot-painter for TF3 functions.
 
 ClassImp(TGLTF3Painter)
 
 //______________________________________________________________________________
 TGLTF3Painter::TGLTF3Painter(TF3 *fun, TH1 *hist, TGLOrthoCamera *camera,
                              TGLPlotCoordinates *coord, TGLPaintDevice *dev) :
-   TGLPlotPainter(hist, camera, coord, dev, kTRUE, kTRUE, kTRUE),
+   TGLPlotPainter(hist, camera, coord, dev, kFALSE, kFALSE, kFALSE),
    fStyle(kDefault),
    fF3(fun),
    fXOZSlice("XOZ", (TH3 *)hist, fun, coord, &fBackBox, TGLTH3Slice::kXOZ),
@@ -40,13 +213,6 @@ char *TGLTF3Painter::GetPlotInfo(Int_t /*px*/, Int_t /*py*/)
    return mess;
 }
 
-namespace {
-   void MarchingCube(Double_t x, Double_t y, Double_t z, Double_t stepX, Double_t stepY,
-                     Double_t stepZ, Double_t scaleX, Double_t scaleY, Double_t scaleZ,
-                     const TF3 *fun, std::vector<TGLTF3Painter::TriFace_t> &mesh,
-                     Rgl::Range_t &minMax);
-}
-
 //______________________________________________________________________________
 Bool_t TGLTF3Painter::InitGeometry()
 {
@@ -60,40 +226,23 @@ Bool_t TGLTF3Painter::InitGeometry()
    if (fCamera) fCamera->SetViewVolume(fBackBox.Get3DBox());
 
    //Build mesh for TF3 surface
-   fMesh.clear();
-
-   const Int_t nX = fHist->GetNbinsX();
-   const Int_t nY = fHist->GetNbinsY();
-   const Int_t nZ = fHist->GetNbinsZ();
-
-   const Double_t xMin = fXAxis->GetBinLowEdge(fXAxis->GetFirst());
-   const Double_t xStep = (fXAxis->GetBinUpEdge(fXAxis->GetLast()) - xMin) / nX;
-   const Double_t yMin = fYAxis->GetBinLowEdge(fYAxis->GetFirst());
-   const Double_t yStep = (fYAxis->GetBinUpEdge(fYAxis->GetLast()) - yMin) / nY;
-   const Double_t zMin = fZAxis->GetBinLowEdge(fZAxis->GetFirst());
-   const Double_t zStep = (fZAxis->GetBinUpEdge(fZAxis->GetLast()) - zMin) / nZ;
-
-   Rgl::Range_t minMax;
-   minMax.first  = fF3->Eval(xMin, yMin, zMin);
-   minMax.second = minMax.first;
-
-   for (Int_t i = 0; i < nX; ++i) {
-      for (Int_t j= 0; j < nY; ++j) {
-         for (Int_t k = 0; k < nZ; ++k) {
-            MarchingCube(xMin + i * xStep, yMin + j * yStep, zMin + k * zStep,
-                         xStep, yStep, zStep, fCoord->GetXScale(), fCoord->GetYScale(),
-                         fCoord->GetZScale(), fF3, fMesh, minMax);
-         }
-      }
-   }
-
-   //Not sure about this part :(
-   minMax.second = 0.001 * minMax.first;
-
-   fXOZSlice.SetMinMax(minMax);
-   fYOZSlice.SetMinMax(minMax);
-   fXOYSlice.SetMinMax(minMax);
-
+   fMesh.ClearMesh();
+
+   Rgl::Mc::TMeshBuilder<TF3, Double_t> builder(kFALSE);//no averaged normals.
+   //Set grid parameters.
+   Rgl::Mc::TGridGeometry<Double_t> geom;
+   geom.fMinX  = fXAxis->GetBinLowEdge(fXAxis->GetFirst());
+   geom.fStepX = (fXAxis->GetBinUpEdge(fXAxis->GetLast()) - geom.fMinX) / (fHist->GetNbinsX());
+   geom.fMinY  = fYAxis->GetBinLowEdge(fYAxis->GetFirst());
+   geom.fStepY = (fYAxis->GetBinUpEdge(fYAxis->GetLast()) - geom.fMinY) / (fHist->GetNbinsY());
+   geom.fMinZ  = fZAxis->GetBinLowEdge(fZAxis->GetFirst());
+   geom.fStepZ = (fZAxis->GetBinUpEdge(fZAxis->GetLast()) - geom.fMinZ) / (fHist->GetNbinsZ());
+   //Scale grid parameters.
+   geom.fMinX *= fCoord->GetXScale(), geom.fStepX *= fCoord->GetXScale();
+   geom.fMinY *= fCoord->GetYScale(), geom.fStepY *= fCoord->GetYScale();
+   geom.fMinZ *= fCoord->GetZScale(), geom.fStepZ *= fCoord->GetZScale();
+
+   builder.BuildMesh(fF3, geom, &fMesh, 0.2);
 
    if (fCoord->Modified()) {
       fUpdateSelection = kTRUE;
@@ -104,7 +253,6 @@ Bool_t TGLTF3Painter::InitGeometry()
       fCoord->ResetModified();
    }
 
-
    return kTRUE;
 }
 
@@ -123,6 +271,7 @@ void TGLTF3Painter::Pan(Int_t px, Int_t py)
 {
    //User's moving mouse cursor, with middle mouse button pressed (for pad).
    //Calculate 3d shift related to 2d mouse movement.
+   //Slicing is disabled (since somebody has broken it).
    if (!MakeGLContextCurrent())
       return;
 
@@ -133,12 +282,13 @@ void TGLTF3Painter::Pan(Int_t px, Int_t py)
       //Possibly, move box here
       py = fCamera->GetHeight() - py;
       if (!fHighColor) {
-         if (fBoxCut.IsActive() && (fSelectedPart >= kXAxis && fSelectedPart <= kZAxis))
+         if (fBoxCut.IsActive() && (fSelectedPart >= kXAxis && fSelectedPart <= kZAxis)) {
             fBoxCut.MoveBox(px, py, fSelectedPart);
-         else
-            MoveSection(px, py);
+         } else {
+            //MoveSection(px, py);
+	 }
       } else {
-         MoveSection(px, py);
+         //MoveSection(px, py);
       }
    }
 
@@ -183,7 +333,7 @@ void TGLTF3Painter::ProcessEvent(Int_t event, Int_t /*px*/, Int_t py)
 }
 
 //______________________________________________________________________________
-void TGLTF3Painter::InitGL()const
+void TGLTF3Painter::InitGL() const
 {
    //Initialize OpenGL state variables.
    glEnable(GL_LIGHTING);
@@ -193,183 +343,109 @@ void TGLTF3Painter::InitGL()const
    glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE);
 }
 
-namespace {
-   void GetColor(Double_t *color, const TGLVector3 &normal);
+//______________________________________________________________________________
+void TGLTF3Painter::DrawToSelectionBuffer() const
+{
+   //Draw triangles, no normals, no lighting.
+   Rgl::ObjectIDToColor(fSelectionBase, fHighColor);
+
+   if (!fBoxCut.IsActive())
+      DrawMesh(GL_DOUBLE, fMesh.fVerts, fMesh.fTris);
+   else
+      DrawMesh(&glVertex3dv, fMesh.fVerts, fMesh.fTris, fBoxCut);
 }
 
 //______________________________________________________________________________
-void TGLTF3Painter::DrawPlot()const
+void TGLTF3Painter::DrawDefaultPlot() const
 {
-   //Draw mesh.
-   fBackBox.DrawBox(fSelectedPart, fSelectionPass, fZLevels, fHighColor);
-   DrawSections();
-
-   if (!fSelectionPass && HasSections() && fStyle < kMaple2) {
-      //Surface is semi-transparent during dynamic profiling.
-      //Having several complex nested surfaces, it's not easy
-      //(possible?) to implement correct and _efficient_ transparency
-      //drawing. So, artefacts are possbile.
+   //Surface with material properties and lighting.
+   if (HasSections()) {
       glEnable(GL_BLEND);
       glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
       glDepthMask(GL_FALSE);
    }
 
-   //Draw TF3 surface
-   if (!fSelectionPass)
-      fStyle > kDefault ? glDisable(GL_LIGHTING) : SetSurfaceColor();//[0
-
-   if (fStyle == kMaple1) {
-      glEnable(GL_POLYGON_OFFSET_FILL);//[1
-      glPolygonOffset(1.f, 1.f);
-   } else if (fStyle == kMaple2)
-      glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);//[2
+   SetSurfaceColor();
 
    if (!fBoxCut.IsActive()) {
-      glBegin(GL_TRIANGLES);
-
-      Double_t color[] = {0., 0., 0., 0.15};
-
-      if (!fSelectionPass) {
-         for (UInt_t i = 0, e = fMesh.size(); i < e; ++i) {
-            glNormal3dv(fMesh[i].fNormals[0].CArr());
-            GetColor(color, fMesh[i].fNormals[0]);
-            glColor4dv(color);
-            glVertex3dv(fMesh[i].fXYZ[0].CArr());
-            glNormal3dv(fMesh[i].fNormals[1].CArr());
-            GetColor(color, fMesh[i].fNormals[1]);
-            glColor4dv(color);
-            glVertex3dv(fMesh[i].fXYZ[1].CArr());
-            glNormal3dv(fMesh[i].fNormals[2].CArr());
-            GetColor(color, fMesh[i].fNormals[2]);
-            glColor4dv(color);
-            glVertex3dv(fMesh[i].fXYZ[2].CArr());
-         }
-      } else {
-         Rgl::ObjectIDToColor(fSelectionBase, fHighColor);
-         for (UInt_t i = 0, e = fMesh.size(); i < e; ++i) {
-            glVertex3dv(fMesh[i].fXYZ[0].CArr());
-            glVertex3dv(fMesh[i].fXYZ[1].CArr());
-            glVertex3dv(fMesh[i].fXYZ[2].CArr());
-         }
-      }
-
-      glEnd();
+      DrawMesh(GL_DOUBLE, fMesh.fVerts, fMesh.fNorms, fMesh.fTris);
+   } else {
+      DrawMesh(&glNormal3dv, &glVertex3dv, fMesh.fVerts, fMesh.fNorms, 
+               fMesh.fTris, fBoxCut);
+   }
 
-      if (fStyle == kMaple1 && !fSelectionPass) {
-         glDisable(GL_POLYGON_OFFSET_FILL);//1]
-         glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);//[3
-         glColor4d(0., 0., 0., 0.25);
+   if (HasSections()) {
+      glDisable(GL_BLEND);
+      glDepthMask(GL_TRUE);
+   }
+}
 
-         glBegin(GL_TRIANGLES);
+//______________________________________________________________________________
+void TGLTF3Painter::DrawMaplePlot() const
+{
+   //Colored surface, without lighting and
+   //material properties.
+   const TGLDisableGuard lightGuard(GL_LIGHTING);
 
-         for (UInt_t i = 0, e = fMesh.size(); i < e; ++i) {
-            glVertex3dv(fMesh[i].fXYZ[0].CArr());
-            glVertex3dv(fMesh[i].fXYZ[1].CArr());
-            glVertex3dv(fMesh[i].fXYZ[2].CArr());
-         }
+   if (HasSections() && fStyle < kMaple2) {
+      glEnable(GL_BLEND);
+      glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+      glDepthMask(GL_FALSE);
+   }
 
-         glEnd();
-         glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);//3]
-      } else if (fStyle == kMaple2)
-         glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);//2]
+   if (fStyle == kMaple1) {//Shaded polygons and outlines.
+      glEnable(GL_POLYGON_OFFSET_FILL);//[1
+      glPolygonOffset(1.f, 1.f);
+   } else if (fStyle == kMaple2)//Colored outlines only.
+      glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);//[2
 
-      if (fStyle > kDefault && !fSelectionPass)
-         glEnable(GL_LIGHTING); //0]
-   } else {
-      glBegin(GL_TRIANGLES);
-
-      //TGLVector3 color;
-      Double_t color[] = {0., 0., 0., 0.15};
-
-      if (!fSelectionPass) {
-         for (UInt_t i = 0, e = fMesh.size(); i < e; ++i) {
-            const TriFace_t &tri = fMesh[i];
-            const Double_t xMin = TMath::Min(TMath::Min(tri.fXYZ[0].X(), tri.fXYZ[1].X()), tri.fXYZ[2].X());
-            const Double_t xMax = TMath::Max(TMath::Max(tri.fXYZ[0].X(), tri.fXYZ[1].X()), tri.fXYZ[2].X());
-            const Double_t yMin = TMath::Min(TMath::Min(tri.fXYZ[0].Y(), tri.fXYZ[1].Y()), tri.fXYZ[2].Y());
-            const Double_t yMax = TMath::Max(TMath::Max(tri.fXYZ[0].Y(), tri.fXYZ[1].Y()), tri.fXYZ[2].Y());
-            const Double_t zMin = TMath::Min(TMath::Min(tri.fXYZ[0].Z(), tri.fXYZ[1].Z()), tri.fXYZ[2].Z());
-            const Double_t zMax = TMath::Max(TMath::Max(tri.fXYZ[0].Z(), tri.fXYZ[1].Z()), tri.fXYZ[2].Z());
-
-            if (fBoxCut.IsInCut(xMin, xMax, yMin, yMax, zMin, zMax))
-               continue;
-
-            glNormal3dv(tri.fNormals[0].CArr());
-            GetColor(color, tri.fNormals[0]);
-            glColor4dv(color);
-            glVertex3dv(tri.fXYZ[0].CArr());
-            glNormal3dv(tri.fNormals[1].CArr());
-            GetColor(color, tri.fNormals[1]);
-            glColor4dv(color);
-            glVertex3dv(tri.fXYZ[1].CArr());
-            glNormal3dv(tri.fNormals[2].CArr());
-            GetColor(color, tri.fNormals[2]);
-            glColor4dv(color);
-            glVertex3dv(tri.fXYZ[2].CArr());
-         }
-      } else {
-         Rgl::ObjectIDToColor(fSelectionBase, fHighColor);
-         for (UInt_t i = 0, e = fMesh.size(); i < e; ++i) {
-            const TriFace_t &tri = fMesh[i];
-            const Double_t xMin = TMath::Min(TMath::Min(tri.fXYZ[0].X(), tri.fXYZ[1].X()), tri.fXYZ[2].X());
-            const Double_t xMax = TMath::Max(TMath::Max(tri.fXYZ[0].X(), tri.fXYZ[1].X()), tri.fXYZ[2].X());
-            const Double_t yMin = TMath::Min(TMath::Min(tri.fXYZ[0].Y(), tri.fXYZ[1].Y()), tri.fXYZ[2].Y());
-            const Double_t yMax = TMath::Max(TMath::Max(tri.fXYZ[0].Y(), tri.fXYZ[1].Y()), tri.fXYZ[2].Y());
-            const Double_t zMin = TMath::Min(TMath::Min(tri.fXYZ[0].Z(), tri.fXYZ[1].Z()), tri.fXYZ[2].Z());
-            const Double_t zMax = TMath::Max(TMath::Max(tri.fXYZ[0].Z(), tri.fXYZ[1].Z()), tri.fXYZ[2].Z());
-
-            if (fBoxCut.IsInCut(xMin, xMax, yMin, yMax, zMin, zMax))
-               continue;
-            glVertex3dv(tri.fXYZ[0].CArr());
-            glVertex3dv(tri.fXYZ[1].CArr());
-            glVertex3dv(tri.fXYZ[2].CArr());
-         }
-      }
+   if(!fBoxCut.IsActive())
+      DrawMapleMesh(fMesh.fVerts, fMesh.fNorms, fMesh.fTris);
+   else
+      DrawMapleMesh(fMesh.fVerts, fMesh.fNorms, fMesh.fTris, fBoxCut);
 
-      glEnd();
-      if (fStyle == kMaple1 && !fSelectionPass) {
-         glDisable(GL_POLYGON_OFFSET_FILL);//1]
-         glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);//[3
-         glColor4d(0., 0., 0., 0.25);
-
-         glBegin(GL_TRIANGLES);
-
-         for (UInt_t i = 0, e = fMesh.size(); i < e; ++i) {
-            const TriFace_t &tri = fMesh[i];
-            const Double_t xMin = TMath::Min(TMath::Min(tri.fXYZ[0].X(), tri.fXYZ[1].X()), tri.fXYZ[2].X());
-            const Double_t xMax = TMath::Max(TMath::Max(tri.fXYZ[0].X(), tri.fXYZ[1].X()), tri.fXYZ[2].X());
-            const Double_t yMin = TMath::Min(TMath::Min(tri.fXYZ[0].Y(), tri.fXYZ[1].Y()), tri.fXYZ[2].Y());
-            const Double_t yMax = TMath::Max(TMath::Max(tri.fXYZ[0].Y(), tri.fXYZ[1].Y()), tri.fXYZ[2].Y());
-            const Double_t zMin = TMath::Min(TMath::Min(tri.fXYZ[0].Z(), tri.fXYZ[1].Z()), tri.fXYZ[2].Z());
-            const Double_t zMax = TMath::Max(TMath::Max(tri.fXYZ[0].Z(), tri.fXYZ[1].Z()), tri.fXYZ[2].Z());
-
-            if (fBoxCut.IsInCut(xMin, xMax, yMin, yMax, zMin, zMax))
-               continue;
-            glVertex3dv(tri.fXYZ[0].CArr());
-            glVertex3dv(tri.fXYZ[1].CArr());
-            glVertex3dv(tri.fXYZ[2].CArr());
-         }
+   if (fStyle == kMaple1) {
+      //Draw outlines.
+      glDisable(GL_POLYGON_OFFSET_FILL);//1]
+      glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);//[3
+      glColor4d(0., 0., 0., 0.25);
 
-         glEnd();
-         glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);//3]
-      } else if (fStyle == kMaple2)
-         glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);//2]
+      if(!fBoxCut.IsActive())
+         DrawMesh(GL_DOUBLE, fMesh.fVerts, fMesh.fTris);
+      else
+         DrawMesh(&glVertex3dv, fMesh.fVerts, fMesh.fTris, fBoxCut);
 
-      if (fStyle > kDefault && !fSelectionPass)
-         glEnable(GL_LIGHTING); //0]
-      fBoxCut.DrawBox(fSelectionPass, fSelectedPart);
-   }
+      glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);//[3
+   } else if (fStyle == kMaple2)
+      glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
 
-   if (!fSelectionPass && HasSections() && fStyle < kMaple2) {
+   if (HasSections() && fStyle < kMaple2) {
       glDisable(GL_BLEND);
       glDepthMask(GL_TRUE);
    }
+}
 
+//______________________________________________________________________________
+void TGLTF3Painter::DrawPlot() const
+{
+   //Draw mesh.
+   fBackBox.DrawBox(fSelectedPart, fSelectionPass, fZLevels, fHighColor);
+   DrawSections();
+   
+   if (fSelectionPass) {
+      DrawToSelectionBuffer();
+   } else if (fStyle == kDefault) {
+      DrawDefaultPlot();
+   } else {
+      DrawMaplePlot();
+   }
 
+   if (fBoxCut.IsActive())
+      fBoxCut.DrawBox(fSelectionPass, fSelectedPart);
 }
 
 //______________________________________________________________________________
-void TGLTF3Painter::SetSurfaceColor()const
+void TGLTF3Painter::SetSurfaceColor() const
 {
    //Set color for surface.
    Float_t diffColor[] = {0.8f, 0.8f, 0.8f, 0.15f};
@@ -387,15 +463,16 @@ void TGLTF3Painter::SetSurfaceColor()const
 }
 
 //______________________________________________________________________________
-Bool_t TGLTF3Painter::HasSections()const
+Bool_t TGLTF3Painter::HasSections() const
 {
    //Any section exists.
-   return fXOZSectionPos > fBackBox.Get3DBox()[0].Y() || fYOZSectionPos > fBackBox.Get3DBox()[0].X() ||
+   return fXOZSectionPos > fBackBox.Get3DBox()[0].Y() || 
+          fYOZSectionPos > fBackBox.Get3DBox()[0].X() ||
           fXOYSectionPos > fBackBox.Get3DBox()[0].Z();
 }
 
 //______________________________________________________________________________
-void TGLTF3Painter::DrawSectionXOZ()const
+void TGLTF3Painter::DrawSectionXOZ() const
 {
    // Draw XOZ parallel section.
    if (fSelectionPass)
@@ -404,7 +481,7 @@ void TGLTF3Painter::DrawSectionXOZ()const
 }
 
 //______________________________________________________________________________
-void TGLTF3Painter::DrawSectionYOZ()const
+void TGLTF3Painter::DrawSectionYOZ() const
 {
    // Draw YOZ parallel section.
    if (fSelectionPass)
@@ -413,7 +490,7 @@ void TGLTF3Painter::DrawSectionYOZ()const
 }
 
 //______________________________________________________________________________
-void TGLTF3Painter::DrawSectionXOY()const
+void TGLTF3Painter::DrawSectionXOY() const
 {
    // Draw XOY parallel section.
    if (fSelectionPass)
@@ -424,13 +501,13 @@ void TGLTF3Painter::DrawSectionXOY()const
 
 //______________________________________________________________________________
 //
-// Implements painting of TH3 with the "ISO" option.
+// "gliso" option for TH3.
 
 ClassImp(TGLIsoPainter)
 
 //______________________________________________________________________________
 TGLIsoPainter::TGLIsoPainter(TH1 *hist, TGLOrthoCamera *camera, TGLPlotCoordinates *coord, TGLPaintDevice *dev)
-                  : TGLPlotPainter(hist, camera, coord, dev, kTRUE, kTRUE, kTRUE),
+                  : TGLPlotPainter(hist, camera, coord, dev, kFALSE, kFALSE, kFALSE),
                     fXOZSlice("XOZ", (TH3 *)hist, coord, &fBackBox, TGLTH3Slice::kXOZ),
                     fYOZSlice("YOZ", (TH3 *)hist, coord, &fBackBox, TGLTH3Slice::kYOZ),
                     fXOYSlice("XOY", (TH3 *)hist, coord, &fBackBox, TGLTH3Slice::kXOY),
@@ -450,28 +527,6 @@ char *TGLIsoPainter::GetPlotInfo(Int_t /*px*/, Int_t /*py*/)
    return mess;
 }
 
-namespace {
-
-   void MarchingCube(Double_t x, Double_t y, Double_t z, Double_t stepX, Double_t stepY,
-                     Double_t stepZ, Double_t scaleX, Double_t scaleY, Double_t scaleZ,
-                     const Double_t *funValues, std::vector<TGLIsoPainter::TriFace_t> &mesh,
-                     Double_t isoValue);
-
-   inline Double_t Abs(Double_t val)
-   {
-      if(val < 0.) val *= -1.;
-      return val;
-   }
-
-   inline Bool_t Eq(const TGLVertex3 &v1, const TGLVertex3 &v2)
-   {
-      return Abs(v1.X() - v2.X()) < 0.0000001 &&
-             Abs(v1.Y() - v2.Y()) < 0.0000001 &&
-             Abs(v1.Z() - v2.Z()) < 0.0000001;
-   }
-
-}
-
 //______________________________________________________________________________
 Bool_t TGLIsoPainter::InitGeometry()
 {
@@ -482,8 +537,6 @@ Bool_t TGLIsoPainter::InitGeometry()
    }
 
    //Create mesh.
-   //Now, I check this to avoid
-   //expensive recalculations.
    if (fInit)
       return kTRUE;
 
@@ -495,7 +548,7 @@ Bool_t TGLIsoPainter::InitGeometry()
    fBackBox.SetPlotBox(fCoord->GetXRangeScaled(), fCoord->GetYRangeScaled(), fCoord->GetZRangeScaled());
    if (fCamera) fCamera->SetViewVolume(fBackBox.Get3DBox());
 
-   //Move old meshed into the cache.
+   //Move old meshes into the cache.
    if (!fIsos.empty())
       fCache.splice(fCache.begin(), fIsos);
    //Number of contours == number of iso surfaces.
@@ -546,7 +599,6 @@ Bool_t TGLIsoPainter::InitGeometry()
       }
    }
 
-
    if (fCoord->Modified()) {
       fUpdateSelection = kTRUE;
       fXOZSectionPos = fBackBox.Get3DBox()[0].Y();
@@ -577,8 +629,8 @@ void TGLIsoPainter::Pan(Int_t px, Int_t py)
 {
    //User's moving mouse cursor, with middle mouse button pressed (for pad).
    //Calculate 3d shift related to 2d mouse movement.
-   // User's moving mouse cursor, with middle mouse button pressed (for pad).
-   // Calculate 3d shift related to 2d mouse movement.
+   //User's moving mouse cursor, with middle mouse button pressed (for pad).
+   //Calculate 3d shift related to 2d mouse movement.
 
    if (!MakeGLContextCurrent())
       return;
@@ -590,12 +642,13 @@ void TGLIsoPainter::Pan(Int_t px, Int_t py)
       //Possibly, move box here
       py = fCamera->GetHeight() - py;
       if (!fHighColor) {
-         if (fBoxCut.IsActive() && (fSelectedPart >= kXAxis && fSelectedPart <= kZAxis))
+         if (fBoxCut.IsActive() && (fSelectedPart >= kXAxis && fSelectedPart <= kZAxis)) {
             fBoxCut.MoveBox(px, py, fSelectedPart);
-         else
-            MoveSection(px, py);
+         } else {
+            //MoveSection(px, py);
+	 }
       } else {
-         MoveSection(px, py);
+         //MoveSection(px, py);
       }
    }
 
@@ -638,7 +691,7 @@ void TGLIsoPainter::ProcessEvent(Int_t event, Int_t /*px*/, Int_t py)
 }
 
 //______________________________________________________________________________
-void TGLIsoPainter::InitGL()const
+void TGLIsoPainter::InitGL() const
 {
    //Initialize OpenGL state variables.
    glEnable(GL_LIGHTING);
@@ -649,12 +702,12 @@ void TGLIsoPainter::InitGL()const
 }
 
 //______________________________________________________________________________
-void TGLIsoPainter::DrawPlot()const
+void TGLIsoPainter::DrawPlot() const
 {
    //Draw mesh.
    fBackBox.DrawBox(fSelectedPart, fSelectionPass, fZLevels, fHighColor);
    DrawSections();
-
+   
    if (fIsos.size() != fColorLevels.size()) {
       Error("TGLIsoPainter::DrawPlot", "Non-equal number of levels and isos");
       return;
@@ -686,7 +739,7 @@ void TGLIsoPainter::DrawPlot()const
 }
 
 //______________________________________________________________________________
-void TGLIsoPainter::DrawSectionXOZ()const
+void TGLIsoPainter::DrawSectionXOZ() const
 {
    // Draw XOZ parallel section.
    if (fSelectionPass)
@@ -695,7 +748,7 @@ void TGLIsoPainter::DrawSectionXOZ()const
 }
 
 //______________________________________________________________________________
-void TGLIsoPainter::DrawSectionYOZ()const
+void TGLIsoPainter::DrawSectionYOZ() const
 {
    // Draw YOZ parallel section.
    if (fSelectionPass)
@@ -704,7 +757,7 @@ void TGLIsoPainter::DrawSectionYOZ()const
 }
 
 //______________________________________________________________________________
-void TGLIsoPainter::DrawSectionXOY()const
+void TGLIsoPainter::DrawSectionXOY() const
 {
    // Draw XOY parallel section.
    if (fSelectionPass)
@@ -713,7 +766,7 @@ void TGLIsoPainter::DrawSectionXOY()const
 }
 
 //______________________________________________________________________________
-Bool_t TGLIsoPainter::HasSections()const
+Bool_t TGLIsoPainter::HasSections() const
 {
    //Any section exists.
    return fXOZSectionPos > fBackBox.Get3DBox()[0].Y() || fYOZSectionPos > fBackBox.Get3DBox()[0].X() ||
@@ -721,7 +774,7 @@ Bool_t TGLIsoPainter::HasSections()const
 }
 
 //______________________________________________________________________________
-void TGLIsoPainter::SetSurfaceColor(Int_t ind)const
+void TGLIsoPainter::SetSurfaceColor(Int_t ind) const
 {
    //Set color for surface.
    Float_t diffColor[] = {0.8f, 0.8f, 0.8f, 0.25f};
@@ -748,274 +801,60 @@ void TGLIsoPainter::SetSurfaceColor(Int_t ind)const
 //______________________________________________________________________________
 void TGLIsoPainter::SetMesh(Mesh_t &m, Double_t isoValue)
 {
-   //Set mesh for iso surface at level isoValue.
-   //Large and nightmarish "unrolled" code - I'm doing simple optimisation:
-   //marching cubes calculates a set of triangles (possible empty)
-   //for each of cubes in a lattice. After that, I need to calculate
-   //per-vertex smoothed normals - calculating the summ of neighbouring
-   //per-triangle normals and normalizing
-   //(so, I need to find common vertices for triangles),
-   //this can be done only after
-   //each of 26 neighbouring cubes was processed. I remember
-   //"mesh range" for each cube, not to check _EVERY_ triangles.
-   const Int_t nX = fHist->GetNbinsX();
-   const Int_t nY = fHist->GetNbinsY();
-   const Int_t nZ = fHist->GetNbinsZ();
-
-   const Double_t xMin      = fXAxis->GetBinCenter(fXAxis->GetFirst());
-   const Double_t xStep     = (fXAxis->GetBinCenter(fXAxis->GetLast()) - xMin) / (nX - 1);
-   const Double_t yMin      = fYAxis->GetBinCenter(fYAxis->GetFirst());
-   const Double_t yStep     = (fYAxis->GetBinCenter(fYAxis->GetLast()) - yMin) / (nY - 1);
-   const Double_t zMin      = fZAxis->GetBinCenter(fZAxis->GetFirst());
-   const Double_t zStep     = (fZAxis->GetBinCenter(fZAxis->GetLast()) - zMin) / (nZ - 1);
-   const Int_t    sliceSize = (nY + 2) * (nZ + 2);
-   std::vector<Range_t> boxRanges((nX + 2) * (nY + 2) * (nZ + 2), Range_t());
-   std::vector<TriFace_t> &mesh = m.fMesh;
-   mesh.clear();
-   //First, calculate full mesh and define "box ranges" - which
-   //part of the full mesh is in current box.
-   //Find flat normals.
-   for (Int_t i = 0, ir = fXAxis->GetFirst(), ei = fXAxis->GetLast(); ir < ei; ++i, ++ir) {
-      for (Int_t j = 0, jr = fYAxis->GetFirst(), ej = fYAxis->GetLast(); jr < ej; ++j, ++jr) {
-         for (Int_t k = 0, kr = fZAxis->GetFirst(), ek = fZAxis->GetLast(); kr < ek; ++k, ++kr) {
-            const Double_t cube[] = {fHist->GetBinContent(ir, jr, kr),             fHist->GetBinContent(ir + 1, jr, kr),
-                                     fHist->GetBinContent(ir + 1, jr + 1, kr),     fHist->GetBinContent(ir, jr + 1, kr),
-                                     fHist->GetBinContent(ir, jr, kr + 1),         fHist->GetBinContent(ir + 1, jr, kr + 1),
-                                     fHist->GetBinContent(ir + 1, jr + 1, kr + 1), fHist->GetBinContent(ir, jr + 1, kr + 1)};
-            Int_t start  = Int_t(mesh.size());
-            MarchingCube(xMin + i * xStep, yMin + j * yStep, zMin + k * zStep, xStep, yStep, zStep,
-                         fCoord->GetXScale(), fCoord->GetYScale(), fCoord->GetZScale(), cube, mesh,
-                         isoValue);
-            Int_t finish = Int_t(mesh.size());
-            if (start != finish)
-               boxRanges[(ir + 1) * sliceSize + (jr + 1) * (nZ + 2) + kr + 1] = Range_t(start, finish);
-         }
-      }
-   }
-
-   for (Int_t i = 1; i <= nX; ++i) {
-      for (Int_t j = 1; j <= nY; ++j) {
-         for (Int_t k = 1; k <= nZ; ++k) {
-            Range_t &box = boxRanges[i * sliceSize + j * (nZ + 2) + k];
-            if (box.fFirst != -1) {
-               for (Int_t tri = box.fFirst; tri < box.fLast; ++tri) {
-                  TriFace_t &face = mesh[tri];
-                  //First, check triangles from the same box.
-                  for (Int_t k1 = 0; k1 < 3; ++k1) face.fPerVertexNormals[k1] = face.fNormal;
-                  const TGLVertex3 &v0 = face.fXYZ[0];
-                  const TGLVertex3 &v1 = face.fXYZ[1];
-                  const TGLVertex3 &v2 = face.fXYZ[2];
-
-                  for (Int_t tri1 = box.fFirst; tri1 < box.fLast; ++tri1) {
-                     if (tri != tri1) {
-                        const TriFace_t &testFace = mesh[tri1];
-                        if (Eq(v0, testFace.fXYZ[0]))
-                           face.fPerVertexNormals[0] += testFace.fNormal;
-                        if (Eq(v0, testFace.fXYZ[1]))
-                           face.fPerVertexNormals[0] += testFace.fNormal;
-                        if (Eq(v0, testFace.fXYZ[2]))
-                           face.fPerVertexNormals[0] += testFace.fNormal;
-                        if (Eq(v1, testFace.fXYZ[0]))
-                           face.fPerVertexNormals[1] += testFace.fNormal;
-                        if (Eq(v1, testFace.fXYZ[1]))
-                           face.fPerVertexNormals[1] += testFace.fNormal;
-                        if (Eq(v1, testFace.fXYZ[2]))
-                           face.fPerVertexNormals[1] += testFace.fNormal;
-                        if (Eq(v2, testFace.fXYZ[0]))
-                           face.fPerVertexNormals[2] += testFace.fNormal;
-                        if (Eq(v2, testFace.fXYZ[1]))
-                           face.fPerVertexNormals[2] += testFace.fNormal;
-                        if (Eq(v2, testFace.fXYZ[2]))
-                           face.fPerVertexNormals[2] += testFace.fNormal;
-                     }
-                  }
-
-                  const Int_t nZ2 = nZ + 2;
-
-                  Range_t &box1  = boxRanges[(i - 1) * sliceSize + (j - 1) * nZ2 + k - 1];
-                  CheckBox(mesh, face, box1);
-                  Range_t &box2  = boxRanges[(i) * sliceSize + (j - 1) * nZ2 + k - 1];
-                  CheckBox(mesh, face, box2);
-                  Range_t &box3  = boxRanges[(i + 1) * sliceSize + (j - 1) * nZ2 + k - 1];
-                  CheckBox(mesh, face, box3);
-                  Range_t &box4  = boxRanges[(i + 1) * sliceSize + (j) * nZ2 + k - 1];
-                  CheckBox(mesh, face, box4);
-                  Range_t &box5  = boxRanges[(i + 1) * sliceSize + (j + 1) * nZ2 + k - 1];
-                  CheckBox(mesh, face, box5);
-                  Range_t &box6  = boxRanges[(i) * sliceSize + (j + 1) * nZ2 + k - 1];
-                  CheckBox(mesh, face, box6);
-                  Range_t &box7  = boxRanges[(i - 1) * sliceSize + (j + 1) * nZ2 + k - 1];
-                  CheckBox(mesh, face, box7);
-                  Range_t &box8  = boxRanges[(i - 1) * sliceSize + (j) * nZ2 + k - 1];
-                  CheckBox(mesh, face, box8);
-                  Range_t &box9  = boxRanges[(i) * sliceSize + (j) * nZ2 + k - 1];
-                  CheckBox(mesh, face, box9);
-
-                  Range_t &box10  = boxRanges[(i - 1) * sliceSize + (j - 1) * nZ2 + k];
-                  CheckBox(mesh, face, box10);
-                  Range_t &box11  = boxRanges[(i) * sliceSize + (j - 1) * nZ2 + k];
-                  CheckBox(mesh, face, box11);
-                  Range_t &box12  = boxRanges[(i + 1) * sliceSize + (j - 1) * nZ2 + k];
-                  CheckBox(mesh, face, box12);
-                  Range_t &box13  = boxRanges[(i + 1) * sliceSize + (j) * nZ2 + k];
-                  CheckBox(mesh, face, box13);
-                  Range_t &box14  = boxRanges[(i + 1) * sliceSize + (j + 1) * nZ2 + k];
-                  CheckBox(mesh, face, box14);
-                  Range_t &box15  = boxRanges[(i) * sliceSize + (j + 1) * nZ2 + k];
-                  CheckBox(mesh, face, box15);
-                  Range_t &box16  = boxRanges[(i - 1) * sliceSize + (j + 1) * nZ2 + k];
-                  CheckBox(mesh, face, box16);
-                  Range_t &box17  = boxRanges[(i - 1) * sliceSize + (j) * nZ2 + k];
-                  CheckBox(mesh, face, box17);
-
-                  Range_t &box18  = boxRanges[(i - 1) * sliceSize + (j - 1) * nZ2 + k + 1];
-                  CheckBox(mesh, face, box18);
-                  Range_t &box19  = boxRanges[(i) * sliceSize + (j - 1) * nZ2 + k + 1];
-                  CheckBox(mesh, face, box19);
-                  Range_t &box20  = boxRanges[(i + 1) * sliceSize + (j - 1) * nZ2 + k + 1];
-                  CheckBox(mesh, face, box20);
-                  Range_t &box21  = boxRanges[(i + 1) * sliceSize + (j) * nZ2 + k + 1];
-                  CheckBox(mesh, face, box21);
-                  Range_t &box22  = boxRanges[(i + 1) * sliceSize + (j + 1) * nZ2 + k + 1];
-                  CheckBox(mesh, face, box22);
-                  Range_t &box23  = boxRanges[(i) * sliceSize + (j + 1) * nZ2 + k + 1];
-                  CheckBox(mesh, face, box23);
-                  Range_t &box24  = boxRanges[(i - 1) * sliceSize + (j + 1) * nZ2 + k + 1];
-                  CheckBox(mesh, face, box24);
-                  Range_t &box25  = boxRanges[(i - 1) * sliceSize + (j) * nZ2 + k + 1];
-                  CheckBox(mesh, face, box25);
-                  Range_t &box26  = boxRanges[(i) * sliceSize + (j) * nZ2 + k + 1];
-                  CheckBox(mesh, face, box26);
-               }
-            }
-         }
-      }
+   Rgl::Mc::TGridGeometry<Float_t> geom;
+   //Get grid parameters.
+   geom.fMinX  = fXAxis->GetBinCenter(fXAxis->GetFirst());
+   geom.fStepX = (fXAxis->GetBinCenter(fXAxis->GetLast()) - geom.fMinX) / (fHist->GetNbinsX() - 1);
+   geom.fMinY  = fYAxis->GetBinCenter(fYAxis->GetFirst());
+   geom.fStepY = (fYAxis->GetBinCenter(fYAxis->GetLast()) - geom.fMinY) / (fHist->GetNbinsY() - 1);
+   geom.fMinZ  = fZAxis->GetBinCenter(fZAxis->GetFirst());
+   geom.fStepZ = (fZAxis->GetBinCenter(fZAxis->GetLast()) - geom.fMinZ) / (fHist->GetNbinsZ() - 1);
+   //Scale grid parameters.
+   geom.fMinX *= fCoord->GetXScale(), geom.fStepX *= fCoord->GetXScale();
+   geom.fMinY *= fCoord->GetYScale(), geom.fStepY *= fCoord->GetYScale();
+   geom.fMinZ *= fCoord->GetZScale(), geom.fStepZ *= fCoord->GetZScale();
+   //Clear mesh if it was from cache.
+   m.ClearMesh();
+   //Select correct TMeshBuilder type.
+   if (typeid(*fHist) == typeid(TH3C)) {
+      Rgl::Mc::TMeshBuilder<TH3C, Float_t> builder(kTRUE);
+      builder.BuildMesh(static_cast<TH3C *>(fHist), geom, &m, isoValue);
+   } else if (typeid(*fHist) == typeid(TH3S)) {
+      Rgl::Mc::TMeshBuilder<TH3S, Float_t> builder(kTRUE);
+      builder.BuildMesh(static_cast<TH3S *>(fHist), geom, &m, isoValue);
+   } else if (typeid(*fHist) == typeid(TH3I)) {
+      Rgl::Mc::TMeshBuilder<TH3I, Float_t> builder(kTRUE);
+      builder.BuildMesh(static_cast<TH3I *>(fHist), geom, &m, isoValue);
+   } else if (typeid(*fHist) == typeid(TH3F)) {
+      Rgl::Mc::TMeshBuilder<TH3F, Float_t> builder(kTRUE);
+      builder.BuildMesh(static_cast<TH3F *>(fHist), geom, &m, isoValue);
+   } else if (typeid(*fHist) == typeid(TH3D)) {
+      Rgl::Mc::TMeshBuilder<TH3D, Float_t> builder(kTRUE);
+      builder.BuildMesh(static_cast<TH3D *>(fHist), geom, &m, isoValue);
    }
-
-   for (UInt_t i = 0, ei = mesh.size(); i < ei; ++i) {
-      TriFace_t &face = mesh[i];
-      if(face.fPerVertexNormals[0].X() || face.fPerVertexNormals[0].Y() || face.fPerVertexNormals[0].Z())
-         face.fPerVertexNormals[0].Normalise();
-      if(face.fPerVertexNormals[1].X() || face.fPerVertexNormals[1].Y() || face.fPerVertexNormals[1].Z())
-         face.fPerVertexNormals[1].Normalise();
-      if(face.fPerVertexNormals[2].X() || face.fPerVertexNormals[2].Y() || face.fPerVertexNormals[2].Z())
-         face.fPerVertexNormals[2].Normalise();
-   }
-
 }
 
 //______________________________________________________________________________
-void TGLIsoPainter::DrawMesh(const Mesh_t &mesh, Int_t level)const
+void TGLIsoPainter::DrawMesh(const Mesh_t &m, Int_t level) const
 {
    //Draw TF3 surface
    if (!fSelectionPass)
       SetSurfaceColor(level);
 
    if (!fBoxCut.IsActive()) {
-      glBegin(GL_TRIANGLES);
-
-
-      if (!fSelectionPass) {
-         for (UInt_t i = 0, e = mesh.fMesh.size(); i < e; ++i) {
-            glNormal3dv(mesh.fMesh[i].fPerVertexNormals[0].CArr());
-            glVertex3dv(mesh.fMesh[i].fXYZ[0].CArr());
-            glNormal3dv(mesh.fMesh[i].fPerVertexNormals[1].CArr());
-            glVertex3dv(mesh.fMesh[i].fXYZ[1].CArr());
-            glNormal3dv(mesh.fMesh[i].fPerVertexNormals[2].CArr());
-            glVertex3dv(mesh.fMesh[i].fXYZ[2].CArr());
-         }
-
-      } else {
+      if (!fSelectionPass)
+         ::DrawMesh(GL_FLOAT, m.fVerts, m.fNorms, m.fTris);
+      else {
          Rgl::ObjectIDToColor(fSelectionBase, fHighColor);
-         for (UInt_t i = 0, e = mesh.fMesh.size(); i < e; ++i) {
-            glVertex3dv(mesh.fMesh[i].fXYZ[0].CArr());
-            glVertex3dv(mesh.fMesh[i].fXYZ[1].CArr());
-            glVertex3dv(mesh.fMesh[i].fXYZ[2].CArr());
-         }
+         ::DrawMesh(GL_FLOAT, m.fVerts, m.fTris);
       }
-
-      glEnd();
-
    } else {
-      glBegin(GL_TRIANGLES);
-
-      if (!fSelectionPass) {
-         for (UInt_t i = 0, e = mesh.fMesh.size(); i < e; ++i) {
-            const TriFace_t &tri = mesh.fMesh[i];
-            const Double_t xMin = TMath::Min(TMath::Min(tri.fXYZ[0].X(), tri.fXYZ[1].X()), tri.fXYZ[2].X());
-            const Double_t xMax = TMath::Max(TMath::Max(tri.fXYZ[0].X(), tri.fXYZ[1].X()), tri.fXYZ[2].X());
-            const Double_t yMin = TMath::Min(TMath::Min(tri.fXYZ[0].Y(), tri.fXYZ[1].Y()), tri.fXYZ[2].Y());
-            const Double_t yMax = TMath::Max(TMath::Max(tri.fXYZ[0].Y(), tri.fXYZ[1].Y()), tri.fXYZ[2].Y());
-            const Double_t zMin = TMath::Min(TMath::Min(tri.fXYZ[0].Z(), tri.fXYZ[1].Z()), tri.fXYZ[2].Z());
-            const Double_t zMax = TMath::Max(TMath::Max(tri.fXYZ[0].Z(), tri.fXYZ[1].Z()), tri.fXYZ[2].Z());
-
-            if (fBoxCut.IsInCut(xMin, xMax, yMin, yMax, zMin, zMax))
-               continue;
-
-            glNormal3dv(tri.fPerVertexNormals[0].CArr());
-            glVertex3dv(tri.fXYZ[0].CArr());
-            glNormal3dv(tri.fPerVertexNormals[1].CArr());
-            glVertex3dv(tri.fXYZ[1].CArr());
-            glNormal3dv(tri.fPerVertexNormals[2].CArr());
-            glVertex3dv(tri.fXYZ[2].CArr());
-         }
-
-      } else {
+      if (!fSelectionPass)
+         ::DrawMesh(&glNormal3fv, &glVertex3fv, m.fVerts, m.fNorms, m.fTris, fBoxCut);
+      else {
          Rgl::ObjectIDToColor(fSelectionBase, fHighColor);
-         for (UInt_t i = 0, e = mesh.fMesh.size(); i < e; ++i) {
-            const TriFace_t &tri = mesh.fMesh[i];
-            const Double_t xMin = TMath::Min(TMath::Min(tri.fXYZ[0].X(), tri.fXYZ[1].X()), tri.fXYZ[2].X());
-            const Double_t xMax = TMath::Max(TMath::Max(tri.fXYZ[0].X(), tri.fXYZ[1].X()), tri.fXYZ[2].X());
-            const Double_t yMin = TMath::Min(TMath::Min(tri.fXYZ[0].Y(), tri.fXYZ[1].Y()), tri.fXYZ[2].Y());
-            const Double_t yMax = TMath::Max(TMath::Max(tri.fXYZ[0].Y(), tri.fXYZ[1].Y()), tri.fXYZ[2].Y());
-            const Double_t zMin = TMath::Min(TMath::Min(tri.fXYZ[0].Z(), tri.fXYZ[1].Z()), tri.fXYZ[2].Z());
-            const Double_t zMax = TMath::Max(TMath::Max(tri.fXYZ[0].Z(), tri.fXYZ[1].Z()), tri.fXYZ[2].Z());
-
-            if (fBoxCut.IsInCut(xMin, xMax, yMin, yMax, zMin, zMax))
-               continue;
-
-            glVertex3dv(tri.fXYZ[0].CArr());
-            glVertex3dv(tri.fXYZ[1].CArr());
-            glVertex3dv(tri.fXYZ[2].CArr());
-         }
+         ::DrawMesh(&glVertex3fv, m.fVerts, m.fTris, fBoxCut);
       }
-
-      glEnd();
-   }
-}
-
-//______________________________________________________________________________
-void TGLIsoPainter::CheckBox(const std::vector<TriFace_t> &mesh, TriFace_t &face, const Range_t &box)
-{
-   //For given box and given fase, check if any of box faces has
-   //common vertex with face, if yes - att its flat normal.
-   if (box.fFirst == -1)
-      return;
-
-   const TGLVertex3 &v0 = face.fXYZ[0];
-   const TGLVertex3 &v1 = face.fXYZ[1];
-   const TGLVertex3 &v2 = face.fXYZ[2];
-
-   for (Int_t tri1 = box.fFirst; tri1 < box.fLast; ++tri1) {
-      const TriFace_t &testFace = mesh[tri1];
-      if (Eq(v0, testFace.fXYZ[0]))
-         face.fPerVertexNormals[0] += testFace.fNormal;
-      if (Eq(v0, testFace.fXYZ[1]))
-         face.fPerVertexNormals[0] += testFace.fNormal;
-      if (Eq(v0, testFace.fXYZ[2]))
-         face.fPerVertexNormals[0] += testFace.fNormal;
-      if (Eq(v1, testFace.fXYZ[0]))
-         face.fPerVertexNormals[1] += testFace.fNormal;
-      if (Eq(v1, testFace.fXYZ[1]))
-         face.fPerVertexNormals[1] += testFace.fNormal;
-      if (Eq(v1, testFace.fXYZ[2]))
-         face.fPerVertexNormals[1] += testFace.fNormal;
-      if (Eq(v2, testFace.fXYZ[0]))
-         face.fPerVertexNormals[2] += testFace.fNormal;
-      if (Eq(v2, testFace.fXYZ[1]))
-         face.fPerVertexNormals[2] += testFace.fNormal;
-      if (Eq(v2, testFace.fXYZ[2]))
-         face.fPerVertexNormals[2] += testFace.fNormal;
    }
 }
 
@@ -1036,496 +875,3 @@ void TGLIsoPainter::FindMinMax()
       }
    }
 }
-
-/*
-TF3's based on a small, nice and neat implementation of marching cubes by Cory Bloyd (corysama at yahoo.com)
-(many thanks!!!). All possible errors in code are mine - I've modified original code. (tpochep)
-*/
-
-
-namespace {
-   //These tables are used so that everything can be done in little loops that you can look at all at once
-   // rather than in pages and pages of unrolled code.
-   //gA2VertexOffset lists the positions, relative to vertex0, of each of the 8 vertices of a cube
-   const Double_t gA2VertexOffset[8][3] =
-   {
-      {0., 0., 0.}, {1., 0., 0.}, {1., 1., 0.},
-      {0., 1., 0.}, {0., 0., 1.}, {1., 0., 1.},
-      {1., 1., 1.}, {0., 1., 1.}
-   };
-   //gA2EdgeConnection lists the index of the endpoint vertices for each of the 12 edges of the cube
-   const Int_t gA2EdgeConnection[12][2] =
-   {
-      {0, 1}, {1, 2}, {2, 3}, {3, 0},
-      {4, 5}, {5, 6}, {6, 7}, {7, 4},
-      {0,4}, {1,5}, {2,6}, {3,7}
-   };
-   //gA2EdgeDirection lists the direction vector (vertex1-vertex0) for each edge in the cube
-   const Double_t gA2EdgeDirection[12][3] =
-   {
-      {1., 0., 0.}, {0., 1., 0.}, {-1., 0., 0.},
-      {0., -1., 0.}, {1., 0., 0.}, {0., 1., 0.},
-      {-1., 0., 0.}, {0., -1., 0.}, {0., 0., 1.},
-      {0., 0., 1.}, { 0., 0., 1.}, {0., 0., 1.}
-   };
-
-   const Float_t gTargetValue = 0.2f;
-   //GetOffset finds the approximate point of intersection of the surface
-   // between two points with the values fValue1 and fValue2
-   Double_t GetOffset(Double_t val1, Double_t val2, Double_t valDesired)
-   {
-      Double_t delta = val2 - val1;
-
-      if (!delta)
-         return 0.5;
-
-      return (valDesired - val1) / delta;
-   }
-
-   //GetColor generates a color from a given normal
-   void GetColor(Double_t *rfColor, const TGLVector3 &normal)
-   {
-      Double_t x = normal.X();
-      Double_t y = normal.Y();
-      Double_t z = normal.Z();
-      rfColor[0] = (x > 0. ? x : 0.) + (y < 0. ? -0.5 * y : 0.) + (z < 0. ? -0.5 * z : 0.);
-      rfColor[1] = (y > 0. ? y : 0.) + (z < 0. ? -0.5 * z : 0.) + (x < 0. ? -0.5 * x : 0.);
-      rfColor[2] = (z > 0. ? z : 0.) + (x < 0. ? -0.5 * x : 0.) + (y < 0. ? -0.5 * y : 0.);
-   }
-
-   void GetNormal(TGLVector3 &normal, Double_t x, Double_t y, Double_t z, const TF3 *fun)
-   {
-      normal.X() = fun->Eval(x - 0.01, y, z) - fun->Eval(x + 0.01, y, z);
-      normal.Y() = fun->Eval(x, y - 0.01, z) - fun->Eval(x, y + 0.01, z);
-      normal.Z() = fun->Eval(x, y, z - 0.01) - fun->Eval(x, y, z + 0.01);
-      normal.Normalise();
-   }
-
-   void GetNormal(TGLIsoPainter::TriFace_t &face)
-   {
-      TMath::Normal2Plane(face.fXYZ[0].CArr(), face.fXYZ[1].CArr(), face.fXYZ[2].CArr(), face.fNormal.Arr());
-   }
-
-   extern Int_t gCubeEdgeFlags[256];
-   extern Int_t gTriangleConnectionTable[256][16];
-
-   //MarchingCube performs the Marching Cubes algorithm on a single cube
-   void MarchingCube(Double_t x, Double_t y, Double_t z, Double_t stepX, Double_t stepY,
-                     Double_t stepZ, Double_t scaleX, Double_t scaleY, Double_t scaleZ,
-                     const TF3 *fun, std::vector<TGLTF3Painter::TriFace_t> &mesh,
-                     Rgl::Range_t &minMax)
-   {
-      Double_t afCubeValue[8] = {0.};
-      TGLVector3 asEdgeVertex[12];
-      TGLVector3 asEdgeNorm[12];
-
-      //Make a local copy of the values at the cube's corners
-      for (Int_t iVertex = 0; iVertex < 8; ++iVertex) {
-         afCubeValue[iVertex] = fun->Eval(x + gA2VertexOffset[iVertex][0] * stepX,
-                                          y + gA2VertexOffset[iVertex][1] * stepY,
-                                          z + gA2VertexOffset[iVertex][2] * stepZ);
-         minMax.first  = TMath::Min(minMax.first,  afCubeValue[iVertex]);
-         minMax.second = TMath::Max(minMax.second, afCubeValue[iVertex]);
-      }
-
-      //Find which vertices are inside of the surface and which are outside
-      Int_t iFlagIndex = 0;
-
-      for (Int_t iVertexTest = 0; iVertexTest < 8; ++iVertexTest) {
-         if(afCubeValue[iVertexTest] <= gTargetValue)
-            iFlagIndex |= 1<<iVertexTest;
-      }
-
-      //Find which edges are intersected by the surface
-      Int_t iEdgeFlags = gCubeEdgeFlags[iFlagIndex];
-      //If the cube is entirely inside or outside of the surface, then there will be no intersections
-      if (!iEdgeFlags) return;
-      //Find the point of intersection of the surface with each edge
-      //Then find the normal to the surface at those points
-      for (Int_t iEdge = 0; iEdge < 12; ++iEdge) {
-         //if there is an intersection on this edge
-         if (iEdgeFlags & (1<<iEdge)) {
-            Double_t offset = GetOffset(afCubeValue[ gA2EdgeConnection[iEdge][0] ],
-                                       afCubeValue[ gA2EdgeConnection[iEdge][1] ],
-                                       gTargetValue);
-
-            asEdgeVertex[iEdge].X() = x + (gA2VertexOffset[ gA2EdgeConnection[iEdge][0] ][0]  +  offset * gA2EdgeDirection[iEdge][0]) * stepX;
-            asEdgeVertex[iEdge].Y() = y + (gA2VertexOffset[ gA2EdgeConnection[iEdge][0] ][1]  +  offset * gA2EdgeDirection[iEdge][1]) * stepY;
-            asEdgeVertex[iEdge].Z() = z + (gA2VertexOffset[ gA2EdgeConnection[iEdge][0] ][2]  +  offset * gA2EdgeDirection[iEdge][2]) * stepZ;
-
-            GetNormal(asEdgeNorm[iEdge], asEdgeVertex[iEdge].X(), asEdgeVertex[iEdge].Y(), asEdgeVertex[iEdge].Z(), fun);
-         }
-      }
-
-      //Draw the triangles that were found.  There can be up to five per cube
-      for (Int_t iTriangle = 0; iTriangle < 5; iTriangle++) {
-         if(gTriangleConnectionTable[iFlagIndex][3 * iTriangle] < 0)
-            break;
-
-         TGLTF3Painter::TriFace_t newTri;
-
-         for (Int_t iCorner = 2; iCorner >= 0; --iCorner) {
-            Int_t iVertex = gTriangleConnectionTable[iFlagIndex][3*iTriangle+iCorner];
-
-            newTri.fXYZ[iCorner].X() = asEdgeVertex[iVertex].X() * scaleX;
-            newTri.fXYZ[iCorner].Y() = asEdgeVertex[iVertex].Y() * scaleY;
-            newTri.fXYZ[iCorner].Z() = asEdgeVertex[iVertex].Z() * scaleZ;
-
-            newTri.fNormals[iCorner] = asEdgeNorm[iVertex];
-         }
-
-         mesh.push_back(newTri);
-      }
-   }
-
-   //MarchingCube performs the Marching Cubes algorithm on a single cube
-   void MarchingCube(Double_t x, Double_t y, Double_t z, Double_t stepX, Double_t stepY,
-                     Double_t stepZ, Double_t scaleX, Double_t scaleY, Double_t scaleZ,
-                     const Double_t *cube, std::vector<TGLIsoPainter::TriFace_t> &mesh, Double_t isoValue)
-   {
-      TGLVector3 asEdgeVertex[12];
-
-      //Find which vertices are inside of the surface and which are outside
-      Int_t iFlagIndex = 0;
-
-      for (Int_t iVertexTest = 0; iVertexTest < 8; ++iVertexTest) {
-         if(cube[iVertexTest] <= isoValue)
-            iFlagIndex |= 1 << iVertexTest;
-      }
-
-      //Find which edges are intersected by the surface
-      Int_t iEdgeFlags = gCubeEdgeFlags[iFlagIndex];
-      //If the cube is entirely inside or outside of the surface, then there will be no intersections
-      if (!iEdgeFlags)
-         return;
-
-      //Find the point of intersection of the surface with each edge
-      //Then find the normal to the surface at those points
-      for (Int_t iEdge = 0; iEdge < 12; ++iEdge) {
-         //if there is an intersection on this edge
-         if (iEdgeFlags & (1<<iEdge)) {
-            Double_t offset = GetOffset(cube[gA2EdgeConnection[iEdge][0]], cube[gA2EdgeConnection[iEdge][1]], isoValue);
-
-            asEdgeVertex[iEdge].X() = x + (gA2VertexOffset[gA2EdgeConnection[iEdge][0]][0] + offset * gA2EdgeDirection[iEdge][0]) * stepX;
-            asEdgeVertex[iEdge].Y() = y + (gA2VertexOffset[gA2EdgeConnection[iEdge][0]][1] + offset * gA2EdgeDirection[iEdge][1]) * stepY;
-            asEdgeVertex[iEdge].Z() = z + (gA2VertexOffset[gA2EdgeConnection[iEdge][0]][2] + offset * gA2EdgeDirection[iEdge][2]) * stepZ;
-         }
-      }
-
-      //Draw the triangles that were found.  There can be up to five per cube
-      for (Int_t iTriangle = 0; iTriangle < 5; iTriangle++) {
-         if(gTriangleConnectionTable[iFlagIndex][3 * iTriangle] < 0)
-            break;
-
-         TGLIsoPainter::TriFace_t newTri;
-
-         for (Int_t iCorner = 2; iCorner >= 0; --iCorner) {
-            Int_t iVertex = gTriangleConnectionTable[iFlagIndex][3 * iTriangle + iCorner];
-
-            newTri.fXYZ[iCorner].X() = asEdgeVertex[iVertex].X() * scaleX;
-            newTri.fXYZ[iCorner].Y() = asEdgeVertex[iVertex].Y() * scaleY;
-            newTri.fXYZ[iCorner].Z() = asEdgeVertex[iVertex].Z() * scaleZ;
-         }
-
-         GetNormal(newTri);
-
-         mesh.push_back(newTri);
-      }
-   }
-
-   // For any edge, if one vertex is inside of the surface and the other is outside of the surface
-   //  then the edge intersects the surface
-   // For each of the 8 vertices of the cube can be two possible states : either inside or outside of the surface
-   // For any cube the are 2^8=256 possible sets of vertex states
-   // This table lists the edges intersected by the surface for all 256 possible vertex states
-   // There are 12 edges.  For each entry in the table, if edge #n is intersected, then bit #n is set to 1
-
-   Int_t gCubeEdgeFlags[256]=
-   {
-      0x000, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c, 0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,
-      0x190, 0x099, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c, 0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,
-      0x230, 0x339, 0x033, 0x13a, 0x636, 0x73f, 0x435, 0x53c, 0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,
-      0x3a0, 0x2a9, 0x1a3, 0x0aa, 0x7a6, 0x6af, 0x5a5, 0x4ac, 0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,
-      0x460, 0x569, 0x663, 0x76a, 0x066, 0x16f, 0x265, 0x36c, 0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,
-      0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0x0ff, 0x3f5, 0x2fc, 0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,
-      0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x055, 0x15c, 0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,
-      0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0x0cc, 0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,
-      0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc, 0x0cc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,
-      0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c, 0x15c, 0x055, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,
-      0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc, 0x2fc, 0x3f5, 0x0ff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
-      0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c, 0x36c, 0x265, 0x16f, 0x066, 0x76a, 0x663, 0x569, 0x460,
-      0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac, 0x4ac, 0x5a5, 0x6af, 0x7a6, 0x0aa, 0x1a3, 0x2a9, 0x3a0,
-      0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c, 0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x033, 0x339, 0x230,
-      0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c, 0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x099, 0x190,
-      0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c, 0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x000
-   };
-
-   //  For each of the possible vertex states listed in gCubeEdgeFlags there is a specific triangulation
-   //  of the edge intersection points.  gTriangleConnectionTable lists all of them in the form of
-   //  0-5 edge triples with the list terminated by the invalid value -1.
-   //  For example: gTriangleConnectionTable[3] list the 2 triangles formed when corner[0]
-   //  and corner[1] are inside of the surface, but the rest of the cube is not.
-   //
-   //  I found this table in an example program someone wrote long ago.  It was probably generated by hand
-
-   GLint gTriangleConnectionTable[256][16] =
-   {
-      {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1},
-      {3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1},
-      {3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1},
-      {3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1},
-      {9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1},
-      {1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1},
-      {9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1},
-      {2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1},
-      {8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1},
-      {9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1},
-      {4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1},
-      {3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1},
-      {1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1},
-      {4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1},
-      {4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1},
-      {9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1},
-      {1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1},
-      {5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1},
-      {2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1},
-      {9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1},
-      {0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1},
-      {2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1},
-      {10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1},
-      {4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1},
-      {5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1},
-      {5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1},
-      {9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1},
-      {0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1},
-      {1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1},
-      {10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1},
-      {8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1},
-      {2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1},
-      {7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1},
-      {9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1},
-      {2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1},
-      {11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1},
-      {9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1},
-      {5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1},
-      {11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1},
-      {11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1},
-      {1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1},
-      {9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1},
-      {5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1},
-      {2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1},
-      {0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1},
-      {5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1},
-      {6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1},
-      {0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1},
-      {3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1},
-      {6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1},
-      {5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1},
-      {1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1},
-      {10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1},
-      {6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1},
-      {1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1},
-      {8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1},
-      {7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1},
-      {3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1},
-      {5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1},
-      {0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1},
-      {9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1},
-      {8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1},
-      {5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1},
-      {0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1},
-      {6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1},
-      {10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1},
-      {10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1},
-      {8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1},
-      {1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1},
-      {3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1},
-      {0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1},
-      {10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1},
-      {0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1},
-      {3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1},
-      {6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1},
-      {9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1},
-      {8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1},
-      {3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1},
-      {6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1},
-      {0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1},
-      {10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1},
-      {10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1},
-      {1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1},
-      {2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1},
-      {7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1},
-      {7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1},
-      {2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1},
-      {1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1},
-      {11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1},
-      {8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1},
-      {0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1},
-      {7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1},
-      {10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1},
-      {2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1},
-      {6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1},
-      {7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1},
-      {2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1},
-      {1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1},
-      {10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1},
-      {10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1},
-      {0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1},
-      {7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1},
-      {6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1},
-      {8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1},
-      {9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1},
-      {6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1},
-      {1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1},
-      {4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1},
-      {10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1},
-      {8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1},
-      {0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1},
-      {1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1},
-      {8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1},
-      {10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1},
-      {4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1},
-      {10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1},
-      {5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1},
-      {11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1},
-      {9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1},
-      {6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1},
-      {7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1},
-      {3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1},
-      {7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1},
-      {9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1},
-      {3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1},
-      {6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1},
-      {9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1},
-      {1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1},
-      {4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1},
-      {7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1},
-      {6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1},
-      {3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1},
-      {0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1},
-      {6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1},
-      {1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1},
-      {0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1},
-      {11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1},
-      {6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1},
-      {5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1},
-      {9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1},
-      {1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1},
-      {1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1},
-      {10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1},
-      {0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1},
-      {5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1},
-      {10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1},
-      {11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1},
-      {0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1},
-      {9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1},
-      {7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1},
-      {2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1},
-      {8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1},
-      {9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1},
-      {9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1},
-      {1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1},
-      {9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1},
-      {9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1},
-      {5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1},
-      {0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1},
-      {10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1},
-      {2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1},
-      {0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1},
-      {0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1},
-      {9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1},
-      {5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1},
-      {3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1},
-      {5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1},
-      {8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1},
-      {0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1},
-      {9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1},
-      {0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1},
-      {1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1},
-      {3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1},
-      {4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1},
-      {9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1},
-      {11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1},
-      {11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1},
-      {2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1},
-      {9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1},
-      {3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1},
-      {1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1},
-      {4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1},
-      {4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1},
-      {0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1},
-      {3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1},
-      {3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1},
-      {0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1},
-      {9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1},
-      {1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-      {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}
-   };
-
-}
diff --git a/graf3d/gl/src/TGLUtil.cxx b/graf3d/gl/src/TGLUtil.cxx
index cc04e5a..dca3213 100644
--- a/graf3d/gl/src/TGLUtil.cxx
+++ b/graf3d/gl/src/TGLUtil.cxx
@@ -603,8 +603,8 @@ void TGLMatrix::Set(const TGLVertex3 & origin, const TGLVector3 & zAxis, const T
 void TGLMatrix::Set(const Double_t vals[16])
 {
    // Set matrix using the 16 Double_t 'vals' passed,
-   // ordering is maintained - i.e. should be column major
-   // as we are
+   // ordering is maintained - i.e. should be column major.
+
    for (UInt_t i=0; i < 16; i++) {
       fVals[i] = vals[i];
    }
@@ -613,12 +613,8 @@ void TGLMatrix::Set(const Double_t vals[16])
 //______________________________________________________________________________
 void TGLMatrix::SetIdentity()
 {
-   // Set matrix to identity:
-   //
-   // 1 0 0 0
-   // 0 1 0 0
-   // 0 0 1 0
-   // 0 0 0 1
+   // Set matrix to identity.
+
    fVals[0] = 1.0; fVals[4] = 0.0; fVals[8 ] = 0.0; fVals[12] = 0.0;
    fVals[1] = 0.0; fVals[5] = 1.0; fVals[9 ] = 0.0; fVals[13] = 0.0;
    fVals[2] = 0.0; fVals[6] = 0.0; fVals[10] = 1.0; fVals[14] = 0.0;
@@ -628,28 +624,16 @@ void TGLMatrix::SetIdentity()
 //______________________________________________________________________________
 void TGLMatrix::SetTranslation(Double_t x, Double_t y, Double_t z)
 {
-   // Set matrix translation components x,y,z:
-   //
-   // . . . x
-   // . . . y
-   // . . . z
-   // . . . .
-   //
-   // The other components are NOT modified
+   // Set matrix translation components x,y,z.
+
    SetTranslation(TGLVertex3(x,y,z));
 }
 
 //______________________________________________________________________________
 void TGLMatrix::SetTranslation(const TGLVertex3 & translation)
 {
-   // Set matrix translation components x,y,z:
-   //
-   // . . . translation.X()
-   // . . . translation.Y()
-   // . . . translation.Z()
-   // . . . .
-   //
-   // . = Exisiting component value - NOT modified
+   // Set matrix translation components x,y,z.
+
    fVals[12] = translation[0];
    fVals[13] = translation[1];
    fVals[14] = translation[2];
@@ -658,12 +642,7 @@ void TGLMatrix::SetTranslation(const TGLVertex3 & translation)
 //______________________________________________________________________________
 TGLVector3 TGLMatrix::GetTranslation() const
 {
-   // Return the translation component of matrix
-   //
-   // . . . X()
-   // . . . Y()
-   // . . . Z()
-   // . . . .
+   // Return the translation component of matrix.
 
    return TGLVector3(fVals[12], fVals[13], fVals[14]);
 }
@@ -671,14 +650,8 @@ TGLVector3 TGLMatrix::GetTranslation() const
 //______________________________________________________________________________
 void TGLMatrix::Translate(const TGLVector3 & vect)
 {
-   // Offset (shift) matrix translation components by 'vect'
-   //
-   // . . . . + vect.X()
-   // . . . . + vect.Y()
-   // . . . . + vect.Z()
-   // . . . .
-   //
-   // . = Exisiting component value - NOT modified
+   // Shift matrix translation components by 'vect' in parent frame.
+
    fVals[12] += vect[0];
    fVals[13] += vect[1];
    fVals[14] += vect[2];
@@ -695,6 +668,16 @@ void TGLMatrix::MoveLF(Int_t ai, Double_t amount)
 }
 
 //______________________________________________________________________________
+void TGLMatrix::Move3LF(Double_t x, Double_t y, Double_t z)
+{
+   // Translate in local frame along all base vectors simultaneously.
+
+   fVals[12] += x*fVals[0] + y*fVals[4] + z*fVals[8];
+   fVals[13] += x*fVals[1] + y*fVals[5] + z*fVals[9];
+   fVals[14] += x*fVals[2] + y*fVals[6] + z*fVals[10];
+}
+
+//______________________________________________________________________________
 void TGLMatrix::Scale(const TGLVector3 & scale)
 {
    // Set matrix axis scales to 'scale'. Note - this really sets
diff --git a/graf3d/gl/src/TGLViewer.cxx b/graf3d/gl/src/TGLViewer.cxx
index adbbf69..e6cca4c 100644
--- a/graf3d/gl/src/TGLViewer.cxx
+++ b/graf3d/gl/src/TGLViewer.cxx
@@ -361,6 +361,14 @@ void TGLViewer::PostSceneBuildSetup(Bool_t resetCameras)
 /**************************************************************************/
 /**************************************************************************/
 
+void TGLViewer::ResetInitGL()
+{
+   // Reset GL initialization flag.
+   // This is needed if GL-context is destroyed from outside.
+
+   fInitGL = kFALSE;
+}
+
 //______________________________________________________________________________
 void TGLViewer::InitGL()
 {
@@ -551,15 +559,15 @@ Bool_t TGLViewer::SavePicture(const TString &fileName)
    // can be covered by other windows.
    // Returns false if something obvious goes wrong, true otherwise.
 
-   if (fileName.EndsWith(".gif") || fileName.Contains("gif+") ||
-            fileName.EndsWith(".jpg") || fileName.EndsWith(".png"))
+   if (fileName.EndsWith(".gif") || fileName.EndsWith(".gif+") ||
+       fileName.EndsWith(".jpg") || fileName.EndsWith(".png"))
    {
       if ( ! TakeLock(kDrawLock)) {
          Error("TGLViewer::SavePicture", "viewer locked - try later.");
          return kFALSE;
       }
 
-      std::auto_ptr<TImage>gif(TImage::Create());
+      std::auto_ptr<TImage> image(TImage::Create());
 
       fRnrCtx->SetGrabImage(kTRUE);
 
@@ -570,13 +578,13 @@ Bool_t TGLViewer::SavePicture(const TString &fileName)
       else
          DoDraw();
 
-      gif->FromGLBuffer(fRnrCtx->GetGrabbedImage(), fViewport.Width(), fViewport.Height());
+      image->FromGLBuffer(fRnrCtx->GetGrabbedImage(), fViewport.Width(), fViewport.Height());
 
       fRnrCtx->SetGrabImage(kFALSE);
       delete [] fRnrCtx->GetGrabbedImage();
       fRnrCtx->SetGrabbedImage(0);
 
-      gif->WriteImage(fileName.Data());
+      image->WriteImage(fileName.Data());
    }
    else if (fileName.EndsWith(".eps"))
    {
@@ -1440,6 +1448,18 @@ void TGLViewer::SetEventHandler(TGEventHandler *handler)
 }
 
 //______________________________________________________________________________
+void  TGLViewer::RemoveOverlayElement(TGLOverlayElement* el)
+{
+   // Remove overlay element.
+
+   if (el == fCurrentOvlElm)
+   {
+      fCurrentOvlElm = 0;
+   }
+   TGLViewerBase::RemoveOverlayElement(el);
+}
+
+//______________________________________________________________________________
 void TGLViewer::ClearCurrentOvlElm()
 {
    // Reset current overlay-element to zero, eventually notifying the
diff --git a/graf3d/gl/src/TGLViewerBase.cxx b/graf3d/gl/src/TGLViewerBase.cxx
index a66a3ce..93801e2 100644
--- a/graf3d/gl/src/TGLViewerBase.cxx
+++ b/graf3d/gl/src/TGLViewerBase.cxx
@@ -14,12 +14,14 @@
 #include "TGLSceneBase.h"
 #include "TGLSceneInfo.h"
 
-#include <TGLRnrCtx.h>
+#include "TGLRnrCtx.h"
 #include "TGLCamera.h"
-#include <TGLOverlay.h>
-#include <TGLSelectBuffer.h>
-#include <TGLSelectRecord.h>
-#include <TGLUtil.h>
+#include "TGLOverlay.h"
+#include "TGLSelectBuffer.h"
+#include "TGLSelectRecord.h"
+#include "TGLAnnotation.h"
+#include "TGLUtil.h"
+
 #include "TGLContext.h"
 #include "TGLIncludes.h"
 
@@ -189,16 +191,37 @@ void TGLViewerBase::AddOverlayElement(TGLOverlayElement* el)
 void TGLViewerBase::RemoveOverlayElement(TGLOverlayElement* el)
 {
    // Remove overlay element.
-   std::vector<TGLOverlayElement*>::iterator it = std::find(fOverlay.begin(), fOverlay.end(), el);
-   if(it != fOverlay.end())
+
+   OverlayElmVec_i it = std::find(fOverlay.begin(), fOverlay.end(), el);
+   if (it != fOverlay.end())
       fOverlay.erase(it);
    Changed();
 }
 
+//______________________________________________________________________
+void TGLViewerBase::DeleteOverlayAnnotations()
+{
+   // Delete overlay elements that are annotations.
+
+   OverlayElmVec_t goners;
+   for (OverlayElmVec_i i = fOverlay.begin(); i != fOverlay.end(); ++i)
+   {
+      if (dynamic_cast<TGLAnnotation*>(*i))
+         goners.push_back(*i);
+   }
+   if ( ! goners.empty())
+   {
+      for (OverlayElmVec_i i = goners.begin(); i != goners.end(); ++i)
+         delete *i;
+      Changed();
+   }
+}
+
 /**************************************************************************/
 // SceneInfo update / check
 /**************************************************************************/
 
+//______________________________________________________________________________
 void TGLViewerBase::ResetSceneInfos()
 {
    // Force rebuild of view-dependent scene-info structures.
@@ -214,6 +237,7 @@ void TGLViewerBase::ResetSceneInfos()
    }
 }
 
+//______________________________________________________________________________
 void TGLViewerBase::MergeSceneBBoxes(TGLBoundingBox& bbox)
 {
    // Merge bounding-boxes of all active registered scenes.
diff --git a/graf3d/gl/src/TGLViewerEditor.cxx b/graf3d/gl/src/TGLViewerEditor.cxx
index a27d741..97c26a8 100644
--- a/graf3d/gl/src/TGLViewerEditor.cxx
+++ b/graf3d/gl/src/TGLViewerEditor.cxx
@@ -45,6 +45,7 @@ TGLViewerEditor::TGLViewerEditor(const TGWindow *p,  Int_t width, Int_t height,
    fCameraCenterX(0),
    fCameraCenterY(0),
    fCameraCenterZ(0),
+   fCaptureAnnotate(),
    fAxesType(0),
    fAxesContainer(0),
    fAxesNone(0),
@@ -97,6 +98,8 @@ void TGLViewerEditor::ConnectSignals2Slots()
    fCameraCenterY->Connect("ValueSet(Long_t)", "TGLViewerEditor", this, "UpdateCameraCenter()");
    fCameraCenterZ->Connect("ValueSet(Long_t)", "TGLViewerEditor", this, "UpdateCameraCenter()");
 
+   fCaptureAnnotate->Connect("Clicked()", "TGLViewerEditor", this, "DoAnnotation()");
+
    fAxesContainer->Connect("Clicked(Int_t)", "TGLViewerEditor", this, "UpdateViewerAxes(Int_t)");
 
    fReferenceOn->Connect("Clicked()", "TGLViewerEditor", this, "UpdateViewerReference()");
@@ -156,10 +159,10 @@ void TGLViewerEditor::SetModel(TObject* obj)
    fCameraCenterX->SetState(fCameraCenterExt->IsDown());
    fCameraCenterY->SetState(fCameraCenterExt->IsDown());
    fCameraCenterZ->SetState(fCameraCenterExt->IsDown());
-   if (fViewer->GetPushAction() == TGLViewer::kPushCamCenter)
-      fCaptureCenter->SetTextColor(0xa03060);
-   else
-      fCaptureCenter->SetTextColor(0x000000);
+
+   // push action
+   fCaptureCenter->SetTextColor((fViewer->GetPushAction() == TGLViewer::kPushCamCenter) ? 0xa03060 : 0x000000);
+   fCaptureAnnotate->SetDown( (fViewer->GetPushAction() == TGLViewer::kPushAnnotate), kFALSE);
 }
 
 //______________________________________________________________________________
@@ -264,6 +267,7 @@ void TGLViewerEditor::DoCaptureCenter()
    // Capture camera-center via picking.
 
    fViewer->PickCameraCenter();
+   ViewerRedraw();
 }
 
 //______________________________________________________________________________
@@ -286,6 +290,14 @@ void TGLViewerEditor::UpdateCameraCenter()
 }
 
 //______________________________________________________________________________
+void TGLViewerEditor::DoAnnotation()
+{
+   // Create annotation via picking.
+
+   fViewer->PickAnnotate();
+}
+
+//______________________________________________________________________________
 void TGLViewerEditor::UpdateViewerAxes(Int_t id)
 {
    // Update viewer with GUI state.
@@ -397,6 +409,12 @@ void TGLViewerEditor::CreateGuidesTab()
    fCaptureCenter = new TGTextButton(grf, " Pick center ");
    grf->AddFrame(fCaptureCenter, new TGLayoutHints(kLHintsNormal, labw + 2, 0, 2, 0));
 
+   // annotate
+   TGGroupFrame* annf  = new TGGroupFrame(fGuidesFrame, "Annotation");
+   fGuidesFrame->AddFrame(annf, new TGLayoutHints(kLHintsTop | kLHintsCenterX | kLHintsExpandX, 2, 3, 0, 0));
+   fCaptureAnnotate = new TGCheckButton(annf, "Pick annotation");
+   annf->AddFrame(fCaptureAnnotate, new TGLayoutHints(kLHintsTop | kLHintsCenterX | kLHintsExpandX));
+
    // reference container
    fRefContainer = new TGGroupFrame(fGuidesFrame, "Reference marker");
    fGuidesFrame->AddFrame(fRefContainer, new TGLayoutHints(kLHintsTop | kLHintsCenterX | kLHintsExpandX, 2, 3, 0, 0));
diff --git a/graf3d/gl/src/TH2GL.cxx b/graf3d/gl/src/TH2GL.cxx
index 2474473..1088e9c 100644
--- a/graf3d/gl/src/TH2GL.cxx
+++ b/graf3d/gl/src/TH2GL.cxx
@@ -10,7 +10,8 @@
  *************************************************************************/
 
 #include "TH2GL.h"
-#include <TH2.h>
+#include "TH2.h"
+#include "TH3.h"
 #include "TVirtualPad.h"
 
 #include "TGLSurfacePainter.h"
@@ -24,7 +25,7 @@
 
 #include "TGLIncludes.h"
 
-//______________________________________________________________________
+//______________________________________________________________________________
 // TH2GL
 //
 // Rendering of TH2 and derived classes.
@@ -39,6 +40,8 @@ TH2GL::TH2GL() : TGLObject(), fM(0), fPlotPainter(0)
    fDLCache = kFALSE; // Disable display list.
 }
 
+
+//______________________________________________________________________________
 TH2GL::~TH2GL()
 {
    // Destructor.
@@ -46,24 +49,20 @@ TH2GL::~TH2GL()
    delete fPlotPainter;
 }
 
-/**************************************************************************/
 
+//______________________________________________________________________________
 Bool_t TH2GL::SetModel(TObject* obj, const Option_t* opt)
 {
    // Set model object.
+   TString option(opt);
+   option.ToLower();
 
    if(SetModelCheckClass(obj, TH2::Class()))
    {
       fM = dynamic_cast<TH2*>(obj);
 
-      TString option(opt);
-
       // Plot type
-      if (option.Index("iso") != kNPOS)
-         fPlotPainter = new TGLIsoPainter(fM, 0, &fCoord);
-      else if (option.Index("box") != kNPOS)
-         fPlotPainter = new TGLBoxPainter(fM, 0, &fCoord);
-      else if (option.Index("surf") != kNPOS)
+      if (option.Index("surf") != kNPOS)
          fPlotPainter = new TGLSurfacePainter(fM, 0, &fCoord);
       else
          fPlotPainter = new TGLLegoPainter(fM, 0, &fCoord);
@@ -81,13 +80,26 @@ Bool_t TH2GL::SetModel(TObject* obj, const Option_t* opt)
          fCoord.SetCoordType(kGLCylindrical);
 
       fPlotPainter->AddOption(option);
+      fPlotPainter->InitGeometry();
+      return kTRUE;
+   } else if (SetModelCheckClass(obj, TH3::Class())) {
+      fM = dynamic_cast<TH3 *>(obj);
 
+      if (option.Index("iso") != kNPOS)
+         fPlotPainter = new TGLIsoPainter(fM, 0, &fCoord);
+      else if (option.Index("box") != kNPOS)
+         fPlotPainter = new TGLBoxPainter(fM, 0, &fCoord);
+
+      fPlotPainter->AddOption(option);
       fPlotPainter->InitGeometry();
       return kTRUE;
    }
+
    return kFALSE;
 }
 
+
+//______________________________________________________________________________
 void TH2GL::SetBBox()
 {
    // Setup bounding-box.
@@ -95,15 +107,19 @@ void TH2GL::SetBBox()
    fBoundingBox.Set(fPlotPainter->RefBackBox().Get3DBox());
 }
 
-/**************************************************************************/
 
+//______________________________________________________________________________
 void TH2GL::DirectDraw(TGLRnrCtx & /*rnrCtx*/) const
 {
    // Render the object.
 
    fPlotPainter->RefBackBox().FindFrontPoint();
+
    glPushAttrib(GL_ENABLE_BIT | GL_LIGHTING_BIT);
+
    glEnable(GL_NORMALIZE);
+   glDisable(GL_COLOR_MATERIAL);
+
    fPlotPainter->InitGL();
    fPlotPainter->DrawPlot();
 
diff --git a/gui/doc/v524/index.html b/gui/doc/v524/index.html
new file mode 100644
index 0000000..6c4f00b
--- /dev/null
+++ b/gui/doc/v524/index.html
@@ -0,0 +1,4 @@
+<br> 
+<hr> 
+<a name="gui"></a> 
+<h3>GUI</h3>
diff --git a/gui/fitpanel/inc/TFitEditor.h b/gui/fitpanel/inc/TFitEditor.h
index 9cefe38..c44441b 100644
--- a/gui/fitpanel/inc/TFitEditor.h
+++ b/gui/fitpanel/inc/TFitEditor.h
@@ -127,14 +127,9 @@ protected:
       Double_t & operator[](UInt_t i) { return fP[i];}
       Double_t fP[3];
    };
-   std::vector<FuncParamData_t >  fFuncPars;         // function parameters (value + limits)
-
-   Double_t             fFuncXmin;       // fit function range (min and max) values    
-   Double_t             fFuncXmax;      
-   Double_t             fFuncYmin;      
-   Double_t             fFuncYmax;      
-   Double_t             fFuncZmin;      
-   Double_t             fFuncZmax;      
+   std::vector<FuncParamData_t>  fFuncPars;         // function parameters (value + limits)
+
+   std::vector<TF1*> fPrevFit;             // Previous succesful fits.
 
    TGRadioButton       *fLibMinuit;        // set default minimization library (Minuit)
    TGRadioButton       *fLibMinuit2;       // set Minuit2 as minimization library
diff --git a/gui/fitpanel/src/TFitEditor.cxx b/gui/fitpanel/src/TFitEditor.cxx
index 733a81b..39e84cb 100644
--- a/gui/fitpanel/src/TFitEditor.cxx
+++ b/gui/fitpanel/src/TFitEditor.cxx
@@ -156,6 +156,7 @@
 #include "TTreeInput.h"
 #include "TAdvancedGraphicsDialog.h"
 
+#include <sstream>
 #include <vector>
 #include <queue>
 using std::vector;
@@ -1350,10 +1351,6 @@ void TFitEditor::SetFitObject(TVirtualPad *pad, TObject *obj, Int_t event)
       //fFuncPars = FuncParams_t( fitFunc->GetNpar() );
       GetParameters(fFuncPars, fitFunc);
 
-      // get function range
-      fitFunc->GetRange(fFuncXmin, fFuncYmin, fFuncZmin, fFuncXmax,  fFuncYmax,  fFuncZmax);
-
-
       TString tmpStr = fitFunc->GetExpFormula();
       TGLBEntry *en = 0;
       if ( tmpStr.Length() == 0 )
@@ -1499,15 +1496,23 @@ void TFitEditor::FillFunctionList(Int_t)
       TObject* obj;
       while( ( obj = (TObject*) functionsIter() ) ) {
          if ( TF1* func = dynamic_cast<TF1*>(obj) ) {
-            fFuncList->AddEntry(func->GetName(), newid++); 
+            // Do not include functions used previously to fit
+            if ( strncmp(func->GetName(), "PrevFit", 7) != 0 )
+               fFuncList->AddEntry(func->GetName(), newid++); 
          }
       }
        if ( newid != kFP_ALTFUNC )
             fFuncList->Select(newid-1);
    } 
    else if ( fTypeFit->GetSelected() == kFP_PREVFIT ) {
-      TList *listOfFunctions = GetFitObjectListOfFunctions();
       Int_t newid = kFP_ALTFUNC;
+
+      for ( std::vector<TF1*>::iterator i = fPrevFit.begin();
+            i != fPrevFit.end(); ++i ) {
+         fFuncList->AddEntry((*i)->GetName(), newid++);
+      }
+
+      TList *listOfFunctions = GetFitObjectListOfFunctions();
       if ( listOfFunctions ) {
          TIter next(listOfFunctions, kIterForward);
          TObject* obj;
@@ -1775,6 +1780,13 @@ void TFitEditor::DoFit()
    //if (!fFuncPars) fFuncPars = new Double_t[fitFunc->GetNpar()][3];
    GetParameters(fFuncPars,fitFunc);
 
+   // Save fit data for future use
+   TF1* tmpTF1 = static_cast<TF1*>( fitFunc->Clone() );
+   ostringstream name;
+   name << "PrevFit" << fPrevFit.size() + 1;
+   tmpTF1->SetName(name.str().c_str());
+   fPrevFit.push_back(tmpTF1);
+
    float xmin, xmax, ymin, ymax, zmin, zmax;
    if ( fParentPad ) {
       fParentPad->Modified();
@@ -1956,9 +1968,9 @@ void TFitEditor::DoFunction(Int_t selected)
          np = tmp.GetNpar();
       }
       if (np)
-         s += Form("+%s(%d)", te->GetTitle(), np);
+         s += TString::Format("+%s(%d)", te->GetTitle(), np);
       else
-         s += Form("%s(%d)", te->GetTitle(), np);
+         s += TString::Format("%s(%d)", te->GetTitle(), np);
       fEnteredFunc->SetText(s.Data());
       editable = true;
    }
diff --git a/gui/ged/inc/TGedEditor.h b/gui/ged/inc/TGedEditor.h
index fb9b9f5..5964ffb 100644
--- a/gui/ged/inc/TGedEditor.h
+++ b/gui/ged/inc/TGedEditor.h
@@ -88,8 +88,8 @@ public:
 
    TGCanvas*                 GetTGCanvas() const { return fCan; }
    TGTab*                    GetTab()      const { return fTab; }
-   virtual TGCompositeFrame* GetEditorTab(const Text_t* name);
-   virtual TGedTabInfo*      GetEditorTabInfo(const Text_t* name);
+   virtual TGCompositeFrame* GetEditorTab(const char* name);
+   virtual TGedTabInfo*      GetEditorTabInfo(const char* name);
 
    virtual TCanvas*          GetCanvas() const { return fCanvas; }
    virtual TVirtualPad*      GetPad()    const { return fPad; }
diff --git a/gui/ged/inc/TGedFrame.h b/gui/ged/inc/TGedFrame.h
index c75e999..1976637 100644
--- a/gui/ged/inc/TGedFrame.h
+++ b/gui/ged/inc/TGedFrame.h
@@ -81,7 +81,7 @@ public:
    TList*            GetExtraTabs()               { return fExtraTabs;   }
    TGedEditor*       GetGedEditor()               { return fGedEditor;   }
    virtual void      AddExtraTab(TGedSubFrame* sf);
-   virtual TGVerticalFrame* CreateEditorTabSubFrame(const Text_t* name);
+   virtual TGVerticalFrame* CreateEditorTabSubFrame(const char* name);
 
    virtual void      Refresh(TObject *model);
    virtual void      SetDrawOption(Option_t *option="");
diff --git a/gui/ged/src/TGedEditor.cxx b/gui/ged/src/TGedEditor.cxx
index beef845..c410950 100644
--- a/gui/ged/src/TGedEditor.cxx
+++ b/gui/ged/src/TGedEditor.cxx
@@ -183,7 +183,7 @@ void TGedEditor::Update(TGedFrame* /*frame*/)
 }
 
 //______________________________________________________________________________
-TGCompositeFrame* TGedEditor::GetEditorTab(const Text_t* name)
+TGCompositeFrame* TGedEditor::GetEditorTab(const char* name)
 {
    // Find or create tab with name.
 
@@ -191,7 +191,7 @@ TGCompositeFrame* TGedEditor::GetEditorTab(const Text_t* name)
 }
 
 //______________________________________________________________________________
-TGedTabInfo* TGedEditor::GetEditorTabInfo(const Text_t* name)
+TGedTabInfo* TGedEditor::GetEditorTabInfo(const char* name)
 {
    // Find or create tab with name.
 
diff --git a/gui/ged/src/TGedFrame.cxx b/gui/ged/src/TGedFrame.cxx
index 4d12351..4f23c88 100644
--- a/gui/ged/src/TGedFrame.cxx
+++ b/gui/ged/src/TGedFrame.cxx
@@ -132,7 +132,7 @@ void TGedFrame::AddExtraTab(TGedSubFrame* sf)
 }
 
 //______________________________________________________________________________
-TGVerticalFrame* TGedFrame::CreateEditorTabSubFrame(const Text_t* name)
+TGVerticalFrame* TGedFrame::CreateEditorTabSubFrame(const char* name)
 {
    // Create a vertical frame to be used by 'owner' in extra tab 'name'.
    // The new frame is registered into the sub-frame list.
@@ -270,8 +270,8 @@ void TGedNameFrame::SetModel(TObject* obj)
    string.Append(obj->ClassName());
 
    fLabel->SetText(new TGString(string));
-   string = Form("Name: %s\nTitle:   %s\nClass: %s",
-                 obj->GetName(), obj->GetTitle(), obj->ClassName());
+   string = TString::Format("Name: %s\nTitle:   %s\nClass: %s",
+                            obj->GetName(), obj->GetTitle(), obj->ClassName());
    fTip->SetText(string);
 
    // Resize label-frame to a reasonable width.
diff --git a/gui/ged/src/TStyleManager.cxx b/gui/ged/src/TStyleManager.cxx
index c8ddfc4..64b0c1f 100644
--- a/gui/ged/src/TStyleManager.cxx
+++ b/gui/ged/src/TStyleManager.cxx
@@ -1741,12 +1741,12 @@ void TStyleManager::ConnectAll()
    Connect("CloseWindow()", "TStyleManager", this, "CloseWindow()");
    fMenuStyle->Connect("Activated(Int_t)", "TStyleManager", this, "DoMenu(Int_t)");
    fMenuHelp->Connect("Activated(Int_t)", "TStyleManager", this, "DoMenu(Int_t)");
-   fToolBarNew->Connect("Clicked()", "TStyleManager", this, Form("DoMenu(Int_t=%d)", kMenuNew));
-   fToolBarDelete->Connect("Clicked()", "TStyleManager", this, Form("DoMenu(Int_t=%d)", kMenuDelete));
-   fToolBarImportCanvas->Connect("Clicked()", "TStyleManager", this, Form("DoMenu(Int_t=%d)", kMenuImportCanvas));
-   fToolBarImportMacro->Connect("Clicked()", "TStyleManager", this, Form("DoMenu(Int_t=%d)", kMenuImportMacro));
-   fToolBarExport->Connect("Clicked()", "TStyleManager", this, Form("DoMenu(Int_t=%d)", kMenuExport));
-   fToolBarHelp->Connect("Clicked()", "TStyleManager", this, Form("DoMenu(Int_t=%d)", kMenuHelp));
+   fToolBarNew->Connect("Clicked()", "TStyleManager", this, TString::Format("DoMenu(Int_t=%d)", kMenuNew));
+   fToolBarDelete->Connect("Clicked()", "TStyleManager", this, TString::Format("DoMenu(Int_t=%d)", kMenuDelete));
+   fToolBarImportCanvas->Connect("Clicked()", "TStyleManager", this, TString::Format("DoMenu(Int_t=%d)", kMenuImportCanvas));
+   fToolBarImportMacro->Connect("Clicked()", "TStyleManager", this, TString::Format("DoMenu(Int_t=%d)", kMenuImportMacro));
+   fToolBarExport->Connect("Clicked()", "TStyleManager", this, TString::Format("DoMenu(Int_t=%d)", kMenuExport));
+   fToolBarHelp->Connect("Clicked()", "TStyleManager", this, TString::Format("DoMenu(Int_t=%d)", kMenuHelp));
    fListComboBox->Connect("Selected(Int_t)", "TStyleManager", this, "DoListSelect()");
    fPreviewButton->Connect("Toggled(Bool_t)", "TStyleManager", this, "DoPreview(Bool_t)");
    fPreviewRealTime->Connect("Toggled(Bool_t)", "TStyleManager", this, "DoRealTime(Bool_t)");
@@ -1755,7 +1755,7 @@ void TStyleManager::ConnectAll()
    fApplyOnButton->Connect("Clicked()", "TStyleManager", this, "DoApplyOn()");
    fMoreLess->Connect("Clicked()", "TStyleManager", this, "DoMoreLess()");
 
-   fEditionHelp->Connect("Clicked()", "TStyleManager", this, Form("DoMenu(Int_t=%d)", kMenuHelpEditor));
+   fEditionHelp->Connect("Clicked()", "TStyleManager", this, TString::Format("DoMenu(Int_t=%d)", kMenuHelpEditor));
    fEditionUpdatePreview->Connect("Clicked()", "TStyleManager", this, "DoEditionUpdatePreview()");
    fEditionReset->Connect("Clicked()", "TStyleManager", this, "DoImportMacro(Int_t=kFALSE)");
    fEditionTab->Connect("Selected(Int_t)", "TStyleManager", this, "DoChangeTab(Int_t)");
diff --git a/gui/gui/inc/TGFSContainer.h b/gui/gui/inc/TGFSContainer.h
index 6e197b0..5f515b7 100644
--- a/gui/gui/inc/TGFSContainer.h
+++ b/gui/gui/inc/TGFSContainer.h
@@ -108,7 +108,7 @@ public:
    }
 
    virtual Bool_t HandleDNDFinished() {
-      return ((TGFrame *)GetParent())->HandleDNDFinished();
+      return ((TGFrame *)(const_cast<TGWindow*>(GetParent())))->HandleDNDFinished();
    }
 
    void SetDNDData(TDNDData *data) {
diff --git a/gui/gui/inc/TGObject.h b/gui/gui/inc/TGObject.h
index 3aa6337..b17bad8 100644
--- a/gui/gui/inc/TGObject.h
+++ b/gui/gui/inc/TGObject.h
@@ -52,7 +52,7 @@ public:
    Handle_t  GetId() const { return fId; }
    TGClient *GetClient() const { return fClient; }
    ULong_t   Hash() const { return (ULong_t) fId >> 0; }
-   Bool_t    IsEqual(const TObject *obj) const { return fId == ((TGObject *) obj)->fId; }
+   Bool_t    IsEqual(const TObject *obj) const { return fId == ((const TGObject *) obj)->fId; }
    virtual void SaveAs(const char* filename = "", Option_t* option = "") const;
 
    ClassDef(TGObject,0)  //ROOT GUI base class
diff --git a/gui/gui/inc/TGSlider.h b/gui/gui/inc/TGSlider.h
index e918b0e..82e5334 100644
--- a/gui/gui/inc/TGSlider.h
+++ b/gui/gui/inc/TGSlider.h
@@ -94,6 +94,7 @@ public:
    virtual ~TGSlider() { }
 
    virtual Bool_t HandleButton(Event_t *event) = 0;
+   virtual Bool_t HandleConfigureNotify(Event_t* event) = 0;
    virtual Bool_t HandleMotion(Event_t *event) = 0;
 
    virtual void  SetScale(Int_t scale) { fScale = scale; }                          //*MENU*
@@ -132,6 +133,7 @@ public:
    virtual ~TGVSlider();
 
    virtual Bool_t HandleButton(Event_t *event);
+   virtual Bool_t HandleConfigureNotify(Event_t* event);
    virtual Bool_t HandleMotion(Event_t *event);
    virtual TGDimension GetDefaultSize() const
                      { return TGDimension(kSliderWidth, fHeight); }
@@ -158,6 +160,7 @@ public:
    virtual ~TGHSlider();
 
    virtual Bool_t HandleButton(Event_t *event);
+   virtual Bool_t HandleConfigureNotify(Event_t* event);
    virtual Bool_t HandleMotion(Event_t *event);
    virtual TGDimension GetDefaultSize() const
                      { return TGDimension(fWidth, kSliderHeight); }
diff --git a/gui/gui/src/TGClient.cxx b/gui/gui/src/TGClient.cxx
index 1a2809b..467cfdd 100644
--- a/gui/gui/src/TGClient.cxx
+++ b/gui/gui/src/TGClient.cxx
@@ -52,9 +52,18 @@
 TGClient *gClient = 0;
 
 // Initialize gClient in case libGui is loaded in batch mode
+extern "C" void G__cpp_setup_tagtableG__Gui1();
 class TGClientInit {
 public:
-   TGClientInit() { if (gROOT && gROOT->IsBatch()) new TGClient(); TApplication::NeedGraphicsLibs(); }
+   TGClientInit() { 
+      if (gROOT && gROOT->IsBatch()) {
+         // Insure that the CINT dictionary is initialized __before__ the TGClient creation which
+         // will induce the creation of a TClass object which will need the dictionary for TGClient!
+         G__cpp_setup_tagtableG__Gui1(); 
+         new TGClient();
+      }
+      TApplication::NeedGraphicsLibs(); 
+   }
 };
 static TGClientInit gClientInit;
 
diff --git a/gui/gui/src/TGColorSelect.cxx b/gui/gui/src/TGColorSelect.cxx
index f542c2f..85e0f35 100644
--- a/gui/gui/src/TGColorSelect.cxx
+++ b/gui/gui/src/TGColorSelect.cxx
@@ -594,7 +594,7 @@ void TGColorSelect::SavePrimitive(ostream &out, Option_t * /*= ""*/)
 
    char quote = '"';
    static Int_t nn = 1;
-   TString cvar = Form("ColPar%d",nn);
+   TString cvar = TString::Format("ColPar%d",nn);
 
    ULong_t color = GetColor();
    const char *colorname = TColor::PixelAsHexString(color);
diff --git a/gui/gui/src/TGComboBox.cxx b/gui/gui/src/TGComboBox.cxx
index 3039996..f060373 100644
--- a/gui/gui/src/TGComboBox.cxx
+++ b/gui/gui/src/TGComboBox.cxx
@@ -647,7 +647,8 @@ TGLineStyleComboBox::TGLineStyleComboBox(const TGWindow *p, Int_t id,
    fSelEntry->ChangeOptions(fSelEntry->GetOptions() | kOwnBackground);
 
    for (Int_t i = 1; i <= 10; i++)
-      AddEntry(new TGLineLBEntry(GetListBox()->GetContainer(), i, Form("%d",i), 0, i),
+      AddEntry(new TGLineLBEntry(GetListBox()->GetContainer(), i, 
+               TString::Format("%d",i), 0, i),
                new TGLayoutHints(kLHintsTop | kLHintsExpandX));
 
    Select(1, kFALSE);  // to have first entry selected
@@ -688,7 +689,8 @@ TGLineWidthComboBox::TGLineWidthComboBox(const TGWindow *p, Int_t id,
    }
 
    for (Int_t i = 1; i < 16; i++)
-      AddEntry(new TGLineLBEntry(GetListBox()->GetContainer(), i, Form("%d",i), i, 0),
+      AddEntry(new TGLineLBEntry(GetListBox()->GetContainer(), i, 
+               TString::Format("%d",i), i, 0),
                new TGLayoutHints(kLHintsTop | kLHintsExpandX));
    Select(1, kFALSE);  // to have first entry selected
    SetWindowName();
diff --git a/gui/gui/src/TGCommandPlugin.cxx b/gui/gui/src/TGCommandPlugin.cxx
index a18cf6d..6780fb2 100644
--- a/gui/gui/src/TGCommandPlugin.cxx
+++ b/gui/gui/src/TGCommandPlugin.cxx
@@ -81,7 +81,8 @@ TGCommandPlugin::~TGCommandPlugin()
 {
    // Destructor.
 
-   TString pathtmp = Form("%s/command.%d.log", gSystem->TempDirectory(), fPid);
+   TString pathtmp = TString::Format("%s/command.%d.log", 
+                                     gSystem->TempDirectory(), fPid);
    gSystem->Unlink(pathtmp);
    delete fTimer;
    Cleanup();
@@ -123,7 +124,8 @@ void TGCommandPlugin::HandleCommand()
    if (strlen(string) > 1) {
       // form temporary file path
       TString sPrompt = "root []";
-      TString pathtmp = Form("%s/command.%d.log", gSystem->TempDirectory(), fPid);
+      TString pathtmp = TString::Format("%s/command.%d.log", 
+                                        gSystem->TempDirectory(), fPid);
       TApplication *app = gROOT->GetApplication();
       if (app->InheritsFrom("TRint"))
          sPrompt = ((TRint*)gROOT->GetApplication())->GetPrompt();
diff --git a/gui/gui/src/TGFSContainer.cxx b/gui/gui/src/TGFSContainer.cxx
index 7c3ddfd..950c62a 100644
--- a/gui/gui/src/TGFSContainer.cxx
+++ b/gui/gui/src/TGFSContainer.cxx
@@ -323,8 +323,8 @@ TGFileItem::TGFileItem(const TGWindow *p,
          fSubnames[3] = new TGString(user_group->fGroup);
          delete user_group;
       } else {
-         fSubnames[2] = new TGString(Form("%d", fUid));
-         fSubnames[3] = new TGString(Form("%d", fGid));
+         fSubnames[2] = new TGString(TString::Format("%d", fUid));
+         fSubnames[3] = new TGString(TString::Format("%d", fGid));
       }
    }
 
diff --git a/gui/gui/src/TGFileBrowser.cxx b/gui/gui/src/TGFileBrowser.cxx
index ee1e284..a039fd3 100644
--- a/gui/gui/src/TGFileBrowser.cxx
+++ b/gui/gui/src/TGFileBrowser.cxx
@@ -226,10 +226,17 @@ void TGFileBrowser::Add(TObject *obj, const char *name, Int_t check)
    // called by a browser. If check < 0 (default) no check box is drawn,
    // if 0 then unchecked checkbox is added, if 1 checked checkbox is added.
 
-   if (obj && obj->InheritsFrom("TApplication"))
-      fListLevel = 0;
-   if (obj && obj->InheritsFrom("TSystemDirectory"))
-      return;
+   if (fListLevel && !strcmp(fListLevel->GetText(), "Classes") &&
+      fListLevel->GetParent() && 
+      !strcmp(fListLevel->GetParent()->GetText(), "root")) {
+      // Browsing list of root classes...
+   }
+   else {
+      if (obj && obj->InheritsFrom("TApplication"))
+         fListLevel = 0;
+      if (obj && obj->InheritsFrom("TSystemDirectory"))
+         return;
+   }
    const TGPicture *pic=0;
    if (obj && obj->InheritsFrom("TKey") && (obj->IsA() != TClass::Class()))
       AddKey(fListLevel, obj, name);
@@ -361,7 +368,7 @@ void TGFileBrowser::BrowseObj(TObject *obj)
          TIter next(volumes);
          TNamed *drive;
          while ((drive = (TNamed *)next())) {
-            AddFSDirectory(Form("%s\\", drive->GetName()), drive->GetTitle(), 
+            AddFSDirectory(TString::Format("%s\\", drive->GetName()), drive->GetTitle(), 
                            (strcmp(drive->GetName(), curdrive) == 0) ? 
                            "SetRootDir" : "Add");
          }
@@ -372,6 +379,8 @@ void TGFileBrowser::BrowseObj(TObject *obj)
          AddFSDirectory("/");
       }
       GotoDir(gSystem->WorkingDirectory());
+      if (gROOT->GetListOfFiles() && !gROOT->GetListOfFiles()->IsEmpty())
+         Selected(0);
    }
 }
 
@@ -562,21 +571,20 @@ void TGFileBrowser::AddKey(TGListTreeItem *itm, TObject *obj, const char *name)
    }
    if ((fNKeys > fGroupSize) && (fCnt % fGroupSize == 0)) {
       if (item != itm) {
-         TString newname = Form("%s-%s", item->GetText(), name);
+         TString newname = TString::Format("%s-%s", item->GetText(), name);
          item->Rename(newname.Data());
       }
       item = fListTree->AddItem(itm, name);
       item->SetDNDSource(kTRUE);
    }
    if ((fCnt > fGroupSize) && (fCnt >= fNKeys-1)) {
-      TString newname = Form("%s-%s", item->GetText(), name);
+      TString newname = TString::Format("%s-%s", item->GetText(), name);
       item->Rename(newname.Data());
    }
    GetObjPicture(&pic, obj);
-   if (!pic) pic = gClient->GetPicture("leaf_t.xpm");
    if (!fListTree->FindChildByName(item, name)) {
       TGListTreeItem *it = fListTree->AddItem(item, name, obj, pic, pic);
-      if ((pic != fFileIcon) && (pic != fCachedPic))
+      if (pic && (pic != fFileIcon) && (pic != fCachedPic))
          fClient->FreePicture(pic);
       it->SetDNDSource(kTRUE);
    }
@@ -631,9 +639,9 @@ void TGFileBrowser::CheckRemote(TGListTreeItem *item)
    if (obj) {
       if (obj->InheritsFrom("TApplicationRemote")) {
          if (!gApplication->GetAppRemote()) {
-            gROOT->ProcessLine(Form(".R %s", item->GetText()));
+            gROOT->ProcessLine(TString::Format(".R %s", item->GetText()));
             if (gApplication->GetAppRemote()) {
-               Getlinem(kInit, Form("\n%s:root [0]",
+               Getlinem(kInit, TString::Format("\n%s:root [0]",
                         gApplication->GetAppRemote()->ApplicationName()));
             }
          }
@@ -642,9 +650,9 @@ void TGFileBrowser::CheckRemote(TGListTreeItem *item)
          ((TObject *)item->GetParent()->GetUserData())->InheritsFrom("TApplicationRemote")) {
          // switch to remote session
          if (!gApplication->GetAppRemote()) {
-            gROOT->ProcessLine(Form(".R %s", item->GetParent()->GetText()));
+            gROOT->ProcessLine(TString::Format(".R %s", item->GetParent()->GetText()));
             if (gApplication->GetAppRemote()) {
-               Getlinem(kInit, Form("\n%s:root [0]",
+               Getlinem(kInit, TString::Format("\n%s:root [0]",
                         gApplication->GetAppRemote()->ApplicationName()));
             }
          }
@@ -666,9 +674,9 @@ void TGFileBrowser::CheckRemote(TGListTreeItem *item)
             // it belongs to a remote session
             if (!gApplication->GetAppRemote()) {
                // switch to remote session if not already in
-               gROOT->ProcessLine(Form(".R %s", top->GetText()));
+               gROOT->ProcessLine(TString::Format(".R %s", top->GetText()));
                if (gApplication->GetAppRemote()) {
-                  Getlinem(kInit, Form("\n%s:root [0]",
+                  Getlinem(kInit, TString::Format("\n%s:root [0]",
                            gApplication->GetAppRemote()->ApplicationName()));
                }
             }
@@ -702,7 +710,7 @@ void TGFileBrowser::Clicked(TGListTreeItem *item, Int_t btn, Int_t x, Int_t y)
       if (obj) {
          if (obj->InheritsFrom("TKey") && (obj->IsA() != TClass::Class())) {
             Chdir(item);
-            const char *clname = (const char *)gROOT->ProcessLine(Form("((TKey *)0x%lx)->GetClassName();", obj));
+            const char *clname = (const char *)gROOT->ProcessLine(TString::Format("((TKey *)0x%lx)->GetClassName();", obj));
             if (clname) {
                TClass *cl = TClass::GetClass(clname);
                void *add = gROOT->FindObject((char *) obj->GetName());
@@ -789,7 +797,7 @@ TString TGFileBrowser::DirName(TGListTreeItem* item)
    char   winName[256];
    char   winExt[256];
    _splitpath(fullpath.Data(), winDrive, winDir, winName, winExt);
-   dirname = Form("%s%s", winDrive, winDir);
+   dirname = TString::Format("%s%s", winDrive, winDir);
 #else
    dirname = gSystem->DirName(fullpath);
 #endif
@@ -866,7 +874,7 @@ void TGFileBrowser::DoubleClicked(TGListTreeItem *item, Int_t /*btn*/)
       }
       else if (obj->InheritsFrom("TKey") && (obj->IsA() != TClass::Class())) {
          Chdir(item);
-         const char *clname = (const char *)gROOT->ProcessLine(Form("((TKey *)0x%lx)->GetClassName();", obj));
+         const char *clname = (const char *)gROOT->ProcessLine(TString::Format("((TKey *)0x%lx)->GetClassName();", obj));
          if (clname) {
             TClass *cl = TClass::GetClass(clname);
             void *add = gROOT->FindObject((char *) obj->GetName());
@@ -895,7 +903,7 @@ void TGFileBrowser::DoubleClicked(TGListTreeItem *item, Int_t /*btn*/)
                // remotely browse file (remotely call TFile::cd())
                gApplication->SetBit(TApplication::kProcessRemotely);
                gApplication->ProcessLine(
-                  Form("((TApplicationServer *)gApplication)->BrowseFile(\"%s\");",
+                  TString::Format("((TApplicationServer *)gApplication)->BrowseFile(\"%s\");",
                        probj->GetName()));
                gSystem->Sleep(250);
             }
@@ -975,7 +983,7 @@ void TGFileBrowser::DoubleClicked(TGListTreeItem *item, Int_t /*btn*/)
                   itm = fListTree->AddItem(item,fname,pic,pic);
                   if (pic != fFileIcon)
                      fClient->FreePicture(pic);
-                  itm->SetUserData(new TObjString(Form("file://%s/%s\r\n",
+                  itm->SetUserData(new TObjString(TString::Format("file://%s/%s\r\n",
                                    gSystem->UnixPathName(file->GetTitle()),
                                    file->GetName())), kTRUE);
                   itm->SetDNDSource(kTRUE);
@@ -1000,7 +1008,7 @@ void TGFileBrowser::DoubleClicked(TGListTreeItem *item, Int_t /*btn*/)
          gSystem->ChangeDirectory(dirname.Data());
          rfile = (TDirectory *)gROOT->GetListOfFiles()->FindObject(obj);
          if (!rfile) {
-            rfile = (TDirectory *)gROOT->ProcessLine(Form("new TFile(\"%s\")",fname.Data()));
+            rfile = (TDirectory *)gROOT->ProcessLine(TString::Format("new TFile(\"%s\")",fname.Data()));
          }
          if (rfile) {
             // replace actual user data (TObjString) by the TDirectory...
@@ -1022,6 +1030,7 @@ void TGFileBrowser::DoubleClicked(TGListTreeItem *item, Int_t /*btn*/)
       else if (fname.EndsWith(".png")) {
          gSystem->ChangeDirectory(dirname.Data());
          XXExecuteDefaultAction(&f);
+         gSystem->ChangeDirectory(savdir.Data());
       }
       else if (IsTextFile(fullpath.Data())) {
          gSystem->ChangeDirectory(dirname.Data());
@@ -1036,11 +1045,11 @@ void TGFileBrowser::DoubleClicked(TGListTreeItem *item, Int_t /*btn*/)
                TString fullname = f.GetTitle();
                fullname.ReplaceAll("\\", "\\\\");
                if (embed->InheritsFrom("TGTextEditor")) {
-                  gROOT->ProcessLine(Form("((TGTextEditor *)0x%lx)->LoadFile(\"%s\");",
+                  gROOT->ProcessLine(TString::Format("((TGTextEditor *)0x%lx)->LoadFile(\"%s\");",
                                      embed, fullname.Data()));
                }
                else if (embed->InheritsFrom("TGTextEdit")) {
-                  gROOT->ProcessLine(Form("((TGTextEdit *)0x%lx)->LoadFile(\"%s\");",
+                  gROOT->ProcessLine(TString::Format("((TGTextEdit *)0x%lx)->LoadFile(\"%s\");",
                                      embed, fullname.Data()));
                }
                else {
@@ -1051,13 +1060,15 @@ void TGFileBrowser::DoubleClicked(TGListTreeItem *item, Int_t /*btn*/)
                XXExecuteDefaultAction(&f);
             }
          }
+         gSystem->ChangeDirectory(savdir.Data());
       }
       else {
          gSystem->ChangeDirectory(dirname.Data());
          XXExecuteDefaultAction(&f);
+         gSystem->ChangeDirectory(savdir.Data());
       }
    }
-   gSystem->ChangeDirectory(savdir.Data());
+   //gSystem->ChangeDirectory(savdir.Data());
    fListTree->ClearViewPort();
 }
 
@@ -1105,18 +1116,18 @@ char *TGFileBrowser::FormatFileInfo(const char *fname, Long64_t size, Long_t mod
       fsize /= 1024;
       if (fsize > 1024) {
          // 3.7MB is more informative than just 3MB
-         infos += Form("Size: %lld.%lldM", fsize/1024, (fsize%1024)/103);
+         infos += TString::Format("Size: %lld.%lldM", fsize/1024, (fsize%1024)/103);
       } else {
-         infos += Form("Size: %lld.%lldK", bsize/1024, (bsize%1024)/103);
+         infos += TString::Format("Size: %lld.%lldK", bsize/1024, (bsize%1024)/103);
       }
    } else {
-      infos += Form("Size: %lld", bsize);
+      infos += TString::Format("Size: %lld", bsize);
    }
    struct tm *newtime;
    time_t loctime = (time_t) modtime;
    newtime = localtime(&loctime);
    infos += "\n";
-   infos += Form("%d-%02d-%02d %02d:%02d", newtime->tm_year + 1900,
+   infos += TString::Format("%d-%02d-%02d %02d:%02d", newtime->tm_year + 1900,
            newtime->tm_mon+1, newtime->tm_mday, newtime->tm_hour,
            newtime->tm_min);
    return StrDup(infos.Data());
@@ -1138,12 +1149,12 @@ void TGFileBrowser::GetObjPicture(const TGPicture **pic, TObject *obj)
       objClass = obj->IsA();
    }
    else if (obj->InheritsFrom("TKey")) {
-      const char *clname = (const char *)gROOT->ProcessLine(Form("((TKey *)0x%lx)->GetClassName();", obj));
+      const char *clname = (const char *)gROOT->ProcessLine(TString::Format("((TKey *)0x%lx)->GetClassName();", obj));
       if (clname)
          objClass = TClass::GetClass(clname);
    }
    else if (obj->InheritsFrom("TKeyMapFile")) {
-      const char *title = (const char *)gROOT->ProcessLine(Form("((TKeyMapFile *)0x%lx)->GetTitle();", obj));
+      const char *title = (const char *)gROOT->ProcessLine(TString::Format("((TKeyMapFile *)0x%lx)->GetTitle();", obj));
       if (title)
          objClass = TClass::GetClass(title);
    }
@@ -1202,6 +1213,14 @@ void TGFileBrowser::GotoDir(const char *path)
    if (item == 0) return;
    fListTree->OpenItem(item);
    TObjArray *tokens = sPath.Tokenize("/");
+   if (tokens->IsEmpty()) {
+      fListTree->HighlightItem(item);
+      DoubleClicked(item, 1);
+      delete tokens;
+      fListTree->ClearViewPort();
+      fListTree->AdjustPosition(item);
+      return;
+   }
    TString first = ((TObjString*)tokens->At(0))->GetName();
    if (first == "afs")
       expand = kFALSE;
diff --git a/gui/gui/src/TGFileDialog.cxx b/gui/gui/src/TGFileDialog.cxx
index 6079546..9321a4e 100644
--- a/gui/gui/src/TGFileDialog.cxx
+++ b/gui/gui/src/TGFileDialog.cxx
@@ -368,7 +368,7 @@ Bool_t TGFileDialog::ProcessMessage(Long_t msg, Long_t parm1, Long_t)
    TGTextLBEntry *te;
    TGFileItem *f;
    void *p = 0;
-   const char *txt;
+   TString txt;
    TString sdir = gSystem->WorkingDirectory();
 
    switch (GET_MSG(msg)) {
@@ -388,10 +388,10 @@ Bool_t TGFileDialog::ProcessMessage(Long_t msg, Long_t parm1, Long_t)
                                 !strcmp(fOk->GetTitle(), "Save") &&
                                 (!(fCheckB->GetState() == kButtonDown))) {
                         Int_t ret;
-                        txt = Form("File name %s already exists, OK to overwrite it?",
-                                   fTbfname->GetString());
+                        txt = TString::Format("File name %s already exists, OK to overwrite it?",
+                                              fTbfname->GetString());
                         new TGMsgBox(fClient->GetRoot(), GetMainFrame(),
-                                     "File Name Exist", txt, kMBIconExclamation,
+                                     "File Name Exist", txt.Data(), kMBIconExclamation,
                                      kMBYes | kMBNo, &ret);
                         if (ret == kMBNo)
                            return kTRUE;
@@ -433,7 +433,7 @@ Bool_t TGFileDialog::ProcessMessage(Long_t msg, Long_t parm1, Long_t)
                      fFileInfo->fIniDir = StrDup(fFc->GetDirectory());
                      break;
 
-                  case kIDF_NEW_FOLDER:
+                  case kIDF_NEW_FOLDER: {
                      char answer[128];
                      strcpy(answer, "(empty)");
                      new TGInputDialog(gClient->GetRoot(), GetMainFrame(),
@@ -456,13 +456,14 @@ Bool_t TGFileDialog::ProcessMessage(Long_t msg, Long_t parm1, Long_t)
                      }
                      if ( gSystem->MakeDirectory(answer) != 0 )
                         new TGMsgBox(gClient->GetRoot(), GetMainFrame(), "Error", 
-                                     Form("Directory name \'%s\' already exists!", answer),
+                                     TString::Format("Directory name \'%s\' already exists!", answer),
                                      kMBIconStop, kMBOk);
                      else {
                         fFc->DisplayDirectory();
                      }
                      gSystem->ChangeDirectory(sdir.Data());
                      break;
+                  }
 
                   case kIDF_LIST:
                      fFv->SetViewMode(kLVList);
@@ -558,10 +559,10 @@ Bool_t TGFileDialog::ProcessMessage(Long_t msg, Long_t parm1, Long_t)
                             (!(fCheckB->GetState() == kButtonDown))) {
 
                            Int_t ret;
-                           txt = Form("File name %s already exists, OK to overwrite it?",
-                                      fTbfname->GetString());
+                           txt = TString::Format("File name %s already exists, OK to overwrite it?",
+                                                 fTbfname->GetString());
                            new TGMsgBox(fClient->GetRoot(), GetMainFrame(),
-                                        "File Name Exist", txt, kMBIconExclamation,
+                                        "File Name Exist", txt.Data(), kMBIconExclamation,
                                         kMBYes | kMBNo, &ret);
                            if (ret == kMBNo)
                               return kTRUE;
@@ -603,10 +604,10 @@ Bool_t TGFileDialog::ProcessMessage(Long_t msg, Long_t parm1, Long_t)
                           !strcmp(fOk->GetTitle(), "Save") &&
                           (!(fCheckB->GetState() == kButtonDown))) {
                   Int_t ret;
-                  txt = Form("File name %s already exists, OK to overwrite it?",
-                             fTbfname->GetString());
+                  txt = TString::Format("File name %s already exists, OK to overwrite it?",
+                                        fTbfname->GetString());
                   new TGMsgBox(fClient->GetRoot(), GetMainFrame(),
-                               "File Name Exist", txt, kMBIconExclamation,
+                               "File Name Exist", txt.Data(), kMBIconExclamation,
                                kMBYes | kMBNo, &ret);
                   if (ret == kMBNo)
                      return kTRUE;
diff --git a/gui/gui/src/TGFont.cxx b/gui/gui/src/TGFont.cxx
index 6cddd5a..cb16edb 100644
--- a/gui/gui/src/TGFont.cxx
+++ b/gui/gui/src/TGFont.cxx
@@ -1657,7 +1657,7 @@ TGFont *TGFontPool::GetFont(FontStruct_t fs)
    }
 
    static int i = 0;
-   f = MakeFont(0, fs, Form("unknown-%d", i));
+   f = MakeFont(0, fs, TString::Format("unknown-%d", i));
    fList->Add(f);
    i++;
 
diff --git a/gui/gui/src/TGFontDialog.cxx b/gui/gui/src/TGFontDialog.cxx
index 3b59211..b0a4bdb 100644
--- a/gui/gui/src/TGFontDialog.cxx
+++ b/gui/gui/src/TGFontDialog.cxx
@@ -551,7 +551,7 @@ void TGFontDialog::UpdateStyleSize(const char *family)
    TString fname;
    char **fontList = 0;
 
-   fname = Form("-*-%s-*-*", family);
+   fname = TString::Format("-*-%s-*-*", family);
    fontList = gVirtualX->ListFonts(fname.Data(), 1000, cnt);
 
    fFontSizes->RemoveEntries(0, 1000);
@@ -695,7 +695,7 @@ void TGFontDialog::UpdateStyleSize(const char *family)
    fFontStyles->Layout();
 //
 
-   sz = Form("%d", fSize);
+   sz = TString::Format("%d", fSize);
    if (sz.Length() == 1) {
       sz = " " + sz;
    }
@@ -771,7 +771,8 @@ void TGFontDialog::GetFontName()
    }
 
    TString oldFont = fLName;
-   fLName = Form("-*-%s-%s-*-*-%s-*-*-*-*-*-%s-*", name, gFontStylesReal[sel].Data(), size, rgstry);
+   fLName = TString::Format("-*-%s-%s-*-*-%s-*-*-*-*-*-%s-*", name, 
+                            gFontStylesReal[sel].Data(), size, rgstry);
 
    if (oldFont != fLName) {
       if (fLabelFont) {
diff --git a/gui/gui/src/TGFrame.cxx b/gui/gui/src/TGFrame.cxx
index 7445b68..bad998c 100644
--- a/gui/gui/src/TGFrame.cxx
+++ b/gui/gui/src/TGFrame.cxx
@@ -1489,8 +1489,8 @@ Bool_t TGMainFrame::HandleKey(Event_t *event)
          else {
             Int_t retval;
             new TGMsgBox(fClient->GetDefaultRoot(), this, "Error...",
-                        Form("file (%s) must have extension .C", fname),
-                        kMBIconExclamation, kMBRetry | kMBCancel, &retval);
+                         TString::Format("file (%s) must have extension .C", fname),
+                         kMBIconExclamation, kMBRetry | kMBCancel, &retval);
             if (retval == kMBRetry)
                HandleKey(event);
          }
@@ -2907,7 +2907,7 @@ void TGMainFrame::SaveSource(const char *filename, Option_t *option)
          out << endl;
 
          if (rb - lb > 1 && eq == -1) {
-            p = Form(" par%d", pnumber);
+            p = TString::Format(" par%d", pnumber);
             s.Insert(rb, p);
             pnumber++;
             out << "void " << s << endl;
@@ -3395,7 +3395,7 @@ void TGTransientFrame::SaveSource(const char *filename, Option_t *option)
          out << endl;
 
          if (rb - lb > 1 && eq == -1) {
-            p = Form(" par%d", pnumber);
+            p = TString::Format(" par%d", pnumber);
             s.Insert(rb, p);
             pnumber++;
             out << "void " << s << endl;
diff --git a/gui/gui/src/TGListTree.cxx b/gui/gui/src/TGListTree.cxx
index 9e69cde..0af1bb3 100644
--- a/gui/gui/src/TGListTree.cxx
+++ b/gui/gui/src/TGListTree.cxx
@@ -850,9 +850,9 @@ Bool_t TGListTree::HandleMotion(Event_t *event)
                }
                else {
                   fDNDData.fDataType = fDNDTypeList[1];
-                  TString str = Form("file://%s/%s\r\n",
-                              gSystem->UnixPathName(gSystem->WorkingDirectory()),
-                              item->GetText());
+                  TString str = TString::Format("file://%s/%s\r\n",
+                                gSystem->UnixPathName(gSystem->WorkingDirectory()),
+                                item->GetText());
                   fDNDData.fData = (void *)strdup(str.Data());
                   fDNDData.fDataLength = str.Length()+1;
                }
@@ -2564,7 +2564,7 @@ void TGListTree::SavePrimitive(ostream &out, Option_t *option /*= ""*/)
 
    while (current) {
       out << "   TGListTreeItem *item" << n << " = " << GetName() << "->AddItem(";
-      current->SavePrimitive(out, Form("%d",n), n);
+      current->SavePrimitive(out, TString::Format("%d",n), n);
       if (current->IsOpen())
          out << "   " << GetName() << "->OpenItem(item" << n << ");" << endl;
       else
@@ -2591,7 +2591,7 @@ void TGListTree::SaveChildren(ostream &out, TGListTreeItem *item, Int_t &n)
    Int_t p = n-1;
    while (item) {
       out << "   TGListTreeItem *item" << n << " = " << GetName() << "->AddItem(";
-      item->SavePrimitive(out, Form("%d",p),n);
+      item->SavePrimitive(out, TString::Format("%d",p),n);
       n++;
       if (item->fFirstchild) {
          SaveChildren(out, item->fFirstchild, n);
@@ -2614,7 +2614,7 @@ void TGListTreeItemStd::SavePrimitive(ostream &out, Option_t *option, Int_t n)
    static Color_t oldcolor = -1;
 
    char quote = '"';
-   TString s = Form("%d",n);
+   TString s = TString::Format("%d", n);
 
    if (!fParent)
       out << "NULL,";
diff --git a/gui/gui/src/TGListView.cxx b/gui/gui/src/TGListView.cxx
index 05b5931..d2acf58 100644
--- a/gui/gui/src/TGListView.cxx
+++ b/gui/gui/src/TGListView.cxx
@@ -1197,7 +1197,7 @@ void TGListView::SetHeader(const char *s, Int_t hmode, Int_t cmode, Int_t idx)
    // alignmode for the item text.
 
    if (idx < 0 || idx >= fNColumns-1) {
-      Error("SetHeader", Form("header index must be [0 - %d>", fNColumns-1));
+      Error("SetHeader", TString::Format("header index must be [0 - %d>", fNColumns-1));
       return;
    }
    delete fColHeader[idx];
diff --git a/gui/gui/src/TGMenu.cxx b/gui/gui/src/TGMenu.cxx
index fceff8d..3eb4414 100644
--- a/gui/gui/src/TGMenu.cxx
+++ b/gui/gui/src/TGMenu.cxx
@@ -815,7 +815,7 @@ Bool_t TGMenuBar::HandleKey(Event_t *event)
                   if (!ce) ce = (TGMenuEntry*)menu->GetListOfEntries()->First();
                   break;
                case kKey_Enter:
-               case kKey_Return:
+               case kKey_Return: {
                   gVirtualX->GrabPointer(0, 0, 0, 0, kFALSE);
                   fCurrent->SetState(kFALSE);
                   menu->fStick = kFALSE;
@@ -824,6 +824,7 @@ Bool_t TGMenuBar::HandleKey(Event_t *event)
                   ev.fWindow = menu->GetId();
                   fCurrent = 0;
                   return menu->HandleButton(&ev);
+               }
                case kKey_Escape:
                   gVirtualX->GrabPointer(0, 0, 0, 0, kFALSE);
                   fCurrent->SetState(kFALSE);
diff --git a/gui/gui/src/TGShapedFrame.cxx b/gui/gui/src/TGShapedFrame.cxx
index 9aef8e3..4c40e73 100644
--- a/gui/gui/src/TGShapedFrame.cxx
+++ b/gui/gui/src/TGShapedFrame.cxx
@@ -42,7 +42,7 @@ TGShapedFrame::TGShapedFrame(const char *pname, const TGWindow *p, UInt_t w,
       picName = "Default.png";
    fImage = TImage::Open(picName.Data());
    if (!fImage || !fImage->IsValid())
-      Error("TGShapedFrame::TGShapedFrame", Form("%s not found", 
+      Error("TGShapedFrame::TGShapedFrame", TString::Format("%s not found", 
             picName.Data()));
    fBgnd = fClient->GetPicturePool()->GetPicture(picName.Data(),
            fImage->GetPixmap(), fImage->GetMask());
diff --git a/gui/gui/src/TGSimpleTableInterface.cxx b/gui/gui/src/TGSimpleTableInterface.cxx
index d23a90d..34670c5 100644
--- a/gui/gui/src/TGSimpleTableInterface.cxx
+++ b/gui/gui/src/TGSimpleTableInterface.cxx
@@ -64,7 +64,7 @@ const char *TGSimpleTableInterface::GetValueAsString(UInt_t row, UInt_t column)
 
    // FIXME use template string for string format instead of hardcoded format
 
-   return Form("%5.2f", GetValue(row, column));
+   return StrDup(TString::Format("%5.2f", GetValue(row, column)));
 }
 
 //______________________________________________________________________________
@@ -72,7 +72,7 @@ const char *TGSimpleTableInterface::GetRowHeader(UInt_t row)
 {
    // Return a name for the header at row.
 
-   return Form("DRow %d", row);
+   return StrDup(TString::Format("DRow %d", row));
 }
 
 //______________________________________________________________________________
@@ -80,5 +80,5 @@ const char *TGSimpleTableInterface::GetColumnHeader(UInt_t column)
 {
    // Return a name for the header at column.
 
-   return Form("DCol %d", column);
+   return StrDup(TString::Format("DCol %d", column));
 }
diff --git a/gui/gui/src/TGSlider.cxx b/gui/gui/src/TGSlider.cxx
index 076663f..996c05c 100644
--- a/gui/gui/src/TGSlider.cxx
+++ b/gui/gui/src/TGSlider.cxx
@@ -90,6 +90,7 @@ TGVSlider::TGVSlider(const TGWindow *p, UInt_t h, UInt_t type, Int_t id,
                          kButtonPressMask | kButtonReleaseMask |
                          kPointerMotionMask, kNone, kNone);
 
+   AddInput(kStructureNotifyMask);
    // set initial values
    fPos = h/2; fVmin = 0; fVmax = h;
    fEditDisabled = kEditDisableWidth;
@@ -179,6 +180,8 @@ Bool_t TGVSlider::HandleButton(Event_t *event)
             // set absolute position
             fPos = ((fVmax - fVmin) * event->fY) / (fHeight-16) + fVmin;
          }
+         if (fPos > fVmax) fPos = fVmax;
+         if (fPos < fVmin) fPos = fVmin;
          SendMessage(fMsgWindow, MK_MSG(kC_VSLIDER, kSL_POS),
                      fWidgetId, fPos);
          fClient->ProcessLine(fCommand, MK_MSG(kC_VSLIDER, kSL_POS),
@@ -223,7 +226,15 @@ Bool_t TGVSlider::HandleMotion(Event_t *event)
    return kTRUE;
 }
 
+//______________________________________________________________________________
+Bool_t TGVSlider::HandleConfigureNotify(Event_t* event)
+{
+   // Handles resize events for this widget.
 
+   TGFrame::HandleConfigureNotify(event);
+   fClient->NeedRedraw(this);
+   return kTRUE;
+}
 
 //______________________________________________________________________________
 TGHSlider::TGHSlider(const TGWindow *p, UInt_t w, UInt_t type, Int_t id,
@@ -244,6 +255,7 @@ TGHSlider::TGHSlider(const TGWindow *p, UInt_t w, UInt_t type, Int_t id,
                          kButtonPressMask | kButtonReleaseMask |
                          kPointerMotionMask, kNone, kNone);
 
+   AddInput(kStructureNotifyMask);
    // set initial values
    fPos = w/2; fVmin = 0; fVmax = w;
    fEditDisabled = kEditDisableHeight;
@@ -325,6 +337,8 @@ Bool_t TGHSlider::HandleButton(Event_t *event)
          } else if (event->fCode == kButton2) {
             fPos = ((fVmax - fVmin) * event->fX) / (fWidth-16) + fVmin;
          }
+         if (fPos > fVmax) fPos = fVmax;
+         if (fPos < fVmin) fPos = fVmin;
          SendMessage(fMsgWindow, MK_MSG(kC_HSLIDER, kSL_POS),
                      fWidgetId, fPos);
          fClient->ProcessLine(fCommand, MK_MSG(kC_HSLIDER, kSL_POS),
@@ -373,6 +387,17 @@ Bool_t TGHSlider::HandleMotion(Event_t *event)
 }
 
 //______________________________________________________________________________
+Bool_t TGHSlider::HandleConfigureNotify(Event_t* event)
+{
+   // Handles resize events for this widget.
+
+   TGFrame::HandleConfigureNotify(event);
+   fClient->NeedRedraw(this);
+   return kTRUE;
+}
+
+
+//______________________________________________________________________________
 TString TGSlider::GetTypeString() const
 {
    // Returns the slider type as a string - used in SavePrimitive().
diff --git a/gui/gui/src/TGTab.cxx b/gui/gui/src/TGTab.cxx
index 892ef09..70f2eff 100644
--- a/gui/gui/src/TGTab.cxx
+++ b/gui/gui/src/TGTab.cxx
@@ -688,7 +688,11 @@ void TGTab::NewTab(const char *text)
 {
    // Create new tab. Used in context menu.
 
-   TString name = text ? text : Form("tab%d", GetNumberOfTabs()+1);
+   TString name;
+   if (text)
+      name = text;
+   else
+      name = TString::Format("tab%d", GetNumberOfTabs()+1);
    AddTab(name.Data());
 
    GetLayoutManager()->Layout();
diff --git a/gui/gui/src/TRootBrowser.cxx b/gui/gui/src/TRootBrowser.cxx
index 8589540..1053dc4 100644
--- a/gui/gui/src/TRootBrowser.cxx
+++ b/gui/gui/src/TRootBrowser.cxx
@@ -504,15 +504,16 @@ Long_t TRootBrowser::ExecPlugin(const char *name, const char *fname,
    StartEmbedding(pos, subpos);
    if (cmd && strlen(cmd)) {
       command = cmd;
-      pname = name ? name : Form("Plugin %d", fPlugins.GetSize());
-      p = new TBrowserPlugin(pname, command.Data(), pos, subpos);
+      if (name) pname = name;
+      else pname = TString::Format("Plugin %d", fPlugins.GetSize());
+      p = new TBrowserPlugin(pname.Data(), command.Data(), pos, subpos);
    }
    else if (fname && strlen(fname)) {
       pname = name ? name : gSystem->BaseName(fname);
       Ssiz_t t = pname.Last('.');
       if (t > 0) pname.Remove(t);
       command.Form("gROOT->Macro(\"%s\");", gSystem->UnixPathName(fname));
-      p = new TBrowserPlugin(pname, command.Data(), pos, subpos);
+      p = new TBrowserPlugin(pname.Data(), command.Data(), pos, subpos);
    }
    else return 0;
    fPlugins.Add(p);
@@ -521,7 +522,7 @@ Long_t TRootBrowser::ExecPlugin(const char *name, const char *fname,
       pname = gPad->GetName();
       p->SetName(pname.Data());
    }
-   SetTabTitle(pname, pos, subpos);
+   SetTabTitle(pname.Data(), pos, subpos);
    StopEmbedding();
    return retval;
 }
@@ -797,45 +798,47 @@ void TRootBrowser::InitPlugins(Option_t *opt)
 
    // --- Right main area
 
-   // Editor plugin...
-   if (strchr(opt, 'E')) {
-      cmd.Form("new TGTextEditor((const char *)0, gClient->GetRoot());");
-      ExecPlugin("Editor 1", 0, cmd.Data(), 1);
-      ++fNbInitPlugins;
-   }
-
-   // HTML plugin...
-   if (strchr(opt, 'H')) {
-      if (gSystem->Load("libGuiHtml") >= 0) {
-         cmd.Form("new TGHtmlBrowser(\"%s\", gClient->GetRoot());", 
-                  gEnv->GetValue("Browser.StartUrl",
-                  "http://root.cern.ch/root/html/ClassIndex.html"));
-         ExecPlugin("HTML", 0, cmd.Data(), 1);
+   Int_t i, len = strlen(opt);
+   for (i=0; i<len; ++i) {
+      // Editor plugin...
+      if (opt[i] == 'E') {
+         cmd.Form("new TGTextEditor((const char *)0, gClient->GetRoot());");
+         ExecPlugin("Editor 1", 0, cmd.Data(), 1);
          ++fNbInitPlugins;
       }
-   }
 
-   // Canvas plugin...
-   if (strchr(opt, 'C')) {
-      cmd.Form("new TCanvas();");
-      ExecPlugin("c1", 0, cmd.Data(), 1);
-      ++fNbInitPlugins;
-   }
+      // HTML plugin...
+      if (opt[i] == 'H') {
+         if (gSystem->Load("libGuiHtml") >= 0) {
+            cmd.Form("new TGHtmlBrowser(\"%s\", gClient->GetRoot());", 
+                     gEnv->GetValue("Browser.StartUrl",
+                     "http://root.cern.ch/root/html/ClassIndex.html"));
+            ExecPlugin("HTML", 0, cmd.Data(), 1);
+            ++fNbInitPlugins;
+         }
+      }
+   
+      // Canvas plugin...
+      if (opt[i] == 'C') {
+         cmd.Form("new TCanvas();");
+         ExecPlugin("c1", 0, cmd.Data(), 1);
+         ++fNbInitPlugins;
+      }
 
-   // GLViewer plugin...
-   if (strchr(opt, 'G')) {
-      cmd.Form("new TGLSAViewer(gClient->GetRoot(), 0);");
-      ExecPlugin("OpenGL", 0, cmd.Data(), 1);
-      ++fNbInitPlugins;
-   }
+      // GLViewer plugin...
+      if (opt[i] == 'G') {
+         cmd.Form("new TGLSAViewer(gClient->GetRoot(), 0);");
+         ExecPlugin("OpenGL", 0, cmd.Data(), 1);
+         ++fNbInitPlugins;
+      }
 
-   // PROOF plugin...
-   if (strchr(opt, 'P')) {
-      cmd.Form("new TSessionViewer();");
-      ExecPlugin("PROOF", 0, cmd.Data(), 1);
-      ++fNbInitPlugins;
+      // PROOF plugin...
+      if (opt[i] == 'P') {
+         cmd.Form("new TSessionViewer();");
+         ExecPlugin("PROOF", 0, cmd.Data(), 1);
+         ++fNbInitPlugins;
+      }
    }
-
    // --- Right bottom area
 
    // Command plugin...
diff --git a/gui/gui/src/TRootBrowserLite.cxx b/gui/gui/src/TRootBrowserLite.cxx
index 985250d..93c6ecf 100644
--- a/gui/gui/src/TRootBrowserLite.cxx
+++ b/gui/gui/src/TRootBrowserLite.cxx
@@ -571,13 +571,13 @@ void TRootIconBox::AddObjItem(const char *name, TObject *obj, TClass *cl)
             TGTextButton** buttons = fListView->GetHeaderButtons();
             if (buttons) {
                buttons[0]->Connect("Clicked()", "TRootBrowserLite", fBrowser,
-                                   Form("SetSortMode(=%d)", kViewArrangeByName));
+                                   TString::Format("SetSortMode(=%d)", kViewArrangeByName));
                buttons[1]->Connect("Clicked()", "TRootBrowserLite", fBrowser,
-                                   Form("SetSortMode(=%d)", kViewArrangeByType));
+                                   TString::Format("SetSortMode(=%d)", kViewArrangeByType));
                buttons[2]->Connect("Clicked()", "TRootBrowserLite", fBrowser,
-                                   Form("SetSortMode(=%d)", kViewArrangeBySize));
+                                   TString::Format("SetSortMode(=%d)", kViewArrangeBySize));
                buttons[5]->Connect("Clicked()", "TRootBrowserLite", fBrowser,
-                                   Form("SetSortMode(=%d)", kViewArrangeByDate));
+                                   TString::Format("SetSortMode(=%d)", kViewArrangeByDate));
             }
          }
          fCheckHeaders = kFALSE;
@@ -604,9 +604,9 @@ void TRootIconBox::AddObjItem(const char *name, TObject *obj, TClass *cl)
          if (obj->IsA() == TSystemFile::Class()) {
             TString str;
             TDNDData data;
-            str = Form("file://%s/%s\r\n",
-                    gSystem->UnixPathName(obj->GetTitle()),
-                    obj->GetName());
+            str = TString::Format("file://%s/%s\r\n",
+                                  gSystem->UnixPathName(obj->GetTitle()),
+                                  obj->GetName());
             data.fData = (void *)strdup(str.Data());
             data.fDataLength = str.Length()+1;
             data.fDataType = gVirtualX->InternAtom("text/uri-list", kFALSE);
@@ -2318,7 +2318,7 @@ void TRootBrowserLite::ListTreeHighlight(TGListTreeItem *item)
             if (!gApplication->GetAppRemote()) {
                gROOT->ProcessLine(Form(".R %s", item->GetText()));
                if (gApplication->GetAppRemote()) {
-                  Getlinem(kInit, Form("\n%s:root [0]", 
+                  Getlinem(kInit, TString::Format("\n%s:root [0]", 
                            gApplication->GetAppRemote()->ApplicationName()));
                }
             }
@@ -2339,8 +2339,8 @@ void TRootBrowserLite::ListTreeHighlight(TGListTreeItem *item)
                   // remotely browse file (remotely call TFile::cd())
                   gApplication->SetBit(TApplication::kProcessRemotely);
                   gApplication->ProcessLine(
-                     Form("((TApplicationServer *)gApplication)->BrowseFile(\"%s\");",
-                          probj->GetName()));
+                     TString::Format("((TApplicationServer *)gApplication)->BrowseFile(\"%s\");",
+                                     probj->GetName()));
                }
             }
          }
@@ -2350,7 +2350,7 @@ void TRootBrowserLite::ListTreeHighlight(TGListTreeItem *item)
             if (!gApplication->GetAppRemote()) {
                gROOT->ProcessLine(Form(".R %s", item->GetParent()->GetText()));
                if (gApplication->GetAppRemote()) {
-                  Getlinem(kInit, Form("\n%s:root [0]", 
+                  Getlinem(kInit, TString::Format("\n%s:root [0]", 
                            gApplication->GetAppRemote()->ApplicationName()));
                }
             }
@@ -2374,7 +2374,7 @@ void TRootBrowserLite::ListTreeHighlight(TGListTreeItem *item)
                   // switch to remote session if not already in
                   gROOT->ProcessLine(Form(".R %s", top->GetText()));
                   if (gApplication->GetAppRemote()) {
-                     Getlinem(kInit, Form("\n%s:root [0]", 
+                     Getlinem(kInit, TString::Format("\n%s:root [0]", 
                               gApplication->GetAppRemote()->ApplicationName()));
                   }
                }
@@ -2815,13 +2815,13 @@ void TRootBrowserLite::SetViewMode(Int_t new_mode, Bool_t force)
       if ((lv == kLVDetails) && (buttons)) {
          if (!strcmp(fListView->GetHeader(1), "Attributes")) {
             buttons[0]->Connect("Clicked()", "TRootBrowserLite", this,
-                                Form("SetSortMode(=%d)", kViewArrangeByName));
+                                TString::Format("SetSortMode(=%d)", kViewArrangeByName));
             buttons[1]->Connect("Clicked()", "TRootBrowserLite", this,
-                                Form("SetSortMode(=%d)", kViewArrangeByType));
+                                TString::Format("SetSortMode(=%d)", kViewArrangeByType));
             buttons[2]->Connect("Clicked()", "TRootBrowserLite", this,
-                                Form("SetSortMode(=%d)", kViewArrangeBySize));
+                                TString::Format("SetSortMode(=%d)", kViewArrangeBySize));
             buttons[5]->Connect("Clicked()", "TRootBrowserLite", this,
-                                Form("SetSortMode(=%d)", kViewArrangeByDate));
+                                TString::Format("SetSortMode(=%d)", kViewArrangeByDate));
          }
       }
       fIconBox->AdjustPosition();
diff --git a/gui/gui/src/TRootCanvas.cxx b/gui/gui/src/TRootCanvas.cxx
index dd1876d..e48bc01 100644
--- a/gui/gui/src/TRootCanvas.cxx
+++ b/gui/gui/src/TRootCanvas.cxx
@@ -1292,7 +1292,7 @@ void TRootCanvas::PrintCanvas()
       TString fn = "rootprint";
       FILE *f = gSystem->TempFileName(fn, gEnv->GetValue("Print.Directory", gSystem->TempDirectory()));
       fclose(f);
-      fn += Form(".%s",gEnv->GetValue("Print.FileType", "pdf"));
+      fn += TString::Format(".%s",gEnv->GetValue("Print.FileType", "pdf"));
       fCanvas->Print(fn);
 
       TString cmd = sprintCmd;
diff --git a/gui/gui/src/TRootContextMenu.cxx b/gui/gui/src/TRootContextMenu.cxx
index c4b7b69..54d48ee 100644
--- a/gui/gui/src/TRootContextMenu.cxx
+++ b/gui/gui/src/TRootContextMenu.cxx
@@ -422,11 +422,11 @@ void TRootContextMenu::Dialog(TObject *object, TFunction *function)
    while ((argument = (TMethodArg *) next())) {
       // Do not input argument for self object
       if (selfobjpos != argpos) {
-         Text_t       *argname    = fContextMenu->CreateArgumentTitle(argument);
-         const Text_t *type       = argument->GetTypeName();
+         char       *argname    = fContextMenu->CreateArgumentTitle(argument);
+         const char *type       = argument->GetTypeName();
          TDataType    *datatype   = gROOT->GetType(type);
-         const Text_t *charstar   = "char*";
-         Text_t        basictype[32];
+         const char *charstar   = "char*";
+         char        basictype[32];
 
          if (datatype) {
             strcpy(basictype, datatype->GetTypeName());
@@ -448,10 +448,10 @@ void TRootContextMenu::Dialog(TObject *object, TFunction *function)
 
             // Get the current value and form it as a text:
 
-            Text_t val[256];
+            char val[256];
 
             if (!strncmp(basictype, "char*", 5)) {
-               Text_t *tdefval;
+               char *tdefval;
                m->GetterMethod()->Execute(object, "", &tdefval);
                strncpy(val, tdefval, 255);
             } else if (!strncmp(basictype, "float", 5) ||
@@ -479,11 +479,11 @@ void TRootContextMenu::Dialog(TObject *object, TFunction *function)
                TIter nextopt(opt);
                TOptionListItem *it = 0;
                while ((it = (TOptionListItem*) nextopt())) {
-                  Text_t *name  = it->fOptName;
-                  Text_t *label = it->fOptLabel;
+                  char *name  = it->fOptName;
+                  char *label = it->fOptLabel;
                   Long_t value  = it->fValue;
                   if (value != -9999) {
-                     Text_t val[256];
+                     char val[256];
                      sprintf(val, "%li", value);
                      o->AddItem(name, val);
                   }else
diff --git a/gui/gui/src/TRootEmbeddedCanvas.cxx b/gui/gui/src/TRootEmbeddedCanvas.cxx
index c34b16f..e39d4e1 100644
--- a/gui/gui/src/TRootEmbeddedCanvas.cxx
+++ b/gui/gui/src/TRootEmbeddedCanvas.cxx
@@ -140,7 +140,10 @@ TRootEmbeddedCanvas::TRootEmbeddedCanvas(const char *name, const TGWindow *p,
    fCanvasContainer = new TRootEmbeddedContainer(this, win, GetViewPort());
    SetContainer(fCanvasContainer);
 
-   fCanvas = new TCanvas(name ? name : Form("%s_canvas", GetName()), w, h, fCWinId);
+   TString cname;
+   if (name) cname = name;
+   else cname = TString::Format("%s_canvas", GetName());
+   fCanvas = new TCanvas(cname.Data(), w, h, fCWinId);
 
    // define DND types
    fDNDTypeList = new Atom_t[3];
@@ -447,7 +450,7 @@ void TRootEmbeddedCanvas::SavePrimitive(ostream &out, Option_t *option /*= ""*/)
        << "->GetCanvasWindowId();" << endl;
 
    static int n = 123;
-   TString cname = Form("c%d", n);
+   TString cname = TString::Format("c%d", n);
 
    out << "   TCanvas *";
    out <<  cname << " = new TCanvas(";
diff --git a/gui/guibuilder/src/TGuiBldDragManager.cxx b/gui/guibuilder/src/TGuiBldDragManager.cxx
index 9207a28..d928397 100644
--- a/gui/guibuilder/src/TGuiBldDragManager.cxx
+++ b/gui/guibuilder/src/TGuiBldDragManager.cxx
@@ -901,10 +901,10 @@ TGuiBldDragManager::TGuiBldDragManager() : TVirtualDragManager() ,
 
    TString tmpfile = gSystem->TempDirectory();
    fPasteFileName = gSystem->ConcatFileName(tmpfile.Data(),
-                             Form("RootGuiBldClipboard%d.C", gSystem->GetPid()));
+                             TString::Format("RootGuiBldClipboard%d.C", gSystem->GetPid()));
 
    fTmpBuildFile = gSystem->ConcatFileName(tmpfile.Data(),
-                             Form("RootGuiBldTmpFile%d.C", gSystem->GetPid()));
+                             TString::Format("RootGuiBldTmpFile%d.C", gSystem->GetPid()));
 
    fName = "Gui Builder Drag Manager";
    SetWindowName(fName.Data());
@@ -2388,7 +2388,7 @@ Bool_t TGuiBldDragManager::HandleKey(Event_t *event)
             } else {
                Int_t retval;
                new TGMsgBox(fClient->GetDefaultRoot(), this, "Error...",
-                            Form("file (%s) must have extension .C", fname.Data()),
+                            TString::Format("file (%s) must have extension .C", fname.Data()),
                             kMBIconExclamation, kMBRetry | kMBCancel, &retval);
                if (retval == kMBRetry) {
                   HandleKey(event);
@@ -3211,8 +3211,8 @@ void TGuiBldDragManager::CloneEditable()
    }
 
    TString tmpfile = gSystem->TempDirectory();
-   tmpfile = gSystem->ConcatFileName(tmpfile.Data(),
-                                     Form("tmp%d.C", gRandom->Integer(100)));
+   tmpfile = gSystem->ConcatFileName(tmpfile.Data(), TString::Format("tmp%d.C", 
+                                     gRandom->Integer(100)));
    Save(tmpfile.Data());
    gROOT->Macro(tmpfile.Data());
    gSystem->Unlink(tmpfile.Data());
@@ -3276,7 +3276,7 @@ Bool_t TGuiBldDragManager::Save(const char *file)
 
    } else {
       Int_t retval;
-      TString msg = Form("file (%s) must have extension .C", fname.Data());
+      TString msg = TString::Format("file (%s) must have extension .C", fname.Data());
 
       new TGMsgBox(fClient->GetDefaultRoot(), main, "Error...", msg.Data(),
                    kMBIconExclamation, kMBRetry | kMBCancel, &retval);
@@ -3358,7 +3358,7 @@ Bool_t TGuiBldDragManager::SaveFrame(const char *file)
       fBuilder->AddMacro(fname.Data(), img);
    } else {
       Int_t retval;
-      TString msg = Form("file (%s) must have extension .C", fname.Data());
+      TString msg = TString::Format("file (%s) must have extension .C", fname.Data());
 
       new TGMsgBox(fClient->GetDefaultRoot(), frame, "Error...", msg.Data(),
                    kMBIconExclamation, kMBRetry | kMBCancel, &retval);
@@ -3608,7 +3608,7 @@ void TGuiBldDragManager::DoResize()
       str += "::";
       str += fr->GetName();
       str += " resized   ";
-      str += Form("(%d x %d)", w, h);
+      str += TString::Format("(%d x %d)", w, h);
       fBuilder->UpdateStatusBar(str.Data());
    }
 
@@ -3662,7 +3662,7 @@ void TGuiBldDragManager::DoMove()
       str += "::";
       str += fPimpl->fGrab->GetName();
       str += " is moved to absolute position   ";
-      str += Form("(%d , %d)", x, y);
+      str += TString::Format("(%d , %d)", x, y);
       fBuilder->UpdateStatusBar(str.Data());
    }
 
@@ -4369,7 +4369,7 @@ Bool_t TGuiBldDragManager::Drop()
          str += "::";
          str += parent->GetName();
          str += " at position  ";
-         str += Form("(%d , %d)", x, y);
+         str += TString::Format("(%d , %d)", x, y);
          fBuilder->UpdateStatusBar(str.Data());
       }
       fTarget = 0;
@@ -5928,7 +5928,7 @@ void TGuiBldDragManager::ChangePicture(TGPictureButton *fr)
    if (!pic) {
       Int_t retval;
       new TGMsgBox(fClient->GetDefaultRoot(), fr, "Error...",
-                   Form("Cannot read image file (%s)", fname.Data()),
+                   TString::Format("Cannot read image file (%s)", fname.Data()),
                    kMBIconExclamation, kMBRetry | kMBCancel, &retval);
 
       if (retval == kMBRetry) {
@@ -6207,7 +6207,7 @@ void TGuiBldDragManager::ChangeImage(TGIcon *fr)
    if (!img) {
       Int_t retval;
       new TGMsgBox(fClient->GetDefaultRoot(), fr, "Error...",
-                   Form("Cannot read image file (%s)", fname.Data()),
+                   TString::Format("Cannot read image file (%s)", fname.Data()),
                    kMBIconExclamation, kMBRetry | kMBCancel, &retval);
 
       if (retval == kMBRetry) {
diff --git a/gui/guibuilder/src/TRootGuiBuilder.cxx b/gui/guibuilder/src/TRootGuiBuilder.cxx
index de673a8..c8f0d18 100644
--- a/gui/guibuilder/src/TRootGuiBuilder.cxx
+++ b/gui/guibuilder/src/TRootGuiBuilder.cxx
@@ -1471,8 +1471,8 @@ Bool_t TRootGuiBuilder::OpenProject(Event_t *event)
    } else {
       Int_t retval;
       new TGMsgBox(fClient->GetDefaultRoot(), this, "Error...",
-                   Form("file (%s) must have source extension (.C, .c, .cxx, .cpp, .cc)", fname.Data()),
-                   kMBIconExclamation, kMBRetry | kMBCancel, &retval);
+                   TString::Format("file (%s) must have source extension (.C, .c, .cxx, .cpp, .cc)",
+                   fname.Data()), kMBIconExclamation, kMBRetry | kMBCancel, &retval);
 
       if (retval == kMBRetry) {
          OpenProject(event);
@@ -1560,8 +1560,8 @@ Bool_t TRootGuiBuilder::SaveProject(Event_t *event)
    } else {
       Int_t retval;
       new TGMsgBox(fClient->GetDefaultRoot(), this, "Error...",
-                   Form("file (%s) must have source extension (.C, .c, .cxx, .cpp, .cc)", fname.Data()),
-                   kMBIconExclamation, kMBRetry | kMBCancel, &retval);
+                   TString::Format("file (%s) must have source extension (.C, .c, .cxx, .cpp, .cc)",
+                   fname.Data()), kMBIconExclamation, kMBRetry | kMBCancel, &retval);
       if (retval == kMBRetry) {
          SaveProject(event);
       }
diff --git a/gui/guihtml/src/TGHtmlBrowser.cxx b/gui/guihtml/src/TGHtmlBrowser.cxx
index b3280dd..ce882ca 100644
--- a/gui/guihtml/src/TGHtmlBrowser.cxx
+++ b/gui/guihtml/src/TGHtmlBrowser.cxx
@@ -56,7 +56,7 @@ enum EMyMessageTypes {
 };
 
 static const char *gHtmlFTypes[] = {
-   "HTML files",    "*.html",
+   "HTML files",    "*.htm*",
    "All files",     "*",
     0,               0
 };
@@ -282,8 +282,12 @@ void TGHtmlBrowser::Selected(const char *uri)
    FILE *f;
 
    TString surl(gSystem->UnixPathName(uri));
-   if (!surl.BeginsWith("http://") && !surl.BeginsWith("file://"))
-      surl.Prepend("file://");
+   if (!surl.BeginsWith("http://") && !surl.BeginsWith("file://")) {
+      if (surl.BeginsWith("file:"))
+         surl.ReplaceAll("file:", "file://");
+      else
+         surl.Prepend("file://");
+   }
    if (surl.EndsWith(".root")) {
       gVirtualX->SetCursor(fHtml->GetId(), gVirtualX->CreateCursor(kWatch));
       gROOT->ProcessLine(Form("TFile::Open(\"%s\");", surl.Data()));
@@ -318,9 +322,12 @@ void TGHtmlBrowser::Selected(const char *uri)
    else {
       f = fopen(url.GetFile(), "r");
       if (f) {
+         TString fpath = url.GetUrl();
+         fpath.ReplaceAll(gSystem->BaseName(fpath.Data()), "");
+         fpath.ReplaceAll("file://", "");
          fHtml->Clear();
          fHtml->Layout();
-         fHtml->SetBaseUri("");
+         fHtml->SetBaseUri(fpath.Data());
          buf = (char *)calloc(4096, sizeof(char));
          while (fgets(buf, 4096, f)) {
             fHtml->ParseText(buf);
diff --git a/gui/guihtml/src/TGHtmlImage.cxx b/gui/guihtml/src/TGHtmlImage.cxx
index 12cde71..64ffe53 100644
--- a/gui/guihtml/src/TGHtmlImage.cxx
+++ b/gui/guihtml/src/TGHtmlImage.cxx
@@ -239,8 +239,8 @@ static TImage *ReadRemoteImage(const char *url)
       free(buf);
       return 0;
    }
-   TString pathtmp = Form("%s/%s",
-      gSystem->TempDirectory(), gSystem->BaseName(url));
+   TString pathtmp = TString::Format("%s/%s", gSystem->TempDirectory(), 
+                                     gSystem->BaseName(url));
    tmp = fopen(pathtmp.Data(), "wb");
    if (!tmp) {
       free(buf);
diff --git a/gui/qtgsi/src/TQCanvasMenu.cxx b/gui/qtgsi/src/TQCanvasMenu.cxx
index 065ebec..90c3fb9 100644
--- a/gui/qtgsi/src/TQCanvasMenu.cxx
+++ b/gui/qtgsi/src/TQCanvasMenu.cxx
@@ -185,11 +185,11 @@ void TQCanvasMenu::Dialog(TObject* object, TMethod* method)
    TMethodArg *argument = 0;
    TIter next(method->GetListOfMethodArgs());
    while ((argument = (TMethodArg *) next())) {
-      Text_t       *argname    = CreateArgumentTitle(argument);
-      const Text_t *type       = argument->GetTypeName();
+      char       *argname    = CreateArgumentTitle(argument);
+      const char *type       = argument->GetTypeName();
       TDataType    *datatype   = gROOT->GetType(type);
-      const Text_t *charstar   = "char*";
-      Text_t        basictype [32];
+      const char *charstar   = "char*";
+      char        basictype [32];
 
       if (datatype) {
          strncpy(basictype, datatype->GetTypeName(),31);
@@ -207,13 +207,13 @@ void TQCanvasMenu::Dialog(TObject* object, TMethod* method)
 
       TDataMember *m = argument->GetDataMember();
       if (m && m->GetterMethod()) {
-         Text_t gettername[256] = "";
+         char gettername[256] = "";
          strncpy(gettername, m->GetterMethod()->GetMethodName(),255);
          m->GetterMethod()->Init(object->IsA(), gettername, "");
          // Get the current value and form it as a text:
-         Text_t val[256];
+         char val[256];
          if (!strncmp(basictype, "char*", 5)) {
-            Text_t *tdefval;
+            char *tdefval;
             m->GetterMethod()->Execute(object, "", &tdefval);
             strncpy(val, tdefval, 255);
          }
diff --git a/gui/recorder/inc/LinkDef.h b/gui/recorder/inc/LinkDef.h
index f4d551d..cc20ff3 100644
--- a/gui/recorder/inc/LinkDef.h
+++ b/gui/recorder/inc/LinkDef.h
@@ -16,6 +16,7 @@
 
 #pragma link C++ class TRecEvent;
 #pragma link C++ class TRecCmdEvent;
+#pragma link C++ class TRecExtraEvent;
 #pragma link C++ class TRecGuiEvent;
 #pragma link C++ class TRecWinPair;
 #pragma link C++ class TRecorder;
diff --git a/gui/recorder/inc/TRecorder.h b/gui/recorder/inc/TRecorder.h
index e4aa89a..08cf74a 100644
--- a/gui/recorder/inc/TRecorder.h
+++ b/gui/recorder/inc/TRecorder.h
@@ -9,6 +9,9 @@
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
 
+#ifndef ROOT_TRecorder
+#define ROOT_TRecorder
+
 //////////////////////////////////////////////////////////////////////////
 //                                                                      //
 //  ROOT EVENT RECORDING SYSTEM                                         //
@@ -131,6 +134,12 @@
 #ifndef ROOT_TGFrame
 #include "TGFrame.h"
 #endif
+#ifndef ROOT_TCanvas
+#include "TCanvas.h"
+#endif
+#ifndef ROOT_THashList
+#include "THashList.h"
+#endif
 
 #include <time.h>
 
@@ -163,7 +172,8 @@ public:
    //---- Types of events recorded in ROOT.
    enum ERecEventType {
       kCmdEvent,     // Commandline event
-      kGuiEvent      // GUI event
+      kGuiEvent,    // GUI event
+      kExtraEvent
    };
 
    // Replays (executes) the stored event again
@@ -226,7 +236,49 @@ public:
       gApplication->ProcessLine(GetText());
    }
 
-   ClassDef(TRecCmdEvent,1)   // Class stores information about 1 commandline event (= 1 command typed by user in commandline)
+   ClassDef(TRecCmdEvent,1) // Class stores information about 1 commandline event (= 1 command typed by user in commandline)
+};
+
+//////////////////////////////////////////////////////////////////////////
+//                                                                      //
+//  TRecExtraEvent                                                      //
+//                                                                      //
+//  Class used for storing information about 1 extra event.             //
+//  It means 1 TPaveLabel or 1 TLatex event produced in the Canvas      //
+//                                                                      //
+//////////////////////////////////////////////////////////////////////////
+class TRecExtraEvent : public TRecEvent
+{
+private:
+   TString fText;             // Text of stored command
+
+public:
+   TRecExtraEvent() {
+      // Creates new empty  TRecExtraEvent
+   }
+
+   void SetText(TString text) {
+      // Saves text of a command (PaveLabel or Text)
+      fText = text;
+   }
+
+   TString GetText() const {
+      // Returns stored text of the command
+      return fText;
+   }
+
+   virtual ERecEventType GetType() const {
+      // Returns what kind of event it stores (Especial event)
+      return TRecEvent::kExtraEvent;
+   }
+
+   virtual void ReplayEvent(Bool_t) {
+      // Stored event is executed again
+
+      gApplication->ProcessLine(GetText());
+   }
+
+   ClassDef(TRecExtraEvent,1) // Class stores information about extra events
 };
 
 //////////////////////////////////////////////////////////////////////////
@@ -245,7 +297,7 @@ protected:
    friend class TRecorderPaused;
    friend class TRecorderRecording;
    friend class TRecorderReplaying;
-   
+
    EGEventType    fType;            // Type of event (see EGEventType)
    Window_t       fWindow;          // Window ID which reported event is relative to
    Time_t         fTime;            // Time event occured in ms
@@ -284,7 +336,7 @@ public:
    virtual void    ReplayEvent(Bool_t showMouseCursor = kTRUE);
    static Event_t *CreateEvent(TRecGuiEvent *ge);
 
-   ClassDef(TRecGuiEvent,1)         // Class stores information about 1 GUI event in ROOT
+   ClassDef(TRecGuiEvent,1) // Class stores information about 1 GUI event in ROOT
 };
 
 //////////////////////////////////////////////////////////////////////////
@@ -440,7 +492,10 @@ public:
    // Gets current state of recorder
    virtual TRecorder::ERecorderState GetState() const;
 
-   ClassDef(TRecorder,1)             // Class provides direct recorder/replayer interface for a user.
+   // Saves all the canvases previous to the TRecorder
+   void PrevCanvases(const char *filename, Option_t *option);
+
+   ClassDef(TRecorder,1) // Class provides direct recorder/replayer interface for a user.
 };
 
 //////////////////////////////////////////////////////////////////////////
@@ -465,7 +520,7 @@ protected:
    void ChangeState(TRecorder *r, TRecorderState *s, Bool_t deletePreviousState) { r->ChangeState(s, deletePreviousState); }
 
 public:
-   virtual        ~TRecorderState() {}
+   virtual ~TRecorderState() {}
    virtual void   Start(TRecorder *, const char *, Option_t *, Window_t *, Int_t) {}
    virtual void   Stop(TRecorder *, Bool_t ) {}
    virtual Bool_t Replay(TRecorder *, const char *, Bool_t, TRecorder::EReplayModes) { return false; }
@@ -476,6 +531,8 @@ public:
    virtual void   ListCmd(const char *) {}
    virtual void   ListGui(const char *) {}
 
+   virtual void   PrevCanvases(const char *, Option_t *) {}
+
    virtual TRecorder::ERecorderState GetState() const = 0;
 
    ClassDef(TRecorderState, 0) // Abstract class that defines interface for a state of recorder
@@ -506,44 +563,54 @@ private:
                            // recorder to INACTIVE state after replaying is finished
 
    TFile      *fFile;      // ROOT file which the recorded events are being read from
+
+
+   TCanvas    *fCanv;      // Used to record the previous canvases
+
+
    TTimer     *fTimer;     // Timer used for replaying
 
    TTree      *fWinTree;   // TTree with recorded windows (=registered during recording)
    TTree      *fGuiTree;   // TTree with recorded GUI events
    TTree      *fCmdTree;   // TTree with recorded commandline events
+   TTree      *fExtraTree; // TTree with recorded extra events (PaveLabels and Texts)
 
-   ULong64_t   fWin;       // Window ID being currenty mapped
-   TRecGuiEvent  *fGuiEvent;  // GUI event being currently replayed
-   TRecCmdEvent  *fCmdEvent;  // Commandline event being currently replayed
+   ULong64_t       fWin;            // Window ID being currenty mapped
+   TRecGuiEvent   *fGuiEvent;       // GUI event being currently replayed
+   TRecCmdEvent   *fCmdEvent;       // Commandline event being currently replayed
+   TRecExtraEvent *fExtraEvent;     // Extra event being currently replayed
 
-   Int_t       fRegWinCounter;   // Counter of registered windows when replaying
-   Int_t       fGuiTreeCounter;  // Counter of GUI events that have been replayed
-   Int_t       fCmdTreeCounter;  // Counter of commandline events that have been replayed
+   Int_t       fRegWinCounter;      // Counter of registered windows when replaying
+   Int_t       fGuiTreeCounter;     // Counter of GUI events that have been replayed
+   Int_t       fCmdTreeCounter;     // Counter of commandline events that have been replayed
+   Int_t       fExtraTreeCounter;   // Counter of extra events that have been replayed
 
-   Int_t       fWinTreeEntries;  // Number of registered windows during _recording_
+   Int_t       fWinTreeEntries;     // Number of registered windows during _recording_
 
    TMutex      *fMutex;
 
-   TList      *fWindowList;      // List of TRecWinPair objects. Mapping of window IDs is stored here.
+   TList      *fWindowList;         // List of TRecWinPair objects. Mapping of window IDs is stored here.
 
-   TRecEvent *fNextEvent;          // The next event that is going to be replayed (GUI event or commandline)
+   TRecEvent  *fNextEvent;          // The next event that is going to be replayed (GUI event or commandline)
 
-   TTime             fPreviousEventTime;  // Execution time of the previously replayed event.
+   TTime       fPreviousEventTime;  // Execution time of the previously replayed event.
                                           // It is used for computing time difference between two events.
 
-   Bool_t            fWaitingForWindow;   // Signalizes that we wait for a window to be registered in order
-                                          // to replay the next event fNextEvent.
-                                          // Registraion of windows can last different time when recording and replaying.
-                                          // If there is an event ready to be replayed but the corresponding windows has not been yet
-                                          // registered, we wait (postopone fNextEvent) until it is registered.
+   Bool_t      fWaitingForWindow;   // Signalizes that we wait for a window to be registered in order
+                                    // to replay the next event fNextEvent.
+                                    // Registraion of windows can last different time when recording and replaying.
+                                    // If there is an event ready to be replayed but the corresponding windows has not been yet
+                                    // registered, we wait (postopone fNextEvent) until it is registered.
+
+   Bool_t      fEventReplayed;      // Signalizes that the last event sent to the replaying has been already replayed.
+                                    // Sometimes an execution of an event can take more time than during recording.
+                                    // This ensures that the next event is sent to replaying AFTER
+                                    // the replaying of the previous one finishes and not earlier.
+                                    // Exceptions: ButtonPress and ButtonRelease events (See TRecorderReplaying::CanBeOverlapped)
 
-   Bool_t            fEventReplayed;      // Signalizes that the last event sent to the replaying has been already replayed.
-                                          // Sometimes an execution of an event can take more time than during recording.
-                                          // This ensures that the next event is sent to replaying AFTER
-                                          // the replaying of the previous one finishes and not earlier.
-                                          // Exceptions: ButtonPress and ButtonRelease events (See TRecorderReplaying::CanBeOverlapped)
+   Bool_t      fShowMouseCursor;    // Specifies if mouse cursor should be also replayed
 
-   Bool_t            fShowMouseCursor;    // Specifies if mouse cursor should be also replayed
+   Bool_t      fFilterStatusBar;    // Special flag to filter status bar element
 
 protected:
    friend class TRecorderInactive;
@@ -555,12 +622,12 @@ protected:
 public:
    virtual TRecorder::ERecorderState GetState() const { return TRecorder::kReplaying; }
 
-   virtual void            Pause(TRecorder *r);
-   virtual void            Continue();
-   virtual void            ReplayStop(TRecorder *r);
+   virtual void   Pause(TRecorder *r);
+   virtual void   Continue();
+   virtual void   ReplayStop(TRecorder *r);
 
-   void        RegisterWindow(Window_t w);   //SLOT
-   void        ReplayRealtime();             //SLOT
+   void           RegisterWindow(Window_t w);   //SLOT
+   void           ReplayRealtime();             //SLOT
 
    ClassDef(TRecorderReplaying, 0) // Represents state of TRecorder when replaying
 };
@@ -587,14 +654,17 @@ private:
 
    TFile              *fFile;             // ROOT file to store recorded events in
    TTimer             *fTimer;            // Timer used for recording
+   ULong_t             fBeginPave;        // TLatex/TPaveLabel edition starting time
 
    TTree              *fWinTree;          // TTree with registered windows
    TTree              *fGuiTree;          // TTree with recorded GUI events
    TTree              *fCmdTree;          // TTree with recorded commandline events
+   TTree              *fExtraTree;        // TTree with recorded extra events (PaveLabels and Texts)
 
    ULong64_t           fWin;              // The newest registered window to be stored in TTree
    TRecGuiEvent       *fGuiEvent;         // The newest GUI event to be stored in TTree
    TRecCmdEvent       *fCmdEvent;         // The newest commandline event to be stored in TTree
+   TRecExtraEvent     *fExtraEvent;       // The newest extra event to be stored in TTree
 
    Bool_t              fCmdEventPending;  // Indication if there is a still pending commandline event that should be stored.
                                           // Commandline events are stored with 1 event delay to ensure skipping
@@ -606,6 +676,8 @@ private:
    Int_t               fFilteredIdsCount; // Only when GUI for recorder is used: Count of windows in GUI recorder
    Window_t           *fFilteredIds;      // Only when GUI for recorer is used: IDs of windows that creates that GUI.
                                           // Events for GUI recorder are not recorded.
+   Bool_t              fFilterEventPave;  // Special flag to filter events during the pave recording
+
 protected:
    friend class TRecorderInactive;
    TRecorderRecording(TRecorder *r, const char *filename, Option_t *option, Window_t *w, Int_t winCount);
@@ -621,6 +693,12 @@ public:
    void  RecordCmdEvent(const char* line);         //SLOT
    void  RecordGuiEvent(Event_t* e, Window_t wid); //SLOT
    void  RecordGuiCNEvent(Event_t* e);             //SLOT
+   void  RecordPave(const TObject* obj);           //SLOT
+   void  RecordText(const TObject* obj);           //SLOT
+   void  FilterEventPave();                        //SLOT
+   void  StartEditing();                           //SLOT
+
+   void  RecordExtraEvent(TString line, ULong_t ExtTime);
 
    ClassDef(TRecorderRecording, 0) // Represents state of TRecorder when recording events
 };
@@ -637,6 +715,10 @@ public:
 //////////////////////////////////////////////////////////////////////////
 class TRecorderInactive : public TRecorderState
 {
+
+private:
+   TSeqCollection *fCollect;
+
 public:
    virtual        ~TRecorderInactive() {}
    TRecorderInactive(){}
@@ -652,6 +734,8 @@ public:
    static void    DumpRootEvent(TRecGuiEvent *e, Int_t n);
    static long    DisplayValid(Long_t n) { return ( n < 0 ? -1 : n); }
 
+   void PrevCanvases(const char *filename, Option_t *option);
+
    ClassDef(TRecorderInactive, 0) // Represents state of TRecorder after its creation
 };
 
@@ -723,5 +807,8 @@ public:
    void Update();
    void Replay();
 
-   ClassDef(TGRecorder,0)             // GUI class of the event recorder.
+   ClassDef(TGRecorder,0) // GUI class of the event recorder.
 };
+
+#endif // ROOT_TRecorder
+
diff --git a/gui/recorder/src/TRecorder.cxx b/gui/recorder/src/TRecorder.cxx
index ca6a69b..2e6af43 100644
--- a/gui/recorder/src/TRecorder.cxx
+++ b/gui/recorder/src/TRecorder.cxx
@@ -120,13 +120,14 @@
 #include "TTimer.h"
 #include "TTree.h"
 #include "TMutex.h"
-
 #include "TGButton.h"
 #include "TGFileDialog.h"
 #include "TGLabel.h"
 #include "TGWindow.h"
 #include "Buttons.h"
-
+#include "TKey.h"
+#include "TPaveLabel.h"
+#include "TLatex.h"
 
 // Names of ROOT GUI events. Used for listing event logs.
 const char *kRecEventNames[] = {
@@ -154,10 +155,11 @@ const char *kRecEventNames[] = {
 };
 
 // Names of TTrees in the TFile with recorded events
-const char *kCmdEventTree = "CmdEvents";   // Name of TTree with commandline events
-const char *kGuiEventTree = "GuiEvents";   // Name of TTree with GUI events
-const char *kWindowsTree  = "WindowsTree"; // Name of TTree with window IDs
-const char *kBranchName   = "MainBranch";  // Name of the main branch in all TTress
+const char *kCmdEventTree   = "CmdEvents";   // Name of TTree with commandline events
+const char *kGuiEventTree   = "GuiEvents";   // Name of TTree with GUI events
+const char *kWindowsTree    = "WindowsTree"; // Name of TTree with window IDs
+const char *kExtraEventTree = "ExtraEvents"; // Name of TTree with extra events (PaveLabels and Texts)
+const char *kBranchName     = "MainBranch";  // Name of the main branch in all TTress
 
 ClassImp(TRecorder)
 
@@ -173,7 +175,7 @@ TRecorder::TRecorder()
 TRecorder::TRecorder(const char *filename, Option_t *option)
 {
    // Creates a recorder with filename to replay or to record,
-   // depending on option (NEW or RECREATE will start recording, 
+   // depending on option (NEW or RECREATE will start recording,
    // READ will start replaying)
 
    TString opt(option);
@@ -277,12 +279,19 @@ TRecorder::ERecorderState TRecorder::GetState() const
 }
 
 
+//______________________________________________________________________________
+void TRecorder::PrevCanvases(const char *filename, Option_t *option)
+{
+   // Save previous canvases in a .root file
+
+   fRecorderState->PrevCanvases(filename,option);
+}
 
 //______________________________________________________________________________
 // Represents state of TRecorder when replaying
 
 ClassImp(TRecorderReplaying)
-   
+
 //______________________________________________________________________________
 TRecorderReplaying::TRecorderReplaying(const char *filename)
 {
@@ -292,6 +301,7 @@ TRecorderReplaying::TRecorderReplaying(const char *filename)
    fFile       = new TFile(filename);
    fCmdEvent   = new TRecCmdEvent();
    fGuiEvent   = new TRecGuiEvent();
+   fExtraEvent = new TRecExtraEvent();
    fWindowList = new TList();
    fTimer      = new TTimer();
    fMutex      = new TMutex(kFALSE);
@@ -316,9 +326,8 @@ TRecorderReplaying::~TRecorderReplaying()
    delete fWindowList;
    delete fCmdEvent;
    delete fGuiEvent;
-
+   delete fExtraEvent;
    delete fMutex;
-
 }
 
 //______________________________________________________________________________
@@ -334,9 +343,12 @@ Bool_t TRecorderReplaying::Initialize(TRecorder *r, Bool_t showMouseCursor, TRec
    fWin              = 0;
    fGuiTreeCounter   = 0;
    fCmdTreeCounter   = 0;
+   fExtraTreeCounter = 0;
    fRegWinCounter    = 0;
    fRecorder         = 0;
 
+   fFilterStatusBar  = kFALSE;
+
    fWaitingForWindow = kFALSE;
 
    fEventReplayed    = 1;
@@ -347,11 +359,12 @@ Bool_t TRecorderReplaying::Initialize(TRecorder *r, Bool_t showMouseCursor, TRec
    if (fFile->IsZombie() || !fFile->IsOpen())
       return false;
 
-   fCmdTree = (TTree*) fFile->Get(kCmdEventTree);
-   fWinTree = (TTree*) fFile->Get(kWindowsTree);
-   fGuiTree = (TTree*) fFile->Get(kGuiEventTree);
+   fCmdTree   = (TTree*) fFile->Get(kCmdEventTree);
+   fWinTree   = (TTree*) fFile->Get(kWindowsTree);
+   fGuiTree   = (TTree*) fFile->Get(kGuiEventTree);
+   fExtraTree = (TTree*) fFile->Get(kExtraEventTree);
 
-   if (!fCmdTree || !fWinTree || ! fGuiTree) {
+   if (!fCmdTree || !fWinTree || ! fGuiTree || ! fExtraTree) {
       Error("TRecorderReplaying::Initialize", "The ROOT file is not valid event logfile.");
       return false;
    }
@@ -360,6 +373,7 @@ Bool_t TRecorderReplaying::Initialize(TRecorder *r, Bool_t showMouseCursor, TRec
       fCmdTree->SetBranchAddress(kBranchName, &fCmdEvent);
       fWinTree->SetBranchAddress(kBranchName, &fWin);
       fGuiTree->SetBranchAddress(kBranchName, &fGuiEvent);
+      fExtraTree->SetBranchAddress(kBranchName, &fExtraEvent);
    }
    catch(...) {
       Error("TRecorderReplaying::Initialize", "The ROOT file is not valid event logfile");
@@ -383,6 +397,24 @@ Bool_t TRecorderReplaying::Initialize(TRecorder *r, Bool_t showMouseCursor, TRec
 
    Info("TRecorderReplaying::Initialize", "Replaying of file %s started", fFile->GetName());
 
+   TFile f (fFile->GetName());
+   TIter nextkey(f.GetListOfKeys());
+   TKey *key;
+   while ((key = (TKey*)nextkey())) {
+      fFilterStatusBar = kTRUE;
+      fCanv = (TCanvas*) key->ReadObj();
+      fCanv->Draw();
+   }
+   TCanvas *canvas;
+   TIter nextc(gROOT->GetListOfCanvases());
+   while ((canvas = (TCanvas*)nextc())) {
+      canvas->SetWindowSize(canvas->GetWindowWidth(), canvas->GetWindowHeight());
+   }
+
+   fFilterStatusBar = kFALSE;
+
+   f.Close();
+
    fMutex->Lock();
    fMutex->UnLock();
 
@@ -404,6 +436,16 @@ void TRecorderReplaying::RegisterWindow(Window_t w)
    // The new window ID is mapped to the old one with the same number in the list of registered windows.
    // It means that 1st new window is mapped to the 1st original, 2nd to the 2nd, Nth new to the Nth original.
 
+   if (fFilterStatusBar) {
+      TGWindow *win = gClient->GetWindowById(w);
+      if (win) {
+         if (win->GetParent()->InheritsFrom("TGStatusBar")) {
+            fFilterStatusBar = kFALSE;
+            return;
+         }
+      }
+   }
+
    // Get original window ID that was registered as 'fRegWinCounter'th
    if (fWinTreeEntries > fRegWinCounter) {
       fWinTree->GetEntry(fRegWinCounter);
@@ -549,12 +591,17 @@ Bool_t TRecorderReplaying::PrepareNextEvent()
 
    fCmdEvent   =  0;
    fGuiEvent   =  0;
+   fExtraEvent =  0;
    fNextEvent  =  0;
 
    // Reads the next unreplayed commandline event to fCmdEvent
    if (fCmdTree->GetEntries() > fCmdTreeCounter)
       fCmdTree->GetEntry(fCmdTreeCounter);
 
+   // Reads the next unreplayed extra event to fExtraEvent
+   if (fExtraTree->GetEntries() > fExtraTreeCounter)
+      fExtraTree->GetEntry(fExtraTreeCounter);
+
    // Reads the next unreplayed GUI event to fGuiEvent
    // Skips GUI events that should not be replayed (FilterEvent call)
    while (fGuiTree->GetEntries() > fGuiTreeCounter) {
@@ -565,22 +612,51 @@ Bool_t TRecorderReplaying::PrepareNextEvent()
    }
 
    // Chooses which one will be fNextEvent (the next event to be replayed)
-   if (fCmdEvent && fGuiEvent) {
+   if (fCmdEvent && fGuiEvent && fExtraEvent) {
+      // If there are all uf them, compares their times and chooses the earlier one
+      if ((fCmdEvent->GetTime() <= fGuiEvent->GetTime()) &&
+          (fCmdEvent->GetTime() <= fExtraEvent->GetTime()))
+         fNextEvent = fCmdEvent;
+      else {
+         if (fGuiEvent->GetTime() <= fExtraEvent->GetTime())
+            fNextEvent = fGuiEvent;
+         else
+            fNextEvent = fExtraEvent;
+      }
+   }
+   else if (fCmdEvent && fGuiEvent) {
       // If there are both of them, compares their times and chooses the earlier one
       if (fCmdEvent->GetTime() <= fGuiEvent->GetTime())
          fNextEvent = fCmdEvent;
       else
          fNextEvent = fGuiEvent;
    }
-   // Nor commandline neither GUI event to replay
-   else if (!fCmdEvent && !fGuiEvent)
+   else if (fCmdEvent && fExtraEvent ) {
+      // If there are both of them, compares their times and chooses the earlier one
+      if (fCmdEvent->GetTime() <= fExtraEvent->GetTime())
+         fNextEvent = fCmdEvent;
+      else
+         fNextEvent = fExtraEvent;
+   }
+   else if (fGuiEvent && fExtraEvent) {
+      // If there are both of them, compares their times and chooses the earlier one
+      if (fExtraEvent->GetTime() <= fGuiEvent->GetTime())
+         fNextEvent = fExtraEvent;
+      else
+         fNextEvent = fGuiEvent;
+   }
+
+   // Nor commandline neither event to replay
+   else if (!fCmdEvent && !fGuiEvent && !fExtraEvent)
       fNextEvent = 0;
    // Only GUI event to replay
-   else if (!fCmdEvent)
+   else if (fGuiEvent)
       fNextEvent = fGuiEvent;
    // Only commandline event to replay
-   else
+   else if (fCmdEvent)
       fNextEvent = fCmdEvent;
+   else
+      fNextEvent = fExtraEvent;
 
    // Nothing to replay
    if (fNextEvent == 0)
@@ -590,6 +666,10 @@ Bool_t TRecorderReplaying::PrepareNextEvent()
    if (fNextEvent == fCmdEvent)
       fCmdTreeCounter++;
 
+   // Extra event to replay
+   if (fNextEvent == fExtraEvent)
+      fExtraTreeCounter++;
+
    // GUI event to replay
    if (fNextEvent == fGuiEvent) {
       // We have the new window to send this event to
@@ -599,7 +679,6 @@ Bool_t TRecorderReplaying::PrepareNextEvent()
       else
          fNextEvent = 0;
    }
-
    return kTRUE;
 }
 
@@ -620,6 +699,7 @@ Bool_t TRecorderReplaying::CanOverlap()
    if (fNextEvent->GetType() == TRecEvent::kCmdEvent)
       return kFALSE;
 
+
    if (gDebug > 0) {
       cout << "Event overlapping " << kRecEventNames[((TRecGuiEvent*)fNextEvent)->fType] << endl;
       TRecorderInactive::DumpRootEvent(((TRecGuiEvent*)fNextEvent), 0);
@@ -637,7 +717,6 @@ Bool_t TRecorderReplaying::CanOverlap()
       return kTRUE;
 
    return kFALSE;
-
 }
 
 //______________________________________________________________________________
@@ -655,9 +734,10 @@ void TRecorderReplaying::ReplayRealtime()
    //
 
    if ((gROOT->GetEditorMode() == kText) ||
-       (gROOT->GetEditorMode() == kPaveLabel))
+       (gROOT->GetEditorMode() == kPaveLabel)){
       gROOT->SetEditorMode();
-   
+   }
+
    // If there are automatically generated ROOT events in the queue, they are let to be handled first
    if (gVirtualX->EventsPending())
       return;
@@ -730,13 +810,11 @@ void TRecorderReplaying::Continue()
       fTimer->Start((ULong_t) (fNextEvent->GetTime() - fPreviousEventTime));
 }
 
-
-
 //______________________________________________________________________________
 // Represents state of TRecorder after its creation
 
 ClassImp(TRecorderInactive)
-   
+
 //______________________________________________________________________________
 void TRecorderInactive::Start(TRecorder *r, const char *filename, Option_t *option, Window_t *w, Int_t winCount)
 {
@@ -882,10 +960,21 @@ void TRecorderInactive::DumpRootEvent(TRecGuiEvent *e, Int_t n)
 }
 
 //______________________________________________________________________________
+void TRecorderInactive::PrevCanvases(const char *filename, Option_t *option)
+{
+   // Save previous canvases in a .root file
+
+   fCollect = gROOT->GetListOfCanvases();
+   TFile f (filename,option);
+   fCollect->Write();
+   f.Close();
+}
+
+//______________________________________________________________________________
 // Represents state of TRecorder when paused
-   
+
    ClassImp(TRecorderPaused)
-   
+
 //______________________________________________________________________________
 TRecorderPaused::TRecorderPaused(TRecorderReplaying *state)
 {
@@ -922,10 +1011,10 @@ void TRecorderPaused::ReplayStop(TRecorder *r)
 // Represents state of TRecorder when recording events
 
 ClassImp(TRecorderRecording)
-   
+
 //______________________________________________________________________________
-TRecorderRecording::TRecorderRecording(TRecorder *r, const char *filename, 
-                                       Option_t *option, Window_t *w, 
+TRecorderRecording::TRecorderRecording(TRecorder *r, const char *filename,
+                                       Option_t *option, Window_t *w,
                                        Int_t winCount)
 {
    // Initializes TRecorderRecording for recording
@@ -942,6 +1031,9 @@ TRecorderRecording::TRecorderRecording(TRecorder *r, const char *filename,
    // No unhandled commandline event in the beginning
    fCmdEventPending = kFALSE;
 
+   // Filer pave events (mouse button move)
+   fFilterEventPave = kFALSE;
+
    // No registered windows in the beginning
    fRegWinCounter = 0;
 
@@ -952,14 +1044,15 @@ TRecorderRecording::TRecorderRecording(TRecorder *r, const char *filename,
    fFile       = new TFile(filename, option);
 
    // TTrees with windows, commandline events and GUi events
-   fWinTree = new TTree(kWindowsTree,   "Windows");
-   fCmdTree = new TTree(kCmdEventTree,  "Commandline events");
-   fGuiTree = new TTree(kGuiEventTree,  "GUI events");
+   fWinTree   = new TTree(kWindowsTree,    "Windows");
+   fCmdTree   = new TTree(kCmdEventTree,   "Commandline events");
+   fGuiTree   = new TTree(kGuiEventTree,   "GUI events");
+   fExtraTree = new TTree(kExtraEventTree, "Extra events");
 
    fWin        = 0;
    fCmdEvent   = new TRecCmdEvent();
    fGuiEvent   = new TRecGuiEvent();
-
+   fExtraEvent = new TRecExtraEvent();
 }
 
 //______________________________________________________________________________
@@ -973,6 +1066,7 @@ TRecorderRecording::~TRecorderRecording()
    delete fTimer;
    delete fCmdEvent;
    delete fGuiEvent;
+   delete fExtraEvent;
 }
 
 //______________________________________________________________________________
@@ -994,10 +1088,47 @@ Bool_t TRecorderRecording::StartRecording()
    // When a kConfigureNotify event is processed in TGFrame::HandleEvent, TRecorderRecording::RecordGuiCNEvent(Event_t*) is called
    TQObject::Connect("TGFrame", "ProcessedConfigure(Event_t*)", "TRecorderRecording", this, "RecordGuiCNEvent(Event_t*)");
 
+   // When a PaveLabel is created, TRecorderRecording::RecordPave(TObject*) is called to record it
+   TQObject::Connect("TPad", "RecordPave(const TObject*)", "TRecorderRecording", this, "RecordPave(const TObject*)");
+
+   // When a Text is created, TRecorderRecording::RecordText() is called to record it
+   TQObject::Connect("TPad", "RecordLatex(const TObject*)", "TRecorderRecording", this, "RecordText(const TObject*)");
+
+   // When a PaveLabel is created, TRecorderRecording::FilterEventPave() is called to filter mouse clicks events.
+   TQObject::Connect("TPad", "EventPave()", "TRecorderRecording", this, "FilterEventPave()");
+
+   // When starting editing a TLatex or a TPaveLabel, StartEditing() is called to memorize edition starting time.
+   TQObject::Connect("TPad", "StartEditing()", "TRecorderRecording", this, "StartEditing()");
+
    // Creates in TTrees appropriate branches to store registered windows, commandline events and GUI events
    fWinTree->Branch(kBranchName, &fWin, "fWin/l");
    fCmdTree->Branch(kBranchName, " TRecCmdEvent", &fCmdEvent);
    fGuiTree->Branch(kBranchName, "TRecGuiEvent", &fGuiEvent);
+   fExtraTree->Branch(kBranchName, "TRecExtraEvent", &fExtraEvent);
+
+   Int_t numCanvases = gROOT->GetListOfCanvases()->LastIndex();
+
+   if (numCanvases >= 0){
+
+      TIter nextwindow (gClient->GetListOfWindows());
+      TGWindow *twin;
+      Window_t  twin2;
+      Int_t cnt = 0;
+      while ((twin = (TGWindow*) nextwindow())) {
+         twin2 = (Window_t) twin->GetId();
+         if (IsFiltered(twin2)) {
+            if (gDebug > 0) {
+               cout << "WindowID "<< twin2 << " filtered" << endl;
+            }
+         }
+         else if (twin != gClient->GetRoot()) {
+            RegisterWindow(twin2);
+         }
+         cnt++;
+      }
+      //Info("TRecorderRecording::StartRecording", "Previous Canvases");
+   }
+
 
    // Starts the timer for recording
    fTimer->TurnOn();
@@ -1013,6 +1144,10 @@ void TRecorderRecording::Stop(TRecorder *, Bool_t guiCommand)
    // Disconnects all slots and stopps recording.
 
    TQObject::Disconnect("TGFrame", "ProcessedConfigure(Event_t*)", this, "RecordGuiCNEvent(Event_t*)");
+   TQObject::Disconnect("TPad", "RecordPave(const TObject*)", this, "RecordPave(const TObject*)");
+   TQObject::Disconnect("TPad", "RecordLatex(const TObject*)", this, "RecordText(const TObject*)");
+   TQObject::Disconnect("TPad", "EventPave()", this, "FilterEventPave()");
+   TQObject::Disconnect("TPad", "StartEditing()", this, "StartEditing()");
    gClient->Disconnect(gClient, "ProcessedEvent(Event_t*, Window_t)", this, "RecordGuiEvent(Event_t*, Window_t)");
    gClient->Disconnect(gClient, "RegisteredWindow(Window_t)", this, "RegisterWindow(Window_t)");
    gApplication->Disconnect(gApplication, "LineProcessed(const char*)", this, "RecordCmdEvent(const char* line)");
@@ -1076,6 +1211,13 @@ void TRecorderRecording::RecordGuiEvent(Event_t* e, Window_t wid)
    if (fFilteredIdsCount && IsFiltered(e->fWindow))
       return;
 
+   // Doesn't record the mouse clicks when a pavelabel is recorded
+   if  (fFilterEventPave && (e->fCode == 1)) {
+      fFilterEventPave = kFALSE;
+      return;
+   }
+   fFilterEventPave = kFALSE;
+
    // Copies all items of e to fGuiEvent
    CopyEvent(e, wid);
 
@@ -1084,14 +1226,14 @@ void TRecorderRecording::RecordGuiEvent(Event_t* e, Window_t wid)
 
    // Saves recorded event itself in TTree
    fGuiTree->Fill();
-
 }
 
 //______________________________________________________________________________
 void TRecorderRecording::RecordGuiCNEvent(Event_t* e)
 {
    // Records GUI Event_t *e of type kConfigureNotify.
-   // It is called via signal-slot when an kConfigureNotify event is processed in TGFrame::HandleEvent
+   // It is called via signal-slot when an kConfigureNotify event is processed
+   // in TGFrame::HandleEvent
 
    // If this event is caused by a recorder itself, it is not recorded
    if (fFilteredIdsCount && IsFiltered(e->fWindow))
@@ -1112,6 +1254,117 @@ void TRecorderRecording::RecordGuiCNEvent(Event_t* e)
 }
 
 //______________________________________________________________________________
+void TRecorderRecording::RecordPave(const TObject* obj)
+{
+   // Records TPaveLabel object created in TCreatePrimitives::Pave()
+
+   ULong_t extratime = fBeginPave;
+   ULong_t interval = (unsigned long)fTimer->GetAbsTime() - fBeginPave;
+   TPaveLabel *pavel = (TPaveLabel *) obj;
+   const char* label;
+   label = pavel->GetLabel();
+   TString aux = "";
+   TString cad = "";
+   cad = "TPaveLabel *p = new TPaveLabel(";
+   cad += pavel->GetX1();
+   cad += ",";
+   cad += pavel->GetY1();
+   cad += ",";
+   cad += pavel->GetX2();
+   cad += ",";
+   cad += pavel->GetY2();
+   cad += ",\"\"); p->Draw(); gPad->Modified(); gPad->Update();";
+   Int_t i, len = (Int_t)strlen(label);
+   interval /= (ULong_t)(len + 2);
+   RecordExtraEvent(cad, extratime);
+   for (i=0; i < len; ++i) {
+      cad = "p->SetLabel(\"";
+      cad += (aux += label[i]);
+      cad += "\"); ";
+#ifndef R__WIN32
+      cad += " p->SetTextFont(83); p->SetTextSizePixels(14); ";
+#endif
+      cad += " gPad->Modified(); gPad->Update();";
+      extratime += interval;
+      RecordExtraEvent(cad, extratime);
+   }
+   cad  = "p->SetTextFont(";
+   cad += pavel->GetTextFont();
+   cad += "); p->SetTextSize(";
+   cad += pavel->GetTextSize();
+   cad += "); gPad->Modified(); gPad->Update();";
+   extratime += interval;
+   RecordExtraEvent(cad, extratime);
+}
+
+//______________________________________________________________________________
+void TRecorderRecording::RecordText(const TObject* obj)
+{
+   // Records TLatex object created in TCreatePrimitives::Text()
+
+   ULong_t extratime = fBeginPave;
+   ULong_t interval = (unsigned long)fTimer->GetAbsTime() - fBeginPave;
+   TLatex *texto = (TLatex *) obj;
+   const char* label;
+   label = texto->GetTitle();
+   TString aux = "";
+   TString cad = "";
+   cad = "TLatex *l = new TLatex(";
+   cad += texto->GetX();
+   cad += ",";
+   cad += texto->GetY();
+   cad += ",\"\"); l->Draw(); gPad->Modified(); gPad->Update();";
+   Int_t i, len = (Int_t)strlen(label);
+   interval /= (ULong_t)(len + 2);
+   RecordExtraEvent(cad, extratime);
+   for (i=0; i < len; ++i) {
+      cad = "l->SetTitle(\"";
+      cad += (aux += label[i]);
+      cad += "\"); ";
+#ifndef R__WIN32
+      cad += " l->SetTextFont(83); l->SetTextSizePixels(14); ";
+#endif
+      cad += " gPad->Modified(); gPad->Update();";
+      extratime += interval;
+      RecordExtraEvent(cad, extratime);
+   }
+   cad  = "l->SetTextFont(";
+   cad += texto->GetTextFont();
+   cad += "); l->SetTextSize(";
+   cad += texto->GetTextSize();
+   cad += "); gPad->Modified(); gPad->Update();";
+   extratime += interval;
+   RecordExtraEvent(cad, extratime);
+}
+
+//______________________________________________________________________________
+void TRecorderRecording::FilterEventPave()
+{
+   // Change the state of the flag to kTRUE when you are recording a pavelabel.
+
+   fFilterEventPave = kTRUE;
+}
+
+//______________________________________________________________________________
+void TRecorderRecording::StartEditing()
+{
+   // Memorize the starting time of editinga TLatex or a TPaveLabel
+
+   fBeginPave = (long)fTimer->GetAbsTime();
+}
+
+//______________________________________________________________________________
+void TRecorderRecording::RecordExtraEvent(TString line, ULong_t ExtTime)
+{
+   // Records TLatex or TPaveLabel object created in TCreatePrimitives,
+   // ExtTime is needed for the correct replay of these events.
+
+   fExtraEvent->SetTime(TTime(ExtTime));
+   fExtraEvent->SetText(line);
+   fExtraTree->Fill();
+}
+
+//______________________________________________________________________________
 void TRecorderRecording::CopyEvent(Event_t *e, Window_t wid)
 {
    // Copies all items of given event to fGuiEvent
@@ -1208,14 +1461,14 @@ void TRecorderRecording::SetTypeOfConfigureNotify(Event_t *e)
 // The GUI for the recorder
 
 ClassImp(TGRecorder)
-   
+
 //______________________________________________________________________________
 TGRecorder::TGRecorder(const TGWindow *p, UInt_t w, UInt_t h) :
    TGMainFrame(p ? p : gClient->GetRoot(), w, h)
 {
    // The GUI for the recorder
 
-   SetCleanup(kDeepCleanup);   
+   SetCleanup(kDeepCleanup);
    fRecorder = new TRecorder();
    fFilteredIds[0] = GetId();
 
@@ -1250,7 +1503,7 @@ TGRecorder::TGRecorder(const TGWindow *p, UInt_t w, UInt_t h) :
    fStatus->SetBackgroundColor((Pixel_t)0x000000);
    vframe->AddFrame(fStatus, new TGLayoutHints(kLHintsLeft | kLHintsTop,2,2,2,2));
    fFilteredIds[6] = fStatus->GetId();
-         
+
    fTimeDisplay = new TGLabel(vframe, "00:00:00");
    fTimeDisplay->SetTextColor(0x7cffff);
    fTimeDisplay->SetTextFont("Helvetica -34", kFALSE);
@@ -1259,7 +1512,7 @@ TGRecorder::TGRecorder(const TGWindow *p, UInt_t w, UInt_t h) :
    fFilteredIds[7] = fTimeDisplay->GetId();
 
    hframe->AddFrame(vframe, new TGLayoutHints(kLHintsLeft | kLHintsExpandY,10,0,0,0));
-      
+
    AddFrame(hframe, new TGLayoutHints(kLHintsExpandX,2,2,2,2));
 
    // Create a horizontal frame widget with buttons
@@ -1400,8 +1653,13 @@ void TGRecorder::StartStop()
 
          if (fi.fFilename && strlen(fi.fFilename)) {
 
-            fRecorder->Start(fi.fFilename, "RECREATE", fFilteredIds, fgWidgetsCount);
-
+            if (!gROOT->GetListOfCanvases()->IsEmpty()) {
+               fRecorder->PrevCanvases(fi.fFilename, "RECREATE");
+               fRecorder->Start(fi.fFilename, "UPDATE", fFilteredIds, fgWidgetsCount);
+            }
+            else {
+               fRecorder->Start(fi.fFilename, "RECREATE", fFilteredIds, fgWidgetsCount);
+            }
             fCursorCheckBox->SetDisabledAndSelected(kTRUE);
             fStartStop->SetPicture(gClient->GetPicture("stop.png"));
             fReplay->SetEnabled(kFALSE);
@@ -1598,3 +1856,4 @@ Event_t *TRecGuiEvent::CreateEvent(TRecGuiEvent *ge)
 }
 
 ClassImp(TRecWinPair)
+
diff --git a/gui/sessionviewer/src/TProofProgressDialog.cxx b/gui/sessionviewer/src/TProofProgressDialog.cxx
index 3899396..52e59f4 100644
--- a/gui/sessionviewer/src/TProofProgressDialog.cxx
+++ b/gui/sessionviewer/src/TProofProgressDialog.cxx
@@ -122,18 +122,18 @@ TProofProgressDialog::TProofProgressDialog(TProof *proof,
    fDialog->DontCallClose();
 
    // Title label
-   char buf[256];
-   sprintf(buf, "Executing on PROOF cluster \"%s\" with %d parallel workers:",
+   TString buf;
+   buf = TString::Format("Executing on PROOF cluster \"%s\" with %d parallel workers:",
            fProof ? fProof->GetMaster() : "<dummy>",
            fProof ? fProof->GetParallel() : 0);
    fTitleLab = new TGLabel(fDialog, buf),
    fDialog->AddFrame(fTitleLab,
                      new TGLayoutHints(kLHintsNormal, 10, 10, 20, 0));
-   sprintf(buf,"Selector: %s", selector);
+   buf = TString::Format("Selector: %s", selector);
    fSelector = new TGLabel(fDialog, buf);
    fDialog->AddFrame(fSelector,
                      new TGLayoutHints(kLHintsNormal, 10, 10, 5, 0));
-   sprintf(buf, "%d files, number of events %lld, starting event %lld",
+   buf = TString::Format("%d files, number of events %lld, starting event %lld",
            fFiles, fEntries, fFirst);
    fFilesEvents = new TGLabel(fDialog, buf);
    fDialog->AddFrame(fFilesEvents, new TGLayoutHints(kLHintsNormal, 10, 10, 5, 0));
@@ -241,8 +241,8 @@ TProofProgressDialog::TProofProgressDialog(TProof *proof,
    // Only enable if master supports it
    if (!PPD_SRV_NEWER_REV(gSVNMemPlot)) {
       fMemPlot->SetState(kButtonDisabled);
-      TString tip = Form("Not supported by the master: required SVN revision %d > %d",
-                         gSVNMemPlot, fSVNRev);
+      TString tip = TString::Format("Not supported by the master: required SVN revision %d > %d",
+                                    gSVNMemPlot, fSVNRev);
       fMemPlot->SetToolTipText(tip.Data());
    } else {
       fMemPlot->SetToolTipText("Show memory consumption");
@@ -298,8 +298,6 @@ TProofProgressDialog::TProofProgressDialog(TProof *proof,
 
    gVirtualX->TranslateCoordinates(main->GetId(), main->GetId(),
                           (mw - width), (mh - height) >> 1, ax, ay, wdum);
-   fDialog->Move(ax-5, ay - mh/4);
-   fDialog->SetWMPosition(ax-5, ay - mh/4);
 
    // Make the message box non-resizable
    fDialog->SetWMSize(width, height);
@@ -311,6 +309,8 @@ TProofProgressDialog::TProofProgressDialog(TProof *proof,
                                        kMWMFuncMinimize,
                         kMWMInputModeless);
 
+   fDialog->Move(ax-10, ay - mh/4);
+   fDialog->SetWMPosition(ax-10, ay - mh/4);
    // Popup dialog and wait till user replies
    fDialog->MapWindow();
 
@@ -323,10 +323,10 @@ void TProofProgressDialog::ResetProgressDialog(const char *selec,
                                                Long64_t entries)
 {
    // Reset dialog box preparing for new query
-   char buf[512];
+   TString buf;
 
    // Update title
-   sprintf(buf, "Executing on PROOF cluster \"%s\" with %d parallel workers:",
+   buf = TString::Format("Executing on PROOF cluster \"%s\" with %d parallel workers:",
            fProof ? fProof->GetMaster() : "<dummy>",
            fProof ? fProof->GetParallel() : 0);
    fTitleLab->SetText(buf);
@@ -340,14 +340,14 @@ void TProofProgressDialog::ResetProgressDialog(const char *selec,
    fStatus        = kRunning;
 
    // Update selector name
-   sprintf(buf,"Selector: %s", selec);
+   buf = TString::Format("Selector: %s", selec);
    fSelector->SetText(buf);
 
    // Reset 'processed' text
    fProcessed->SetText("Estimated time left:");
 
    // Update numbers
-   sprintf(buf, "%d files, number of events %lld, starting event %lld",
+   buf = TString::Format("%d files, number of events %lld, starting event %lld",
            fFiles, fEntries, fFirst);
    fFilesEvents->SetText(buf);
 
@@ -390,13 +390,13 @@ void TProofProgressDialog::Progress(Long64_t total, Long64_t processed)
 
    Long_t tt;
    UInt_t hh=0, mm=0, ss=0;
-   char buf[256];
+   TString buf;
    char stm[256];
    static const char *cproc[] = { "running", "done",
                                   "STOPPED", "ABORTED", "***EVENTS SKIPPED***"};
 
    // Update title
-   sprintf(buf, "Executing on PROOF cluster \"%s\" with %d parallel workers:",
+   buf = TString::Format("Executing on PROOF cluster \"%s\" with %d parallel workers:",
            fProof ? fProof->GetMaster() : "<dummy>",
            fProof ? fProof->GetParallel() : 0);
    fTitleLab->SetText(buf);
@@ -415,7 +415,7 @@ void TProofProgressDialog::Progress(Long64_t total, Long64_t processed)
 
    if (fEntries != total) {
       fEntries = total;
-      sprintf(buf, "%d files, number of events %lld, starting event %lld",
+      buf = TString::Format("%d files, number of events %lld, starting event %lld",
               fFiles, fEntries, fFirst);
       fFilesEvents->SetText(buf);
    }
@@ -445,7 +445,7 @@ void TProofProgressDialog::Progress(Long64_t total, Long64_t processed)
       else
          sprintf(stm, "%d sec", ss);
       fProcessed->SetText("Processed:");
-      sprintf(buf, "%lld events in %s", total, stm);
+      buf = TString::Format("%lld events in %s", total, stm);
       fTotal->SetText(buf);
 
       if (fProof) {
@@ -488,14 +488,14 @@ void TProofProgressDialog::Progress(Long64_t total, Long64_t processed)
       else
          sprintf(stm, "%d sec", ss);
       if (fStatus > kDone) {
-         sprintf(buf, "%s (%lld events of %lld processed) - %s",
+         buf = TString::Format("%s (%lld events of %lld processed) - %s",
                       stm, evproc, total, cproc[fStatus]);
       } else {
-         sprintf(buf, "%s (%lld events of %lld processed)",
+         buf = TString::Format("%s (%lld events of %lld processed)",
                       stm, evproc, total);
       }
       fTotal->SetText(buf);
-      sprintf(buf, "%.1f events/sec", Float_t(evproc)/Long_t(tdiff)*1000.);
+      buf = TString::Format("%.1f events/sec", Float_t(evproc)/Long_t(tdiff)*1000.);
       fRate->SetText(buf);
 
       if (processed < 0) {
@@ -524,20 +524,20 @@ void TProofProgressDialog::Progress(Long64_t total, Long64_t processed,
 
    Long_t tt;
    UInt_t hh=0, mm=0, ss=0;
-   char buf[256];
+   TString buf;
    char stm[256];
    static const char *cproc[] = { "running", "done",
                                   "STOPPED", "ABORTED", "***EVENTS SKIPPED***"};
 
    // Update title
-   sprintf(buf, "Executing on PROOF cluster \"%s\" with %d parallel workers:",
+   buf = TString::Format("Executing on PROOF cluster \"%s\" with %d parallel workers:",
            fProof ? fProof->GetMaster() : "<dummy>",
            fProof ? fProof->GetParallel() : 0);
    fTitleLab->SetText(buf);
 
    if (initTime >= 0.) {
       // Set init time
-      sprintf(buf, "%.1f secs", initTime);
+      buf = TString::Format("%.1f secs", initTime);
       fInit->SetText(buf);
       fDialog->Layout();
    }
@@ -560,7 +560,7 @@ void TProofProgressDialog::Progress(Long64_t total, Long64_t processed,
 
    if (fEntries != total) {
       fEntries = total;
-      sprintf(buf, "%d files, number of events %lld, starting event %lld",
+      buf = TString::Format("%d files, number of events %lld, starting event %lld",
               fFiles, fEntries, fFirst);
       fFilesEvents->SetText(buf);
    }
@@ -592,7 +592,7 @@ void TProofProgressDialog::Progress(Long64_t total, Long64_t processed,
          fStatus = kIncomplete;
          // We use a different color to highlight incompletion
          fBar->SetBarColor("magenta");
-         st = Form(" %s", cproc[fStatus]);
+         st = TString::Format(" %s", cproc[fStatus]);
       }
 
       tt = (Long_t)fProcTime;
@@ -608,10 +608,10 @@ void TProofProgressDialog::Progress(Long64_t total, Long64_t processed,
       else
          sprintf(stm, "%d sec", ss);
       fProcessed->SetText("Processed:");
-      sprintf(buf, "%lld events (%.2f MBs) in %s %s",
+      buf = TString::Format("%lld events (%.2f MBs) in %s %s",
               std::max(fPrevProcessed, processed), fAvgMBRate*fProcTime, stm, st.Data());
       fTotal->SetText(buf);
-      sprintf(buf, "%.1f evts/sec (%.1f MBs/sec)", fAvgRate, fAvgMBRate);
+      buf = TString::Format("%.1f evts/sec (%.1f MBs/sec)", fAvgRate, fAvgMBRate);
       fRate->SetText(buf);
       // Fill rate graph
       Bool_t useAvg = gEnv->GetValue("Proof.RatePlotUseAvg", 0);
@@ -670,22 +670,22 @@ void TProofProgressDialog::Progress(Long64_t total, Long64_t processed,
       else
          sprintf(stm, "%d sec", ss);
       if (fStatus > kDone) {
-         sprintf(buf, "%s (processed %lld events out of %lld - %.2f MBs of data) - %s",
+         buf = TString::Format("%s (processed %lld events out of %lld - %.2f MBs of data) - %s",
                       stm, evproc, total, mbsproc, cproc[fStatus]);
       } else {
-         sprintf(buf, "%s (processed %lld events out of %lld - %.2f MBs of data)",
+         buf = TString::Format("%s (processed %lld events out of %lld - %.2f MBs of data)",
                       stm, evproc, total, mbsproc);
       }
       fTotal->SetText(buf);
 
       // Post
       if (evtrti > 0.) {
-         sprintf(buf, "%.1f evts/sec (%.1f MBs/sec) - avg: %.1f evts/sec (%.1f MBs/sec)",
+         buf = TString::Format("%.1f evts/sec (%.1f MBs/sec) - avg: %.1f evts/sec (%.1f MBs/sec)",
                       evtrti, mbrti, fAvgRate, fAvgMBRate);
          fRatePoints->Fill(procTime, evtrti, mbrti);
          fRatePlot->SetState(kButtonUp);
       } else {
-         sprintf(buf, "avg: %.1f evts/sec (%.1f MBs/sec)", fAvgRate, fAvgMBRate);
+         buf = TString::Format("avg: %.1f evts/sec (%.1f MBs/sec)", fAvgRate, fAvgMBRate);
       }
       fRate->SetText(buf);
 
diff --git a/gui/sessionviewer/src/TProofProgressLog.cxx b/gui/sessionviewer/src/TProofProgressLog.cxx
index 4f25f5e..d641df6 100644
--- a/gui/sessionviewer/src/TProofProgressLog.cxx
+++ b/gui/sessionviewer/src/TProofProgressLog.cxx
@@ -166,16 +166,8 @@ TProofProgressLog::TProofProgressLog(TProofProgressDialog *d, Int_t w, Int_t h)
    SetIconName(title);
 
    MapSubwindows();
-
    Resize();
-
-   Window_t wdummy;
-   int ax, ay;
-   gVirtualX->TranslateCoordinates(GetParent()->GetId(), fDialog->fDialog->GetId(),
-       (Int_t)(((TGFrame *)GetParent())->GetWidth() + w),
-       (Int_t)(((TGFrame *)GetParent())->GetHeight()- 3*h/2), ax, ay, wdummy);
-   Move(ax, ay);
-
+   CenterOnParent();
    Popup();
 }
 
@@ -280,7 +272,7 @@ TGListBox* TProofProgressLog::BuildLogList(TGFrame *parent)
    Int_t is = 0;
    while ((pe=(TProofLogElem*)next())){
       TUrl url(pe->GetTitle());
-      TString buf = Form("%s %s", pe->GetName(), url.GetHost());
+      TString buf = TString::Format("%s %s", pe->GetName(), url.GetHost());
       c->AddEntry(buf.Data(), is);
       is++;
    }
@@ -386,8 +378,9 @@ void TProofProgressLog::SaveToFile()
    // File name: the default is <session-tag>.log
    TString filename = fFileName->GetText();
    if (filename.IsNull() || filename == "<session-tag>.log") {
-      filename = (fDialog && fDialog->fProof) ? Form("%s.log", fDialog->fProof->GetName())
-                                              : "proof.log";
+      filename = (fDialog && fDialog->fProof) ? 
+                  TString::Format("%s.log", fDialog->fProof->GetName()) :
+                  "proof.log";
    }
 
    TList *selected = new TList;
diff --git a/gui/sessionviewer/src/TProofProgressMemoryPlot.cxx b/gui/sessionviewer/src/TProofProgressMemoryPlot.cxx
index 4dcdc39..bcb6d01 100644
--- a/gui/sessionviewer/src/TProofProgressMemoryPlot.cxx
+++ b/gui/sessionviewer/src/TProofProgressMemoryPlot.cxx
@@ -108,17 +108,8 @@ TProofProgressMemoryPlot::TProofProgressMemoryPlot(TProofProgressDialog *d,
    SetIconName(title);
 
    MapSubwindows();
-
    Resize();
-
-   Window_t wdummy;
-   int ax, ay;
-   gVirtualX->TranslateCoordinates(GetParent()->GetId(), fDialog->fDialog->GetId(),
-       (Int_t)(((TGFrame *)GetParent())->GetWidth() + w),
-       (Int_t)(((TGFrame *)GetParent())->GetHeight()- 3*h/2), ax, ay, wdummy);
-   Move(ax, ay);
-
-   //Popup();
+   CenterOnParent();
    MapWindow();
 }
 
@@ -171,7 +162,7 @@ TGListBox* TProofProgressMemoryPlot::BuildLogList(TGFrame *parent)
    Int_t is = 1;
    while ((pe=(TProofLogElem*)next())){
       TUrl url(pe->GetTitle());
-      buf = Form("%s %s", pe->GetName(), url.GetHost());
+      buf = TString::Format("%s %s", pe->GetName(), url.GetHost());
       c->AddEntry(buf.Data(), is);
       is++;
    }
@@ -281,7 +272,7 @@ void TProofProgressMemoryPlot::DoPlot()
             gr->SetLineColor(2);
             gr->SetLineStyle(3);
             fWPlot->Add(gr, "l");
-            legw->AddEntry(gr, Form("%s - min", pltemp->GetName()) , "l");
+            legw->AddEntry(gr, TString::Format("%s - min", pltemp->GetName()) , "l");
          }
          pltemp = (TProofLogElem*)elem->At(max+1);
          gr = DoWorkerPlot(pltemp);
@@ -290,7 +281,7 @@ void TProofProgressMemoryPlot::DoPlot()
             gr->SetLineColor(2);
             gr->SetLineStyle(2);
             fWPlot->Add(gr, "l");
-            legw->AddEntry(gr, Form("%s - max", pltemp->GetName()), "l");
+            legw->AddEntry(gr, TString::Format("%s - max", pltemp->GetName()), "l");
          }
 
 
diff --git a/gui/sessionviewer/src/TSessionDialogs.cxx b/gui/sessionviewer/src/TSessionDialogs.cxx
index 7ea7508..46b08a9 100644
--- a/gui/sessionviewer/src/TSessionDialogs.cxx
+++ b/gui/sessionviewer/src/TSessionDialogs.cxx
@@ -192,13 +192,13 @@ void TNewChainDlg::OnElementClicked(TGLVEntry *entry, Int_t)
 
    fChain = (TObject *)entry->GetUserData();
    if (fChain->IsA() == TChain::Class()) {
-      TString s = Form("%s : %s" , ((TChain *)fChain)->GetTitle(),
-                      ((TChain *)fChain)->GetName());
+      TString s = TString::Format("%s : %s" , ((TChain *)fChain)->GetTitle(),
+                                  ((TChain *)fChain)->GetName());
       fName->SetText(s);
    }
    else if (fChain->IsA() == TDSet::Class()) {
-      TString s = Form("%s : %s" , ((TDSet *)fChain)->GetName(),
-                      ((TDSet *)fChain)->GetObjName());
+      TString s = TString::Format("%s : %s" , ((TDSet *)fChain)->GetName(),
+                                  ((TDSet *)fChain)->GetObjName());
       fName->SetText(s);
    }
    fOkButton->SetEnabled(kTRUE);
@@ -265,9 +265,9 @@ void TNewChainDlg::OnDoubleClick(TGLVEntry* f, Int_t btn)
    // Check if the file is a root macro file type
    if (name.Contains(".C")) {
       // form the command
-      TString command = Form(".x %s/%s",
-            gSystem->UnixPathName(fContents->GetDirectory()),
-            name.Data());
+      TString command = TString::Format(".x %s/%s",
+                        gSystem->UnixPathName(fContents->GetDirectory()),
+                        name.Data());
       // and process
       gApplication->ProcessLine(command.Data());
       UpdateList();
@@ -1083,10 +1083,10 @@ void TUploadDataSetDlg::AddFiles(const char *fileName)
          if (entryString.Index(rg) != kNPOS &&
              gSystem->AccessPathName(Form("%s/%s", gSystem->DirName(fileName),
                 ent), kReadPermission) == kFALSE) {
-            const char *text = Form("%s/%s",
+            TString text = TString::Format("%s/%s",
                gSystem->UnixPathName(gSystem->DirName(fileName)), ent);
-            if (!fLVContainer->FindItem(text)) {
-               TGLVEntry *entry = new TGLVEntry(fLVContainer, text, text);
+            if (!fLVContainer->FindItem(text.Data())) {
+               TGLVEntry *entry = new TGLVEntry(fLVContainer, text.Data(), text.Data());
                entry->SetPictures(gClient->GetPicture("rootdb_t.xpm"),
                                   gClient->GetPicture("rootdb_t.xpm"));
                fLVContainer->AddItem(entry);
@@ -1117,12 +1117,12 @@ void TUploadDataSetDlg::AddFiles(TList *fileList)
    TObjString *el;
    TIter next(fileList);
    while ((el = (TObjString *) next())) {
-      const char *fileName = Form("%s/%s",
+      TString fileName = TString::Format("%s/%s",
                   gSystem->UnixPathName(gSystem->DirName(el->GetString())),
                   gSystem->BaseName(el->GetString()));
       // single file
-      if (!fLVContainer->FindItem(fileName)) {
-         TGLVEntry *entry = new TGLVEntry(fLVContainer, fileName, fileName);
+      if (!fLVContainer->FindItem(fileName.Data())) {
+         TGLVEntry *entry = new TGLVEntry(fLVContainer, fileName.Data(), fileName.Data());
          entry->SetPictures(gClient->GetPicture("rootdb_t.xpm"),
                             gClient->GetPicture("rootdb_t.xpm"));
          fLVContainer->AddItem(entry);
@@ -1258,7 +1258,7 @@ void TUploadDataSetDlg::UploadDataSet()
       // ask user what to do :
       // cancel/overwrite and change option
       new TGMsgBox(fClient->GetRoot(), this, "Upload DataSet",
-                   Form("The dataset \"%s\" already exists on the cluster ! Overwrite ?",
+                   TString::Format("The dataset \"%s\" already exists on the cluster ! Overwrite ?",
                    dsetName), kMBIconQuestion, kMBYes | kMBNo | kMBCancel | kMBAppend,
                    &retval);
       if (retval == kMBYes) {
@@ -1293,9 +1293,9 @@ void TUploadDataSetDlg::UploadDataSet()
          // Notify user that file: obj->GetFirstUrl()->GetUrl() exists on
          // the cluster and ask user what to do
          new TGMsgBox(fClient->GetRoot(), this, "Upload DataSet",
-                   Form("The file \"%s\" already exists on the cluster ! Overwrite ?",
-                   obj->GetFirstUrl()->GetUrl()), kMBIconQuestion,
-                   kMBYes | kMBNo | kMBYesAll | kMBNoAll | kMBDismiss, &retval);
+                      TString::Format("The file \"%s\" already exists on the cluster ! Overwrite ?",
+                      obj->GetFirstUrl()->GetUrl()), kMBIconQuestion,
+                      kMBYes | kMBNo | kMBYesAll | kMBNoAll | kMBDismiss, &retval);
          if (retval == kMBYesAll) {
             ret = fViewer->GetActDesc()->fProof->UploadDataSet(dsetName,
                            skippedFiles, destination,
@@ -1304,7 +1304,7 @@ void TUploadDataSetDlg::UploadDataSet()
             if (ret == TProof::kError) {
                // Inform user
                new TGMsgBox(fClient->GetRoot(), this, "Upload DataSet",
-                            Form("Failed uploading \"%s\" to the cluster",
+                            TString::Format("Failed uploading \"%s\" to the cluster",
                             obj->GetFirstUrl()->GetUrl()), kMBIconExclamation,
                             kMBOk, &retval);
             }
@@ -1329,7 +1329,7 @@ void TUploadDataSetDlg::UploadDataSet()
             if (ret == TProof::kError) {
                // Inform user
                new TGMsgBox(fClient->GetRoot(), this, "Upload DataSet",
-                            Form("Failed uploading \"%s\" to the cluster",
+                            TString::Format("Failed uploading \"%s\" to the cluster",
                             obj->GetFirstUrl()->GetUrl()), kMBIconExclamation,
                             kMBOk, &retval);
             }
diff --git a/gui/sessionviewer/src/TSessionViewer.cxx b/gui/sessionviewer/src/TSessionViewer.cxx
index 6def54d..00ab014 100644
--- a/gui/sessionviewer/src/TSessionViewer.cxx
+++ b/gui/sessionviewer/src/TSessionViewer.cxx
@@ -676,9 +676,9 @@ void TSessionServerFrame::OnBtnAddClicked()
       desc = dynamic_cast<TSessionDescription*>(obj);
    if (desc) {
       new TGMsgBox(fClient->GetRoot(), fViewer, "Adding Session",
-          Form("The session \"%s\" already exists ! Overwrite ?",
-          fTxtName->GetText()), kMBIconQuestion, kMBYes | kMBNo |
-          kMBCancel, &retval);
+                   TString::Format("The session \"%s\" already exists ! Overwrite ?",
+                   fTxtName->GetText()), kMBIconQuestion, kMBYes | kMBNo |
+                   kMBCancel, &retval);
       if (retval != kMBYes)
          return;
       newSession = kFALSE;
@@ -1835,8 +1835,8 @@ void TSessionFrame::OnBtnGetQueriesClicked()
       while ((query = (TQueryResult *)nextp())) {
          // create new query description
          newquery = new TQueryDescription();
-         newquery->fReference = Form("%s:%s", query->GetTitle(),
-                                    query->GetName());
+         newquery->fReference = TString::Format("%s:%s", query->GetTitle(),
+                                                query->GetName());
          // check in our tree if it is already there
          TGListTreeItem *item =
             fViewer->GetSessionHierarchy()->FindChildByData(
@@ -1860,8 +1860,8 @@ void TSessionFrame::OnBtnGetQueriesClicked()
                TQueryDescription::kSessionQueryFinalized :
                (TQueryDescription::ESessionQueryStatus)query->GetStatus();
          newquery->fSelectorString  = query->GetSelecImp()->GetName();
-         newquery->fQueryName       = Form("%s:%s", query->GetTitle(),
-                                          query->GetName());
+         newquery->fQueryName       = TString::Format("%s:%s", query->GetTitle(),
+                                                      query->GetName());
          newquery->fOptions         = query->GetOptions();
          newquery->fEventList       = "";
          newquery->fNbFiles         = 0;
@@ -1894,8 +1894,8 @@ void TSessionFrame::OnCommandLine()
    const char *cmd = fCommandTxt->GetText();
    char opt[2];
    // form temporary file path
-   TString pathtmp = Form("%s/%s", gSystem->TempDirectory(),
-         kSession_RedirectCmd);
+   TString pathtmp = TString::Format("%s/%s", gSystem->TempDirectory(),
+                                     kSession_RedirectCmd);
    // if check box "clear view" is checked, open temp file in write mode
    // (overwrite), in append mode otherwise.
    if (fClearCheck->IsOn())
@@ -2592,18 +2592,18 @@ void TSessionQueryFrame::Progress(Long64_t total, Long64_t processed)
    // if no change since last call, just return
    if (fPrevProcessed == processed)
       return;
-   char *buf;
+   TString buf;
 
    // Update informations at first call
    if (fEntries != total) {
-      buf = Form("PROOF cluster : \"%s\" - %d worker nodes",
-            fViewer->GetActDesc()->fProof->GetMaster(),
-            fViewer->GetActDesc()->fProof->GetParallel());
+      buf = TString::Format("PROOF cluster : \"%s\" - %d worker nodes",
+                            fViewer->GetActDesc()->fProof->GetMaster(),
+                            fViewer->GetActDesc()->fProof->GetParallel());
       fLabInfos->SetText(buf);
 
       fEntries = total;
-      buf = Form(" %d files, %lld events, starting event %lld",
-              fFiles, fEntries, fFirst);
+      buf = TString::Format(" %d files, %lld events, starting event %lld",
+                            fFiles, fEntries, fFirst);
       fLabStatus->SetText(buf);
    }
 
@@ -2655,17 +2655,17 @@ void TSessionQueryFrame::Progress(Long64_t total, Long64_t processed)
          sprintf(stm, "%d min %d sec", mm, ss);
       else
          sprintf(stm, "%d sec", ss);
-      buf = Form(" Processed : %lld events in %s", total, stm);
+      buf = TString::Format(" Processed : %lld events in %s", total, stm);
       fTotal->SetText(buf);
    } else {
       // update status infos
-      buf = Form(" Estimated time left : %s (%lld events of %lld processed)        ",
-                 stm, processed, total);
+      buf = TString::Format(" Estimated time left : %s (%lld events of %lld processed)        ",
+                            stm, processed, total);
       fTotal->SetText(buf);
    }
    if (processed > 0 && (Long_t)tdiff > 0) {
-      buf = Form(" Processing Rate : %.1f events/sec   ",
-                 (Float_t)processed/(Long_t)tdiff*1000.);
+      buf = TString::Format(" Processing Rate : %.1f events/sec   ",
+                           (Float_t)processed/(Long_t)tdiff*1000.);
       fRate->SetText(buf);
    }
    fPrevProcessed = processed;
@@ -2692,27 +2692,27 @@ void TSessionQueryFrame::ProgressLocal(Long64_t total, Long64_t processed)
 
    Long_t tt;
    UInt_t hh=0, mm=0, ss=0;
-   char stm[256];
-   char cproc[80];
+   TString stm;
+   TString cproc;
    Int_t status;
 
    switch (fViewer->GetActDesc()->fActQuery->fStatus) {
 
       case TQueryDescription::kSessionQueryAborted:
-         strcpy(cproc, " - ABORTED");
+         cproc = " - ABORTED";
          status = kAborted;
          break;
       case TQueryDescription::kSessionQueryStopped:
-         strcpy(cproc, " - STOPPED");
+         cproc = " - STOPPED";
          status = kStopped;
          break;
       case TQueryDescription::kSessionQueryRunning:
-         strcpy(cproc, " ");
+         cproc = " ";
          status = kRunning;
          break;
       case TQueryDescription::kSessionQueryCompleted:
       case TQueryDescription::kSessionQueryFinalized:
-         strcpy(cproc, " ");
+         cproc = " ";
          status = kDone;
          break;
       default:
@@ -2740,16 +2740,16 @@ void TSessionQueryFrame::ProgressLocal(Long64_t total, Long64_t processed)
       fPrevTotal = total;
 
    // if no change since last call, just return
-   char *buf;
+   TString buf;
 
    // Update informations at first call
    if (fEntries != total) {
       fLabInfos->SetText("Local Session");
 
       fEntries = total;
-      buf = Form(" %d files, %lld events, starting event %lld",
-              fFiles, fEntries, fFirst);
-      fLabStatus->SetText(buf);
+      buf = TString::Format(" %d files, %lld events, starting event %lld",
+                            fFiles, fEntries, fFirst);
+      fLabStatus->SetText(buf.Data());
    }
 
    // compute progress bar position and update
@@ -2780,15 +2780,15 @@ void TSessionQueryFrame::ProgressLocal(Long64_t total, Long64_t processed)
       ss = (UInt_t)((tt % 3600) % 60);
    }
    if (hh)
-      sprintf(stm, "%d h %d min %d sec", hh, mm, ss);
+      stm = TString::Format("%d h %d min %d sec", hh, mm, ss);
    else if (mm)
-      sprintf(stm, "%d min %d sec", mm, ss);
+      stm = TString::Format("%d min %d sec", mm, ss);
    else
-      sprintf(stm, "%d sec", ss);
+      stm = TString::Format("%d sec", ss);
    if ((processed != total) && (status == kRunning)) {
       // update status infos
-      buf = Form(" Estimated time left : %s (%lld events of %lld processed)        ",
-                 stm, processed, total);
+      buf = TString::Format(" Estimated time left : %s (%lld events of %lld processed)        ",
+                            stm.Data(), processed, total);
       fTotal->SetText(buf);
    } else {
       tt = (Long_t(tdiff)/1000);
@@ -2798,19 +2798,19 @@ void TSessionQueryFrame::ProgressLocal(Long64_t total, Long64_t processed)
          ss = (UInt_t)((tt % 3600) % 60);
       }
       if (hh)
-         sprintf(stm, "%d h %d min %d sec", hh, mm, ss);
+         stm = TString::Format("%d h %d min %d sec", hh, mm, ss);
       else if (mm)
-         sprintf(stm, "%d min %d sec", mm, ss);
+         stm = TString::Format("%d min %d sec", mm, ss);
       else
-         sprintf(stm, "%d sec", ss);
-      buf = Form(" Processed : %ld events in %s", (Long_t)processed, stm);
-      strcat(buf, cproc);
-      fTotal->SetText(buf);
+         stm = TString::Format("%d sec", ss);
+      buf = TString::Format(" Processed : %ld events in %s", (Long_t)processed, stm.Data());
+      buf += cproc;
+      fTotal->SetText(buf.Data());
    }
    if (processed > 0 && (Long_t)tdiff > 0) {
-      buf = Form(" Processing Rate : %.1f events/sec   ",
-                 (Float_t)processed/(Long_t)tdiff*1000.);
-      fRate->SetText(buf);
+      buf = TString::Format(" Processing Rate : %.1f events/sec   ",
+                            (Float_t)processed/(Long_t)tdiff*1000.);
+      fRate->SetText(buf.Data());
    }
    fPrevProcessed = processed;
 
@@ -2848,7 +2848,7 @@ void TSessionQueryFrame::ResetProgressDialog(const char * /*selector*/, Int_t fi
 {
    // Reset progress frame information fields.
 
-   char *buf;
+   TString buf;
    fFiles         = files > 0 ? files : 0;
    fFirst         = first;
    fEntries       = entries;
@@ -2860,10 +2860,10 @@ void TSessionQueryFrame::ResetProgressDialog(const char * /*selector*/, Int_t fi
       frmProg->Reset();
    }
 
-   buf = Form("%0d files, %0lld events, starting event %0lld",
-           fFiles > 0 ? fFiles : 0, fEntries > 0 ? fEntries : 0,
-           fFirst >= 0 ? fFirst : 0);
-   fLabStatus->SetText(buf);
+   buf = TString::Format("%0d files, %0lld events, starting event %0lld",
+                         fFiles > 0 ? fFiles : 0, fEntries > 0 ? fEntries : 0,
+                         fFirst >= 0 ? fFirst : 0);
+   fLabStatus->SetText(buf.Data());
    // Reconnect the slots
    if (fViewer->GetActDesc()->fProof &&
        fViewer->GetActDesc()->fProof->IsValid()) {
@@ -2874,10 +2874,10 @@ void TSessionQueryFrame::ResetProgressDialog(const char * /*selector*/, Int_t fi
                "Progress(Long64_t,Long64_t,Long64_t,Float_t,Float_t,Float_t,Float_t)");
       fViewer->GetActDesc()->fProof->Connect("StopProcess(Bool_t)",
                "TSessionQueryFrame", this, "IndicateStop(Bool_t)");
-      sprintf(buf, "PROOF cluster : \"%s\" - %d worker nodes",
+      buf = TString::Format("PROOF cluster : \"%s\" - %d worker nodes",
                fViewer->GetActDesc()->fProof->GetMaster(),
                fViewer->GetActDesc()->fProof->GetParallel());
-      fLabInfos->SetText(buf);
+      fLabInfos->SetText(buf.Data());
    }
    else if (fViewer->GetActDesc()->fLocal) {
       fStatsCanvas->Clear();
@@ -3102,8 +3102,8 @@ void TSessionQueryFrame::OnBtnSubmit()
          return;
       }
       // set query reference id to unique identifier
-      newquery->fReference= Form("session-%s:q%lld",
-            fViewer->GetActDesc()->fProof->GetSessionTag(), id);
+      newquery->fReference= TString::Format("session-%s:q%lld",
+                            fViewer->GetActDesc()->fProof->GetSessionTag(), id);
       // start icon animation
       fViewer->SetChangePic(kTRUE);
    }
@@ -3153,7 +3153,7 @@ void TSessionQueryFrame::OnBtnSubmit()
          return;
       }
       // set query reference id to unique identifier
-      newquery->fReference = Form("local-session-%s:q%lld", newquery->fQueryName.Data(), id);
+      newquery->fReference = TString::Format("local-session-%s:q%lld", newquery->fQueryName.Data(), id);
    }
    // update buttons state
    UpdateButtons(newquery);
@@ -3272,7 +3272,7 @@ void TSessionQueryFrame::UpdateInfos()
 {
    // Update query information (header) text view.
 
-   char *buffer;
+   TString buffer;
    const char *qst[] = {"aborted  ", "submitted", "running  ",
                         "stopped  ", "completed"};
 
@@ -3323,49 +3323,47 @@ void TSessionQueryFrame::UpdateInfos()
 
    Int_t qry = result->GetSeqNum();
 
-   buffer = Form("------------------------------------------------------\n");
+   buffer = TString::Format("------------------------------------------------------\n");
    // Print header
    if (!result->IsDraw()) {
       const char *fin = result->IsFinalized() ? "finalized" : qst[st];
       const char *arc = result->IsArchived() ? "(A)" : "";
-      buffer = Form("%s Query No  : %d\n", buffer, qry);
-      buffer = Form("%s Ref       : \"%s:%s\"\n", buffer, result->GetTitle(),
-                 result->GetName());
-      buffer = Form("%s Selector  : %s\n", buffer,
-                 result->GetSelecImp()->GetTitle());
-      buffer = Form("%s Status    : %9s%s\n", buffer, fin, arc);
-      buffer = Form("%s------------------------------------------------------\n",
-                 buffer);
+      buffer = TString::Format(" Query No  : %d\n", qry);
+      buffer += TString::Format(" Ref       : \"%s:%s\"\n", result->GetTitle(),
+                                result->GetName());
+      buffer += TString::Format(" Selector  : %s\n",
+                                result->GetSelecImp()->GetTitle());
+      buffer += TString::Format("Status    : %9s%s\n", fin, arc);
+      buffer += TString::Format("------------------------------------------------------\n");
    } else {
-      buffer = Form("%s Query No  : %d\n", buffer, qry);
-      buffer = Form("%s Ref       : \"%s:%s\"\n", buffer, result->GetTitle(),
-                 result->GetName());
-      buffer = Form("%s Selector  : %s\n", buffer,
-                 result->GetSelecImp()->GetTitle());
-      buffer = Form("%s------------------------------------------------------\n",
-                 buffer);
+      buffer += TString::Format(" Query No  : %d\n", qry);
+      buffer += TString::Format(" Ref       : \"%s:%s\"\n", result->GetTitle(),
+                                result->GetName());
+      buffer += TString::Format(" Selector  : %s\n",
+                                result->GetSelecImp()->GetTitle());
+      buffer += TString::Format("------------------------------------------------------\n");
    }
 
    // Time information
    Int_t elapsed = (Int_t)(result->GetEndTime().Convert() -
                            result->GetStartTime().Convert());
-   buffer = Form("%s Started   : %s\n",buffer,
-              result->GetStartTime().AsString());
-   buffer = Form("%s Real time : %d sec (CPU time: %.1f sec)\n", buffer, elapsed,
-              result->GetUsedCPU());
+   buffer += TString::Format(" Started   : %s\n",
+                             result->GetStartTime().AsString());
+   buffer += TString::Format(" Real time : %d sec (CPU time: %.1f sec)\n", 
+                             elapsed, result->GetUsedCPU());
 
    // Number of events processed, rate, size
    Double_t rate = 0.0;
    if (result->GetEntries() > -1 && elapsed > 0)
       rate = result->GetEntries() / (Double_t)elapsed ;
    Float_t size = ((Float_t)result->GetBytes())/(1024*1024);
-   buffer = Form("%s Processed : %lld events (size: %.3f MBs)\n",buffer,
-              result->GetEntries(), size);
-   buffer = Form("%s Rate      : %.1f evts/sec\n",buffer, rate);
+   buffer += TString::Format(" Processed : %lld events (size: %.3f MBs)\n",
+                             result->GetEntries(), size);
+   buffer += TString::Format(" Rate      : %.1f evts/sec\n", rate);
 
    // Package information
    if (strlen(result->GetParList()) > 1) {
-      buffer = Form("%s Packages  :  %s\n",buffer, result->GetParList());
+      buffer += TString::Format("%s Packages  :  %s\n", result->GetParList());
    }
 
    // Result information
@@ -3382,18 +3380,16 @@ void TSessionQueryFrame::UpdateInfos()
       }
    }
    if (res.Length() > 1) {
-      buffer = Form("%s------------------------------------------------------\n",
-                 buffer);
-      buffer = Form("%s Results   : %s\n",buffer, res.Data());
+      buffer += TString::Format("------------------------------------------------------\n");
+      buffer += TString::Format(" Results   : %s\n", res.Data());
    }
 
    if (result->GetOutputList() && result->GetOutputList()->GetSize() > 0) {
-      buffer = Form("%s Outlist   : %d objects\n",buffer,
-                 result->GetOutputList()->GetSize());
-      buffer = Form("%s------------------------------------------------------\n",
-                 buffer);
+      buffer += TString::Format("%s Outlist   : %d objects\n",
+                                result->GetOutputList()->GetSize());
+      buffer += TString::Format("------------------------------------------------------\n");
    }
-   fInfoTextView->LoadBuffer(buffer);
+   fInfoTextView->LoadBuffer(buffer.Data());
 
    //Float_t pos = Float_t((Double_t)(result->GetEntries() * 100)/(Double_t)total);
    if (result->GetStatus() == TQueryResult::kAborted)
@@ -3405,11 +3401,11 @@ void TSessionQueryFrame::UpdateInfos()
 
    frmProg->SetPosition(100.0);
 
-   buffer = Form(" Processed : %lld events in %.1f sec", result->GetEntries(),
-              (Float_t)elapsed);
-   fTotal->SetText(buffer);
-   buffer = Form(" Processing Rate : %.1f events/sec   ", rate);
-   fRate->SetText(buffer);
+   buffer = TString::Format(" Processed : %lld events in %.1f sec", result->GetEntries(),
+                           (Float_t)elapsed);
+   fTotal->SetText(buffer.Data());
+   buffer = TString::Format(" Processing Rate : %.1f events/sec   ", rate);
+   fRate->SetText(buffer.Data());
    fFB->Layout();
 }
 
@@ -3483,7 +3479,7 @@ void TSessionOutputFrame::OnElementDblClicked(TGLVEntry* entry, Int_t , Int_t, I
    gPad->SetEditable(kFALSE);
    // check default action from root.mimes
    if (fClient->GetMimeTypeList()->GetAction(obj->IsA()->GetName(), action)) {
-      act = Form("((%s*)0x%lx)%s", obj->IsA()->GetName(), (Long_t)obj, action);
+      act = TString::Format("((%s*)0x%lx)%s", obj->IsA()->GetName(), (Long_t)obj, action);
       if (act[0] == '!') {
          act.Remove(0, 1);
          gSystem->Exec(act.Data());
@@ -4140,17 +4136,17 @@ void TSessionViewer::WriteConfiguration(const char *filename)
       sessionstring += ";";
       sessionstring += session->fAddress;
       sessionstring += ";";
-      sessionstring += Form("%d", session->fPort);
+      sessionstring += TString::Format("%d", session->fPort);
       sessionstring += ";";
-      sessionstring += Form("%d", session->fLogLevel);
+      sessionstring += TString::Format("%d", session->fLogLevel);
       sessionstring += ";";
       sessionstring += session->fConfigFile.Length() > 1 ? session->fConfigFile.Data() : " ";
       sessionstring += ";";
       sessionstring += session->fUserName;
       sessionstring += ";";
-      sessionstring += Form("%d", session->fSync);
+      sessionstring += TString::Format("%d", session->fSync);
       sessionstring += ";";
-      sessionstring += Form("%d", session->fAutoEnable);
+      sessionstring += TString::Format("%d", session->fAutoEnable);
       if (scnt > 0) // skip local session
          fViewerEnv->SetValue(Form("SessionDescription.%d",scnt), sessionstring);
       scnt++;
@@ -4158,7 +4154,7 @@ void TSessionViewer::WriteConfiguration(const char *filename)
       TIter qnext(session->fQueries);
       while ((query = (TQueryDescription *) qnext())) {
          TString querystring;
-         querystring += Form("%d", query->fStatus);
+         querystring += TString::Format("%d", query->fStatus);
          querystring += ";";
          querystring += query->fReference.Length() > 1 ? query->fReference.Data() : " ";
          querystring += ";";
@@ -4172,11 +4168,11 @@ void TSessionViewer::WriteConfiguration(const char *filename)
          querystring += ";";
          querystring += query->fEventList.Length() > 1 ? query->fEventList.Data() : " ";
          querystring += ";";
-         querystring += Form("%d",query->fNbFiles);
+         querystring += TString::Format("%d",query->fNbFiles);
          querystring += ";";
-         querystring += Form("%d",query->fNoEntries);
+         querystring += TString::Format("%d",query->fNoEntries);
          querystring += ";";
-         querystring += Form("%d",query->fFirstEntry);
+         querystring += TString::Format("%d",query->fFirstEntry);
          fViewerEnv->SetValue(Form("QueryDescription.%d",qcnt), querystring);
          qcnt++;
       }
@@ -4249,9 +4245,9 @@ void TSessionViewer::Build()
 
    fViewerEnv = 0;
 #ifdef WIN32
-   fConfigFile = Form("%s\\%s", gSystem->HomeDirectory(), kConfigFile);
+   fConfigFile = TString::Format("%s\\%s", gSystem->HomeDirectory(), kConfigFile);
 #else
-   fConfigFile = Form("%s/%s", gSystem->HomeDirectory(), kConfigFile);
+   fConfigFile = TString::Format("%s/%s", gSystem->HomeDirectory(), kConfigFile);
 #endif
 
    fCascadeMenu = new TGPopupMenu(fClient->GetDefaultRoot());
@@ -4797,11 +4793,11 @@ void TSessionViewer::Terminate()
 
    // clean-up temporary files
    TString pathtmp;
-   pathtmp = Form("%s/%s", gSystem->TempDirectory(), kSession_RedirectFile);
+   pathtmp = TString::Format("%s/%s", gSystem->TempDirectory(), kSession_RedirectFile);
    if (!gSystem->AccessPathName(pathtmp)) {
       gSystem->Unlink(pathtmp);
    }
-   pathtmp = Form("%s/%s", gSystem->TempDirectory(), kSession_RedirectCmd);
+   pathtmp = TString::Format("%s/%s", gSystem->TempDirectory(), kSession_RedirectCmd);
    if (!gSystem->AccessPathName(pathtmp)) {
       gSystem->Unlink(pathtmp);
    }
@@ -4825,11 +4821,11 @@ void TSessionViewer::CloseWindow()
 
    // clean-up temporary files
    TString pathtmp;
-   pathtmp = Form("%s/%s", gSystem->TempDirectory(), kSession_RedirectFile);
+   pathtmp = TString::Format("%s/%s", gSystem->TempDirectory(), kSession_RedirectFile);
    if (!gSystem->AccessPathName(pathtmp)) {
       gSystem->Unlink(pathtmp);
    }
-   pathtmp = Form("%s/%s", gSystem->TempDirectory(), kSession_RedirectCmd);
+   pathtmp = TString::Format("%s/%s", gSystem->TempDirectory(), kSession_RedirectCmd);
    if (!gSystem->AccessPathName(pathtmp)) {
       gSystem->Unlink(pathtmp);
    }
@@ -5161,7 +5157,7 @@ void TSessionViewer::ShowPackages()
    if (fActDesc->fLocal) return;
    if (!fActDesc->fProof || !fActDesc->fProof->IsValid())
       return;
-   TString pathtmp = Form("%s/%s", gSystem->TempDirectory(),
+   TString pathtmp = TString::Format("%s/%s", gSystem->TempDirectory(),
             kSession_RedirectFile);
    // redirect stdout/stderr to temp file
    if (gSystem->RedirectOutput(pathtmp.Data(), "w") != 0) {
@@ -5246,7 +5242,7 @@ void TSessionViewer::ShowEnabledPackages()
    if (fActDesc->fLocal) return;
    if (!fActDesc->fProof || !fActDesc->fProof->IsValid())
       return;
-   TString pathtmp = Form("%s/%s", gSystem->TempDirectory(),
+   TString pathtmp = TString::Format("%s/%s", gSystem->TempDirectory(),
          kSession_RedirectFile);
    // redirect stdout/stderr to temp file
    if (gSystem->RedirectOutput(pathtmp.Data(), "w") != 0) {
@@ -5327,7 +5323,7 @@ void TSessionViewer::ShowStatus()
 
    if (!fActDesc->fProof || !fActDesc->fProof->IsValid())
       return;
-   TString pathtmp = Form("%s/%s", gSystem->TempDirectory(),
+   TString pathtmp = TString::Format("%s/%s", gSystem->TempDirectory(),
             kSession_RedirectFile);
    // redirect stdout/stderr to temp file
    if (gSystem->RedirectOutput(pathtmp.Data(), "w") != 0) {
diff --git a/tutorials/eve/alice_esd.C b/tutorials/eve/alice_esd.C
index 79cb0d5..01d9d6e 100644
--- a/tutorials/eve/alice_esd.C
+++ b/tutorials/eve/alice_esd.C
@@ -104,21 +104,43 @@ Double_t   trackGetP(AliExternalTrackParam* tp);
 // Configuration and global variables.
 
 const char* esd_file_name         = "http://root.cern.ch/files/alice_ESDs.root";
-//const char* esd_friends_file_name = "http://root.cern.ch/files/alice_ESDfriends.root";
-const char* esd_friends_file_name = "http://root.cern.ch/files/AliESDfriends.root";
+// Temporarily disable reading of ESD friend.
+// There seems to be no way to get it working without AliRoot.
+// const char* esd_friends_file_name = "http://root.cern.ch/files/alice_ESDfriends.root";
+const char* esd_friends_file_name = 0;
+
 const char* esd_geom_file_name    = "http://root.cern.ch/files/alice_ESDgeometry.root";
 
+// For testing
+// const char* esd_file_name         = "AliESDs.root";
+// const char* esd_friends_file_name = "AliESDfriends.root";
+
 TFile *esd_file          = 0;
 TFile *esd_friends_file  = 0;
 
 TTree *esd_tree          = 0;
 
 AliESDEvent  *esd        = 0;
+TList        *esd_objs   = 0;
 AliESDfriend *esd_friend = 0;
 
 Int_t esd_event_id       = 0; // Current event id.
 
-TEveTrackList *track_list = 0;
+TEveTrackList *gTrackList = 0;
+
+TEveGeoShape *gGeomGentle = 0;
+
+TEveProjectionManager *gRPhiMgr = 0;
+TEveProjectionManager *gRhoZMgr = 0;
+
+TEveViewer *g3DView   = 0;
+TEveViewer *gRPhiView = 0;
+TEveViewer *gRhoZView = 0;
+
+TEveScene *gRPhiGeomScene  = 0;
+TEveScene *gRhoZGeomScene  = 0;
+TEveScene *gRPhiEventScene = 0;
+TEveScene *gRhoZEventScene = 0;
 
 
 /******************************************************************************/
@@ -138,7 +160,7 @@ void alice_esd()
 
    TFile::SetCacheFileDir(".");
 
-   if (!alice_esd_loadlib(esd_file_name, "aliesd"))
+   if (!alice_esd_loadlib("aliesd"))
    {
       Error("alice_esd", "Can not load project libraries.");
       return;
@@ -149,35 +171,58 @@ void alice_esd()
    if (!esd_file)
       return;
 
-   printf("*** Opening ESD-friends ***\n");
-   esd_friends_file = TFile::Open(esd_friends_file_name, "CACHEREAD");
-   if (!esd_friends_file)
-      return;
+   esd_tree = (TTree*)       esd_file->Get("esdTree");
+   esd      = (AliESDEvent*) esd_tree->GetUserInfo()->FindObject("AliESDEvent");
+   esd_objs = esd->fESDObjects;
 
-   esd_tree = (TTree*) esd_file->Get("esdTree");
-   esd_tree->GetBranch("ESDfriend.")->SetFile(esd_friends_file);
-   
-   esd = (AliESDEvent*) esd_tree->GetUserInfo()->FindObject("AliESDEvent");
+   if (esd_friends_file_name != 0)
+   {
+      printf("*** Opening ESD-friends ***\n");
+      esd_friends_file = TFile::Open(esd_friends_file_name, "CACHEREAD");
+      if (!esd_friends_file)
+         return;
+
+      esd_tree->SetBranchStatus ("ESDfriend*", 1);
+   }
 
    // Set the branch addresses.
    {
-      TIter next(esd->fESDObjects);
+      TIter next(esd_objs);
       TObject *el;
-      while ((el=(TNamed*)next()))
+      while ((el = (TNamed*)next()))
       {
          TString bname(el->GetName());
-         if(bname.CompareTo("AliESDfriend")==0)
+         if (bname == "AliESDfriend")
          {
-            // AliESDfriend needs some '.' magick.
-            esd_tree->SetBranchAddress("ESDfriend.", esd->fESDObjects->GetObjectRef(el));
+            // AliESDfriend needs special treatment.
+            TBranch *br = esd_tree->GetBranch("ESDfriend.");
+            br->SetAddress(esd_objs->GetObjectRef(el));
          }
          else
          {
-            esd_tree->SetBranchAddress(bname, esd->fESDObjects->GetObjectRef(el));
+            TBranch *br = esd_tree->GetBranch(bname);
+            if (br)
+            {
+               br->SetAddress(esd_objs->GetObjectRef(el));
+            }
+            else
+            {
+               br = esd_tree->GetBranch(bname + ".");
+               if (br)
+               {
+                  br->SetAddress(esd_objs->GetObjectRef(el));
+               }
+               else
+               {
+                  Warning("AliESDEvent::ReadFromTree() No Branch found with Name '%s' or '%s.'.",
+                          bname.Data(),bname.Data());
+               }
+            }
          }
       }
    }
 
+
    TEveManager::Create();
 
    { // Simple geometry
@@ -185,12 +230,107 @@ void alice_esd()
       if (!geom)
          return;
       TEveGeoShapeExtract* gse = (TEveGeoShapeExtract*) geom->Get("Gentle");
-      TEveGeoShape* gsre = TEveGeoShape::ImportShapeExtract(gse, 0);
+      gGeomGentle = TEveGeoShape::ImportShapeExtract(gse, 0);
       geom->Close();
       delete geom;
-      gEve->AddGlobalElement(gsre);
+      gEve->AddGlobalElement(gGeomGentle);
    }
 
+
+   // Scenes
+   //========
+
+   gRPhiGeomScene  = gEve->SpawnNewScene("RPhi Geometry",
+                                         "Scene holding projected geometry for the RPhi view.");
+   gRhoZGeomScene  = gEve->SpawnNewScene("RhoZ Geometry",
+                                         "Scene holding projected geometry for the RhoZ view.");
+   gRPhiEventScene = gEve->SpawnNewScene("RPhi Event Data",
+                                         "Scene holding projected geometry for the RPhi view.");
+   gRhoZEventScene = gEve->SpawnNewScene("RhoZ Event Data",
+                                         "Scene holding projected geometry for the RhoZ view.");
+
+
+   // Projection managers
+   //=====================
+
+   gRPhiMgr = new TEveProjectionManager();
+   gRPhiMgr->SetProjection(TEveProjection::kPT_RPhi);
+   gEve->AddToListTree(gRPhiMgr, kFALSE);
+   {
+      TEveProjectionAxes* a = new TEveProjectionAxes(gRPhiMgr);
+      a->SetMainColor(kWhite);
+      a->SetTitle("R-Phi");
+      a->SetTitleSize(0.05);
+      a->SetTitleFont(102);
+      a->SetLabelSize(0.025);
+      a->SetLabelFont(102);
+      gRPhiGeomScene->AddElement(a);
+   }
+   gRPhiMgr->ImportElements(gGeomGentle, gRPhiGeomScene);
+
+   gRhoZMgr = new TEveProjectionManager();
+   gRhoZMgr->SetProjection(TEveProjection::kPT_RhoZ);
+   gEve->AddToListTree(gRhoZMgr, kFALSE);
+   {
+      TEveProjectionAxes* a = new TEveProjectionAxes(gRhoZMgr);
+      a->SetMainColor(kWhite);
+      a->SetTitle("Rho-Z");
+      a->SetTitleSize(0.05);
+      a->SetTitleFont(102);
+      a->SetLabelSize(0.025);
+      a->SetLabelFont(102);
+      gRhoZGeomScene->AddElement(a);
+   }
+   gRhoZMgr->ImportElements(gGeomGentle, gRhoZGeomScene);
+
+
+   // Viewers
+   //=========
+
+   TEveWindowSlot *slot = 0;
+   TEveWindowPack *pack = 0;
+
+   slot = TEveWindow::CreateWindowInTab(gEve->GetBrowser()->GetTabRight());
+   pack = slot->MakePack();
+   pack->SetElementName("Multi View");
+   pack->SetHorizontal();
+   pack->SetShowTitleBar(kFALSE);
+   pack->NewSlot()->MakeCurrent();
+   g3DView = gEve->SpawnNewViewer("3D View", "");
+   g3DView->AddScene(gEve->GetGlobalScene());
+   g3DView->AddScene(gEve->GetEventScene());
+
+   pack = pack->NewSlot()->MakePack();
+   pack->SetShowTitleBar(kFALSE);
+   pack->NewSlot()->MakeCurrent();
+   gRPhiView = gEve->SpawnNewViewer("RPhi View", "");
+   gRPhiView->GetGLViewer()->SetCurrentCamera(TGLViewer::kCameraOrthoXOY);
+   gRPhiView->AddScene(gRPhiGeomScene);
+   gRPhiView->AddScene(gRPhiEventScene);
+
+   pack->NewSlot()->MakeCurrent();
+   gRhoZView = gEve->SpawnNewViewer("RhoZ View", "");
+   gRhoZView->GetGLViewer()->SetCurrentCamera(TGLViewer::kCameraOrthoXOY);
+   gRhoZView->AddScene(gRhoZGeomScene);
+   gRhoZView->AddScene(gRhoZEventScene);
+
+
+   // HTML summary view
+   //===================
+
+   gROOT->LoadMacro("alice_esd_html_summary.C");
+   fgHtmlSummary = new HtmlSummary("Alice Event Display Summary Table");
+   slot = TEveWindow::CreateWindowInTab(gEve->GetBrowser()->GetTabRight());
+   fgHtml = new TGHtml(0, 100, 100);
+   TEveWindowFrame *wf = slot->MakeFrame(fgHtml);
+   fgHtml->MapSubwindows();
+   wf->SetElementName("Summary");
+
+   // Final stuff
+   //=============
+
+   gEve->GetBrowser()->GetTabRight()->SetTab(1);
+
    make_gui();
 
    load_event();
@@ -199,7 +339,7 @@ void alice_esd()
 }
 
 //______________________________________________________________________________
-Bool_t alice_esd_loadlib(const char* file, const char* project)
+Bool_t alice_esd_loadlib(const char* project)
 {
    // Make sure that shared library created from the auto-generated project
    // files exists and load it.
@@ -207,9 +347,12 @@ Bool_t alice_esd_loadlib(const char* file, const char* project)
    TString lib(Form("%s/%s.%s", project, project, gSystem->GetSoExt()));
 
    if (gSystem->AccessPathName(lib, kReadPermission)) {
-      TFile* f = TFile::Open(file, "CACHEREAD");
+      TFile* f = TFile::Open(esd_file_name, "CACHEREAD");
       if (f == 0)
          return kFALSE;
+      TFile *f2 = TFile::Open(esd_friends_file_name, "CACHEREAD");
+      TTree *tree = (TTree*) f->Get("esdTree");
+      tree->SetBranchStatus ("ESDfriend*", 1);
       f->MakeProject(project, "*", "++");
       f->Close();
       delete f;
@@ -225,14 +368,31 @@ void load_event()
 
    printf("Loading event %d.\n", esd_event_id);
 
-   if (track_list)
-      track_list->DestroyElements();
+   gEve->GetViewers()->DeleteAnnotations();
+
+   if (gTrackList)
+      gTrackList->DestroyElements();
 
    esd_tree->GetEntry(esd_event_id);
-//   esd_tree->Show();
+   // esd_tree->Show();
 
    alice_esd_read();
 
+   TEveElement* top = gEve->GetCurrentEvent();
+
+   if (gRPhiMgr && top)
+   {
+      gRPhiEventScene->DestroyElements();
+      gRPhiMgr->ImportElements(top, gRPhiEventScene);
+   }
+   if (gRhoZMgr && top)
+   {
+      gRhoZEventScene->DestroyElements();
+      gRhoZMgr->ImportElements(top, gRhoZEventScene);
+   }
+
+   update_html_summary();
+
    gEve->Redraw3D(kFALSE, kTRUE);
 }
 
@@ -328,24 +488,25 @@ void alice_esd_read()
 {
    // Read tracks and associated clusters from current event.
 
-   AliESDRun    *esdrun = (AliESDRun*)    esd->fESDObjects->FindObject("AliESDRun");
-   TClonesArray *tracks = (TClonesArray*) esd->fESDObjects->FindObject("Tracks");
+   AliESDRun    *esdrun = (AliESDRun*)    esd_objs->FindObject("AliESDRun");
+   TClonesArray *tracks = (TClonesArray*) esd_objs->FindObject("Tracks");
 
    // This needs further investigation. Clusters not shown.
-    AliESDfriend *frnd   = (AliESDfriend*) esd->fESDObjects->FindObject("AliESDfriend");
-    printf("Friend %p, n_tracks:%d\n", frnd, frnd->fTracks.GetEntries());
+   // esd_friend = (AliESDfriend*) esd_objs->FindObject("AliESDfriend");
+   // printf("Friend %p, n_tracks:%d\n", esd_friend, esd_friend->fTracks.GetEntries());
 
-   if (track_list == 0) {
-      track_list = new TEveTrackList("ESD Tracks"); 
-      track_list->SetMainColor(6);
-      track_list->SetMarkerColor(kYellow);
-      track_list->SetMarkerStyle(4);
-      track_list->SetMarkerSize(0.5);
+   if (gTrackList == 0)
+   {
+      gTrackList = new TEveTrackList("ESD Tracks"); 
+      gTrackList->SetMainColor(6);
+      gTrackList->SetMarkerColor(kYellow);
+      gTrackList->SetMarkerStyle(4);
+      gTrackList->SetMarkerSize(0.5);
 
-      gEve->AddElement(track_list);
+      gEve->AddElement(gTrackList);
    }
 
-   TEveTrackPropagator* trkProp = track_list->GetPropagator();
+   TEveTrackPropagator* trkProp = gTrackList->GetPropagator();
    trkProp->SetMagField( 0.1 * esdrun->fMagneticField ); // kGaus to Tesla
 
    for (Int_t n=0; n<tracks->GetEntriesFast(); ++n)
@@ -359,8 +520,8 @@ void alice_esd_read()
       }
 
       TEveTrack* track = esd_make_track(trkProp, n, at, tp);
-      track->SetAttLineAttMarker(track_list);
-      gEve->AddElement(track, track_list);
+      track->SetAttLineAttMarker(gTrackList);
+      gEve->AddElement(track, gTrackList);
 
       // This needs further investigation. Clusters not shown.
       // if (frnd)
@@ -370,7 +531,7 @@ void alice_esd_read()
       // }
    }
 
-   track_list->MakeTracks();
+   gTrackList->MakeTracks();
 }
 
 //______________________________________________________________________________
diff --git a/tutorials/eve/alice_esd_html_summary.C b/tutorials/eve/alice_esd_html_summary.C
new file mode 100644
index 0000000..bd52ac8
--- /dev/null
+++ b/tutorials/eve/alice_esd_html_summary.C
@@ -0,0 +1,333 @@
+// @(#)root/eve:$Id: root-5.22-00d-fireworks-graf3d-gui.patch,v 1.5 2010/10/09 09:42:53 eulisse Exp $
+
+// Html table and event summary for alice_esd.C
+
+//==============================================================================
+
+class HtmlObjTable : public TObject
+{
+public:                     // make them public for shorter code
+
+   TString   fName;
+   Int_t     fNValues;      // number of values
+   Int_t     fNFields;      // number of fields
+   TArrayF  *fValues;
+   TString  *fLabels;
+   Bool_t    fExpand;
+
+   TString   fHtml;         // HTML output code
+
+   void Build();
+   void BuildTitle();
+   void BuildLabels();
+   void BuildTable();
+
+public:
+   HtmlObjTable(const char *name, Int_t nfields, Int_t nvals, Bool_t exp=kTRUE);
+   virtual ~HtmlObjTable();
+
+   void     SetLabel(Int_t col, const char *label) { fLabels[col] = label; }
+   void     SetValue(Int_t col, Int_t row, Float_t val) { fValues[col].SetAt(val, row); }
+   TString  Html() const { return fHtml; }
+
+   ClassDef(HtmlObjTable, 0);
+};
+
+//==============================================================================
+
+class HtmlSummary
+{
+public:                           // make them public for shorter code
+   Int_t           fNTables;
+   TOrdCollection *fObjTables;    // ->array of object tables
+   TString         fHtml;         // output HTML string
+   TString         fTitle;        // page title
+   TString         fHeader;       // HTML header
+   TString         fFooter;       // HTML footer
+
+   void     MakeHeader();
+   void     MakeFooter();
+
+public:
+   HtmlSummary(const char *title);
+   virtual ~HtmlSummary();
+
+   HtmlObjTable  *AddTable(const char *name, Int_t nfields, Int_t nvals, 
+                           Bool_t exp=kTRUE, Option_t *opt="");
+   HtmlObjTable  *GetTable(Int_t at) const { return (HtmlObjTable *)fObjTables->At(at); }
+   void           Build();
+   void           Clear(Option_t *option="");
+   void           Reset(Option_t *option="");
+   TString        Html() const { return fHtml; }
+
+   ClassDef(HtmlSummary, 0);
+};
+
+//==============================================================================
+
+HtmlSummary *fgHtmlSummary = 0;
+TGHtml      *fgHtml        = 0;
+
+//==============================================================================
+
+//______________________________________________________________________________
+HtmlObjTable::HtmlObjTable(const char *name, Int_t nfields, Int_t nvals, Bool_t exp) : 
+   fName(name), fNValues(nvals), fNFields(nfields), fExpand(exp)
+{
+   // Constructor.
+
+   fValues = new TArrayF[fNFields];
+   for (int i=0;i<fNFields;i++)
+      fValues[i].Set(nvals);
+   fLabels = new TString[fNFields];
+}
+
+//______________________________________________________________________________
+HtmlObjTable::~HtmlObjTable()
+{
+   // Destructor.
+
+   delete [] fValues;
+   delete [] fLabels;
+}
+
+//______________________________________________________________________________
+void HtmlObjTable::Build()
+{
+   // Build HTML code.
+
+   fHtml = "<table width=100% border=1 cellspacing=0 cellpadding=0 bgcolor=f0f0f0> ",
+
+   BuildTitle();
+   if (fExpand && (fNFields > 0) && (fNValues > 0)) {
+      BuildLabels();
+      BuildTable();
+   }
+
+   fHtml += "</table>";
+}
+
+//______________________________________________________________________________
+void HtmlObjTable::BuildTitle()
+{
+   // Build table title.
+   
+   fHtml += "<tr><td colspan=";
+   fHtml += Form("%d>", fNFields+1);
+   fHtml += "<table width=100% border=0 cellspacing=2 cellpadding=0 bgcolor=6e6ea0>";
+   fHtml += "<tr><td align=left>";
+   fHtml += "<font face=Verdana size=3 color=ffffff><b><i>";
+   fHtml += fName;
+   fHtml += "</i></b></font></td>";
+   fHtml += "<td>";
+   fHtml += "<td align=right> ";
+   fHtml += "<font face=Verdana size=3 color=ffffff><b><i>";
+   fHtml += Form("Size = %d", fNValues);
+   fHtml += "</i></b></font></td></tr>";
+   fHtml += "</table>";
+   fHtml += "</td></tr>";
+}
+
+//______________________________________________________________________________
+void HtmlObjTable::BuildLabels()
+{
+   // Build table labels.
+
+   Int_t i;
+   fHtml += "<tr bgcolor=c0c0ff>";
+   fHtml += "<th> </th>"; // for the check boxes
+   for (i=0;i<fNFields;i++) {
+      fHtml += "<th> ";
+      fHtml += fLabels[i];
+      fHtml += " </th>"; // for the check boxes
+   }
+   fHtml += "</tr>";
+}
+
+//______________________________________________________________________________
+void HtmlObjTable::BuildTable()
+{
+   // Build part of table with values.
+
+   for (int i = 0; i < fNValues; i++) {
+      if (i%2)
+         fHtml += "<tr bgcolor=e0e0ff>";
+      else
+         fHtml += "<tr bgcolor=ffffff>";
+      
+      TString name = fName;
+      name.ReplaceAll(" ", "_");
+      // checkboxes
+      fHtml += "<td bgcolor=d0d0ff align=\"center\">";
+      fHtml += "<input type=\"checkbox\" name=\"";
+      fHtml += name;
+      fHtml += Form("[%d]\">",i);
+      fHtml += "</td>";
+
+      for (int j = 0; j < fNFields; j++) {
+         fHtml += "<td width=";
+         fHtml += Form("%d%%", 100/fNFields);
+         fHtml += " align=\"center\"";
+         fHtml += ">";
+         fHtml += Form("%1.4f", fValues[j][i]);
+         fHtml += "</td>";
+      }
+      fHtml += "</tr> ";
+   }
+}
+
+//______________________________________________________________________________
+HtmlSummary::HtmlSummary(const char *title) : fNTables(0), fTitle(title)
+{
+   // Constructor.
+
+   fObjTables = new TOrdCollection();
+}
+
+//______________________________________________________________________________
+HtmlSummary::~HtmlSummary()
+{
+   // Destructor.
+
+   Reset();
+}
+
+//______________________________________________________________________________
+HtmlObjTable *HtmlSummary::AddTable(const char *name, Int_t nfields, Int_t nvals,
+                                    Bool_t exp, Option_t *option)
+{
+   // Add a new table in our list of tables.
+
+   TString opt = option;
+   opt.ToLower();
+   HtmlObjTable *table = new HtmlObjTable(name, nfields, nvals, exp);
+   fNTables++;
+   if (opt.Contains("first"))
+      fObjTables->AddFirst(table);
+   else
+      fObjTables->Add(table);
+   return table;
+}
+
+//______________________________________________________________________________
+void HtmlSummary::Clear(Option_t *option)
+{
+   // Clear the table list.
+
+   if (option && option[0] == 'D')
+      fObjTables->Delete(option);
+   else
+      fObjTables->Clear(option);
+   fNTables = 0;
+}
+
+//______________________________________________________________________________
+void HtmlSummary::Reset(Option_t *)
+{
+   // Reset (delete) the table list;
+
+   delete fObjTables; fObjTables = 0;
+   fNTables = 0;
+}
+
+//______________________________________________________________________________
+void HtmlSummary::Build()
+{
+   // Build the summary.
+
+   MakeHeader();
+   for (int i=0;i<fNTables;i++) {
+      GetTable(i)->Build();
+      fHtml += GetTable(i)->Html();
+   }
+   MakeFooter();
+}
+
+//______________________________________________________________________________
+void HtmlSummary::MakeHeader()
+{
+   // Make HTML header.
+
+   fHeader  = "<html><head><title>";
+   fHeader += fTitle;
+   fHeader += "</title></head><body>";
+   fHeader += "<center><h2><font color=#2222ee><i>";
+   fHeader += fTitle;
+   fHeader += "</i></font></h2></center>";
+   fHtml    = fHeader;
+}
+
+//______________________________________________________________________________
+void HtmlSummary::MakeFooter()
+{
+   // Make HTML footer.
+
+   fFooter  = "<br><p><br><center><strong><font size=2 color=#2222ee>";
+   fFooter += "Example of using Html widget to display tabular data";
+   fFooter += "<br>";
+   fFooter += " 2007-2008 Bertrand Bellenot";
+   fFooter += "</font></strong></center></body></html>";  
+   fHtml   += fFooter;
+}
+
+//==============================================================================
+
+//______________________________________________________________________________
+void update_html_summary()
+{
+   // Update summary of current event.
+
+   TEveElement::List_i i;
+   TEveElement::List_i j;
+   Int_t k;
+   TEveElement *el;
+   HtmlObjTable *table;
+   TEveEventManager *mgr = gEve ? gEve->GetCurrentEvent() : 0;
+   if (mgr) {
+      fgHtmlSummary->Clear("D");
+      for (i=mgr->BeginChildren(); i!=mgr->EndChildren(); ++i) {
+         el = ((TEveElement*)(*i));
+         if (el->IsA() == TEvePointSet::Class()) {
+            TEvePointSet *ps = (TEvePointSet *)el;
+            TString ename  = ps->GetElementName();
+            TString etitle = ps->GetElementTitle();
+            if (ename.First('\'') != kNPOS)
+               ename.Remove(ename.First('\''));
+            etitle.Remove(0, 2);
+            Int_t nel = atoi(etitle.Data());
+            table = fgHtmlSummary->AddTable(ename, 0, nel);
+         }
+         else if (el->IsA() == TEveTrackList::Class()) {
+            TEveTrackList *tracks = (TEveTrackList *)el;
+            TString ename  = tracks->GetElementName();
+            if (ename.First('\'') != kNPOS)
+               ename.Remove(ename.First('\''));
+            table = fgHtmlSummary->AddTable(ename.Data(), 5, 
+                     tracks->NumChildren(), kTRUE, "first");
+            table->SetLabel(0, "Momentum");
+            table->SetLabel(1, "P_t");
+            table->SetLabel(2, "Phi");
+            table->SetLabel(3, "Theta");
+            table->SetLabel(4, "Eta");
+            k=0;
+            for (j=tracks->BeginChildren(); j!=tracks->EndChildren(); ++j) {
+               Float_t p     = ((TEveTrack*)(*j))->GetMomentum().Mag();
+               table->SetValue(0, k, p);
+               Float_t pt    = ((TEveTrack*)(*j))->GetMomentum().Perp();
+               table->SetValue(1, k, pt);
+               Float_t phi   = ((TEveTrack*)(*j))->GetMomentum().Phi();
+               table->SetValue(2, k, phi);
+               Float_t theta = ((TEveTrack*)(*j))->GetMomentum().Theta();
+               table->SetValue(3, k, theta);
+               Float_t eta   = ((TEveTrack*)(*j))->GetMomentum().Eta();
+               table->SetValue(4, k, eta);
+               ++k;
+            }
+         }
+      }
+      fgHtmlSummary->Build();
+      fgHtml->Clear();
+      fgHtml->ParseText((char*)fgHtmlSummary->Html().Data());
+      fgHtml->Layout();
+   }
+}
diff --git a/tutorials/eve/arrow.C b/tutorials/eve/arrow.C
index 562207f..e8aa5b9 100644
--- a/tutorials/eve/arrow.C
+++ b/tutorials/eve/arrow.C
@@ -27,6 +27,7 @@ void arrow()
    TEveArrow* a1 = new TEveArrow(1., 1., 10., 10., 4., 0.);
    a1->SetMainColor(kBlue);
    a1->SetTubeR(0.02);
+   a1->SetPickable(kTRUE);
    gEve->AddElement(a1);
    TEveText* t1 = new TEveText("blue");
    t1->SetFontSize(20);
@@ -36,10 +37,12 @@ void arrow()
 
    TEveArrow* a2 = new TEveArrow(20., 1., 10., 3., 0., 4.);
    a2->SetMainColor(kGreen);
+   a2->SetPickable(kTRUE);
    gEve->AddElement(a2);
 
    TEveArrow* a3 = new TEveArrow(1., 10., 10., 0., 20., 0.);
    a3->SetMainColor(kOrange);
+   a3->SetPickable(kTRUE);
    gEve->AddElement(a3);
 
    gEve->FullRedraw3D(kTRUE);
diff --git a/tutorials/eve/cms_calo.C b/tutorials/eve/cms_calo.C
index 0bae5e3..50d28e9 100644
--- a/tutorials/eve/cms_calo.C
+++ b/tutorials/eve/cms_calo.C
@@ -114,17 +114,14 @@ void MakeCaloLego(TEveCaloData* data)
    Float_t sc = TMath::TwoPi();
    lego->RefMainTrans().SetScale(sc, sc, sc);
    // overlay lego1
-   TEveLegoOverlay* overlay = new TEveLegoOverlay();
+   TEveCaloLegoOverlay* overlay = new TEveCaloLegoOverlay();
    overlay->SetShowPlane(kTRUE);
 
    overlay->SetHeaderTxt(Form("Max Et %3.1f", data->GetMaxVal(kTRUE)));
-   overlay->RefAxisAttrib().SetLabelSize(0.02);
+   overlay->GetAttAxis()->SetLabelSize(0.02);
    v->AddOverlayElement(overlay);
    overlay->SetCaloLego(lego);
    gEve->AddElement(overlay, s2);
-
-
-
 }
 
 //______________________________________________________________________________
diff --git a/tutorials/eve/cms_calo_detail.C b/tutorials/eve/cms_calo_detail.C
index cea748f..7b011e0 100644
--- a/tutorials/eve/cms_calo_detail.C
+++ b/tutorials/eve/cms_calo_detail.C
@@ -13,11 +13,14 @@
 #else
 
 #include <TEveManager.h>
+#include <TEveTrans.h>
 #include <TEveCalo.h>
 #include <TEveCaloData.h>
-#include <TEveLegoOverlay.h>
+#include <TEveCaloLegoOverlay.h>
 #include <TEveLegoEventHandler.h>
 
+#include <TEveStraightLineSet.h>
+
 #include <TGLViewer.h>
 #include <TGLOverlayButton.h>
 
@@ -92,71 +95,78 @@ public:
 
 void cms_calo_detail()
 {
-  TEveManager::Create();
-
-  TGLViewer* v = gEve->GetDefaultGLViewer(); // Default
-  v->SetCurrentCamera(TGLViewer::kCameraPerspXOY);
-  v->SetEventHandler(new TEveLegoEventHandler("Lego", (TGWindow*)v->GetGLWidget(), (TObject*)v));
-
-  // data
-
-  TEveCaloDataVec* data = new TEveCaloDataVec(2);
-
-  data->RefSliceInfo(0).Setup("ECAL", 0.3, kRed);
-  data->RefSliceInfo(1).Setup("HCAL", 0.1, kYellow);
-
-  data->AddTower(0.12, 0.14, 0.45, 0.47);
-  data->FillSlice(0, 12);
-  data->FillSlice(1, 3);
-
-  data->AddTower(0.125, 0.145, 0.43, 0.45);
-  data->FillSlice(0, 4);
-  data->FillSlice(1, 7);
-
-  data->AddTower(0.10, 0.12, 0.45, 0.47);
-  data->FillSlice(0, 6);
-  data->FillSlice(1, 0);
-
-  data->SetAxisFromBins();
-  // set eta, phi axis title with symbol.ttf font
-  data->GetEtaBins()->SetTitle("X[cm]");
-  data->GetEtaBins()->SetTitleSize(0.1);
-  data->GetPhiBins()->SetTitle("Y[cm]");
-  data->GetPhiBins()->SetTitleColor(kGreen);
-  data->DataChanged();
-
-  // add offset
-  Double_t etaMin, etaMax;
-  Double_t phiMin, phiMax;
-  data->GetEtaLimits(etaMin, etaMax);
-  data->GetPhiLimits(phiMin, phiMax);
-  Float_t offe = 0.1*(etaMax -etaMin);
-  Float_t offp = 0.1*(etaMax -etaMin);
-  data->AddTower(etaMin -offe, etaMax +offe, phiMin -offp , phiMax +offp);
-
-
-  // lego
-  TEveCaloLego* lego = new TEveCaloLego(data);
-  lego->SetAutoRebin(kFALSE);
-  lego->SetPlaneColor(kBlue-5);
-  lego->SetFontColor(kGray);
-  lego->Set2DMode(TEveCaloLego::kValSize);
-  lego->SetName("Calo Detail");
-  gEve->AddElement(lego);
-
-  // overlay lego
-
-  TEveLegoOverlay* overlay = new TEveLegoOverlay();
-  overlay->SetCaloLego(lego);
-  v->AddOverlayElement(overlay);
-  gEve->AddElement(overlay);
-
-  // overlay legend
-
-  ButtFaker* legend = new ButtFaker(v);
-  v->AddOverlayElement(legend);
-
-  gEve->Redraw3D(kTRUE);
+   TEveManager::Create();
+
+   TGLViewer* v = gEve->GetDefaultGLViewer(); // Default
+   v->SetCurrentCamera(TGLViewer::kCameraPerspXOY);
+   v->SetEventHandler(new TEveLegoEventHandler("Lego", (TGWindow*)v->GetGLWidget(), (TObject*)v));
+
+   // data
+
+   TEveCaloDataVec* data = new TEveCaloDataVec(2);
+
+   data->RefSliceInfo(0).Setup("ECAL", 0.3, kRed);
+   data->RefSliceInfo(1).Setup("HCAL", 0.1, kYellow);
+
+   data->AddTower(0.12, 0.14, 0.45, 0.47);
+   data->FillSlice(0, 12);
+   data->FillSlice(1, 3);
+
+   data->AddTower(0.125, 0.145, 0.43, 0.45);
+   data->FillSlice(0, 4);
+   data->FillSlice(1, 7);
+
+   data->AddTower(0.10, 0.12, 0.45, 0.47);
+   data->FillSlice(0, 6);
+   data->FillSlice(1, 0);
+
+   data->SetAxisFromBins();
+   // set eta, phi axis title with symbol.ttf font
+   data->GetEtaBins()->SetTitle("X[cm]");
+   data->GetEtaBins()->SetTitleSize(0.1);
+   data->GetPhiBins()->SetTitle("Y[cm]");
+   data->GetPhiBins()->SetTitleColor(kGreen);
+   data->DataChanged();
+
+   // lego
+   TEveCaloLego* lego = new TEveCaloLego(data);
+   // move to real-world coordinates
+   Double_t em, eM, pm, pM;
+   data->GetEtaLimits(em, eM);
+   data->GetPhiLimits(pm, pM);
+   lego->SetEta(em, eM);
+   lego->SetPhiWithRng((pm+pM)*0.5, pM-pm);
+   Double_t sc = ((eM - em) < (pM - pm)) ? (eM - em) : (pM - pm);
+   lego->InitMainTrans();
+   lego->RefMainTrans().SetScale(sc, sc, sc);
+   lego->RefMainTrans().SetPos((eM+em)*0.5, (pM+pm)*0.5, 0);
+
+   lego->SetAutoRebin(kFALSE);
+   lego->SetPlaneColor(kBlue-5);
+   lego->SetFontColor(kGray);
+   lego->Set2DMode(TEveCaloLego::kValSize);
+   lego->SetName("Calo Detail");
+   gEve->AddElement(lego);
+
+   // add line to test real world coordinates
+   TEveStraightLineSet* ls = new TEveStraightLineSet();
+   ls->AddLine( em, pm, 0,  eM, pM, 0);
+   ls->SetLineColor(kBlue);
+   gEve->AddElement(ls);
+
+
+   // overlay lego
+   TEveCaloLegoOverlay* overlay = new TEveCaloLegoOverlay();
+   overlay->SetCaloLego(lego);
+   v->AddOverlayElement(overlay);
+   gEve->AddElement(overlay);
+
+   // overlay legend
+
+   ButtFaker* legend = new ButtFaker(v);
+   v->AddOverlayElement(legend);
+
+   gEve->Redraw3D(kTRUE);
 }
 
 #endif
diff --git a/tutorials/eve/geom_alias.C b/tutorials/eve/geom_alias.C
index faa20c9..dcd3f17 100644
--- a/tutorials/eve/geom_alias.C
+++ b/tutorials/eve/geom_alias.C
@@ -32,4 +32,7 @@ void geom_alias()
    TGLViewer *v = gEve->GetDefaultGLViewer();
    v->GetClipSet()->SetClipType(2);
    v->RefreshPadEditor(v);
+
+   v->CurrentCamera().RotateRad(-0.5, -2.4);
+   v->DoDraw();
 }
diff --git a/tutorials/eve/geom_atlas.C b/tutorials/eve/geom_atlas.C
index 5496899..d615378 100644
--- a/tutorials/eve/geom_atlas.C
+++ b/tutorials/eve/geom_atlas.C
@@ -28,4 +28,7 @@ void geom_atlas()
    TGLViewer *v = gEve->GetDefaultGLViewer();
    v->GetClipSet()->SetClipType(1);
    v->RefreshPadEditor(v);
+
+   v->CurrentCamera().RotateRad(-.7, 0.5);
+   v->DoDraw();
 }
diff --git a/tutorials/eve/geom_cms.C b/tutorials/eve/geom_cms.C
index fe83e43..e3e4fd5 100644
--- a/tutorials/eve/geom_cms.C
+++ b/tutorials/eve/geom_cms.C
@@ -30,7 +30,10 @@ void geom_cms()
    // 0 - no clip, 1 - clip plane, 2 - clip box
    TGLViewer *v = gEve->GetDefaultGLViewer();
    v->GetClipSet()->SetClipType(1);
-   v->SetClearColor(kBlue-10);
+   v->SetClearColor(kMagenta+4);
    v->SetGuideState(TGLUtil::kAxesEdge, kTRUE, kFALSE, 0);
    v->RefreshPadEditor(v);
+
+   v->CurrentCamera().RotateRad(-1.2, 0.5);
+   v->DoDraw();
 }
diff --git a/tutorials/eve/jetcone_test.C b/tutorials/eve/jetcone_test.C
new file mode 100644
index 0000000..0e83660
--- /dev/null
+++ b/tutorials/eve/jetcone_test.C
@@ -0,0 +1,165 @@
+// Demonstrates usage of TEveJetCone class.
+// Author: Jochen Thaeder
+
+const char* esd_geom_file_name = "http://root.cern.ch/files/alice_ESDgeometry.root";
+
+void jetcone_test()
+{
+   TEveManager::Create();
+
+   using namespace TMath;
+
+   TRandom r(0);
+
+   // -- Set Constants
+   Int_t nCones  = 10;
+   Int_t nTracks = 200;
+
+   Float_t coneRadius = 0.4;
+   Float_t length = 300.;
+
+   // -- Define palette
+   gStyle->SetPalette(1, 0);
+   TEveRGBAPalette* pal = new TEveRGBAPalette(0, 500);
+
+   // -----------------------------------------------------------------------------------
+   // -- Line sets
+   // -----------------------------------------------------------------------------------
+
+   // -- Define cone center
+   TEveStraightLineSet* axis = new TEveStraightLineSet("Cone Axis");
+   axis->SetLineColor(kGreen);
+   axis->SetLineWidth(2);
+
+   TEveStraightLineSet* tracksXYZ = new TEveStraightLineSet("StraightLinesXYZ");
+   tracksXYZ->SetLineColor(kRed);
+   tracksXYZ->SetLineWidth(2);
+
+   TEveStraightLineSet* tracksEtaPhi = new TEveStraightLineSet("StraightLinesEtaPhi");
+   tracksEtaPhi->SetLineColor(kYellow);
+   tracksEtaPhi->SetLineWidth(2);
+
+   TEveStraightLineSet* tracksSeedEtaPhi = new TEveStraightLineSet("StraightLinesEtaPhiSeed");
+   tracksSeedEtaPhi->SetLineColor(kBlue);
+   tracksSeedEtaPhi->SetLineWidth(2);
+
+   // -----------------------------------------------------------------------------------
+   // -- Draw track distribution in XYZ ( in TPC Volume ) ( +/-250, +/-250, +/-250 )
+   // -----------------------------------------------------------------------------------
+
+   for ( Int_t track=0; track < nTracks ; track++ ) {
+
+      Float_t trackX = r.Uniform(-250.0, 250.0);
+      Float_t trackY = r.Uniform(-250.0, 250.0);
+      Float_t trackZ = r.Uniform(-250.0, 250.0);
+      Float_t trackR = (Float_t) Sqrt ( trackX*trackX + trackY*trackY + trackZ*trackZ );
+
+      /*
+        Float_t trackEta =  0.5 * (Float_t) Log( (Double_t)(( trackR+trackZ )/( trackR-trackZ )) );
+        Float_t trackPhi = (Float_t) ATan2( (Double_t) trackY, (Double_t) trackX );
+        if ( trackPhi < 0. ) trackPhi += (Float_t) TwoPi();
+      */
+
+      TEveVector trackDir(trackX/trackR, trackY/trackR ,trackZ/trackR);
+      TEveVector trackEnd = trackDir * length;
+      tracksXYZ->AddLine(0., 0., 0., trackEnd.fX, trackEnd.fY, trackEnd.fZ );
+   }
+
+   // -----------------------------------------------------------------------------------
+   // -- Draw track distribution in eta phi ( in TPC Volume ) ( +/-0.9, {0, 2Pi} )
+   // -----------------------------------------------------------------------------------
+
+   for ( Int_t track=0; track < nTracks ; track++ ) {
+
+      Float_t trackEta = r.Uniform(-0.9, 0.9);
+      Float_t trackPhi = r.Uniform(0.0, TwoPi());
+
+      TEveVector trackDir( GetTEveVector(trackEta, trackPhi) );
+      TEveVector trackEnd = trackDir * length;
+
+      if ( trackEta > coneRadius || trackEta < -coneRadius )
+         tracksEtaPhi->AddLine(0., 0., 0., trackEnd.fX, trackEnd.fY, trackEnd.fZ );
+      else
+         tracksSeedEtaPhi->AddLine(0., 0., 0., trackEnd.fX, trackEnd.fY, trackEnd.fZ );
+   }
+
+   // -----------------------------------------------------------------------------------
+   // -- Draw cones
+   // -----------------------------------------------------------------------------------
+
+   for ( Int_t iter = 0; iter < nCones; ++iter ) {
+
+      // -- Get Random ( eta ,phi )
+      Float_t coneEta = r.Uniform(-0.9, 0.9);
+      Float_t conePhi = r.Uniform(0.0, TwoPi() );
+
+      // -- Primary vertx as origin
+      TEveVector coneOrigin(0.0,0.0,0.0);
+
+      // -- Get Cone Axis - axis line 10% longer than cone height
+      TEveVector coneAxis ( GetTEveVector( coneEta, conePhi) );
+      coneAxis *= length * 1.1;
+
+      axis->AddLine( 0., 0., 0., coneAxis.fX, coneAxis.fY, coneAxis.fZ );
+
+      // -- Draw jet cone
+      TEveJetCone* jetCone = new TEveJetCone("JetCone");
+      jetCone->SetCylinder( 250., 250. );
+      if ( (jetCone->AddCone( coneEta, conePhi, coneRadius   ) ) != -1)
+         gEve->AddElement( jetCone );
+   }
+
+   // -----------------------------------------------------------------------------------
+
+   // -- Add cone axis
+   gEve->AddElement(axis);
+
+   // -- Add lines
+   //  gEve->AddElement(tracksXYZ);
+   gEve->AddElement(tracksSeedEtaPhi);
+   gEve->AddElement(tracksEtaPhi);
+
+   // -- Load TPC geometry
+   geomGentleTPC();
+
+   gEve->Redraw3D(kTRUE);
+
+   return;
+}
+
+// ################################################################################
+// ################################################################################
+
+// ################################################################################
+TEveVector GetTEveVector( Float_t& eta, Float_t& phi )
+{
+  TEveVector vec( (Float_t) Cos ( (Double_t) phi)/ CosH( (Double_t) eta ),
+		  (Float_t) Sin ( (Double_t) phi)/ CosH( (Double_t) eta ),
+		  (Float_t) TanH( (Double_t) eta ) );
+  return vec;
+}
+
+// ################################################################################
+void geomGentleTPC()
+{
+   // Simple geometry
+   TFile* geom = TFile::Open(esd_geom_file_name, "CACHEREAD");
+   if (!geom)
+      return;
+
+   TEveGeoShapeExtract* gse = (TEveGeoShapeExtract*) geom->Get("Gentle");
+   TEveGeoShape* gsre = TEveGeoShape::ImportShapeExtract(gse, 0);
+   geom->Close();
+   delete geom;
+
+   gEve->AddGlobalElement(gsre);
+
+   TEveElement* elTRD = gsre->FindChild("TRD+TOF");
+   elTRD->SetRnrState(kFALSE);
+
+   TEveElement* elPHOS = gsre->FindChild("PHOS");
+   elPHOS->SetRnrState(kFALSE);
+
+   TEveElement* elHMPID = gsre->FindChild("HMPID");
+   elHMPID->SetRnrState(kFALSE);
+}
diff --git a/tutorials/eve/track.C b/tutorials/eve/track.C
index 7859e86..251e798 100644
--- a/tutorials/eve/track.C
+++ b/tutorials/eve/track.C
@@ -3,55 +3,31 @@
 
 // Makes some tracks with three different magnetic field types.
 
-void track(Int_t bCase = 2)
+#include "TEveTrackPropagator.h"
+#include "TEveTrack.h"
+#include "TEveManager.h"
+#include "TEveViewer.h"
+#include "TSystem.h"
+#include "TGLViewer.h"
+#include "TMath.h"
+
+#include "TEveViewer.h"
+#include "TEvePointSet.h"
+
+class GappedField : public TEveMagField
 {
-  gSystem->IgnoreSignal(kSigSegmentationViolation, true);
-  TEveManager::Create();
-
-  TEveTrackPropagator* prop = new TEveTrackPropagator();
-  prop->SetRnrDaughters(kTRUE);
-  gEve->AddElement(prop);
-
-  TEveTrack *track = 0;
-  switch (bCase)
-  {
-    case 0:
-    {
-      // B = 0 no difference btween signed and charge particles
-      prop->SetMagField(0.);
-      prop->SetName("ZeroB");
-      track = make_track(prop, 0);
-      track = make_track(prop, 1);
-      break;
-    }
-
-    case 1:
-    {
-      // constant B field, const angle
-      prop->SetMagFieldObj(new TEveMagFieldConst(0., 0., -3.8));
-      prop->SetName("ConstB");
-      prop->SetMaxR(123);
-      prop->SetMaxZ(300);
-      track = make_track(prop, 0);
-      track = make_track(prop, -1);
-      break;
-    }
-    case 2:
-    {
-      // variable B field, sign change at  R = 200 cm
-      prop->SetMagFieldObj(new TEveMagFieldDuo(200, -4.4, 2));
-      prop->SetName("DuoB");
-      prop->SetMaxR(600);
-      prop->SetMaxZ(700);
-      prop->SetMinAng(1.f);
-      track = make_track(prop, 0);
-      track = make_track(prop, -1);
-      break;
-    }
-  };
-  //  make_projected(track);
-  gEve->Redraw3D(1);
-}
+public:
+   GappedField():TEveMagField(){}
+   ~GappedField(){};
+   using   TEveMagField::GetField;
+
+   virtual TEveVector GetField(Float_t /*x*/, Float_t /*y*/, Float_t z) const
+   {
+      if (TMath::Abs(z) < 300) return TEveVector(0, 0, -4);
+      if (TMath::Abs(z) < 600) return TEveVector(0, 0, 0);
+      return TEveVector(0, 0, 4);
+   }
+};
 
 //______________________________________________________________________________
 TEveTrack* make_track(TEveTrackPropagator* prop, Int_t sign)
@@ -63,9 +39,10 @@ TEveTrack* make_track(TEveTrackPropagator* prop, Int_t sign)
   rc->fV.Set(0.028558, -0.000918, 3.691919);
   rc->fP.Set(0.767095, -2.400006, -0.313103);
   rc->fSign = sign;
+
+
   TEveTrack* track = new TEveTrack(rc, prop);
   track->SetName(Form("Charge %d", sign));
-
   // daughter 0
   TEvePathMark* pm1 = new TEvePathMark(TEvePathMark::kDaughter);
   pm1->fV.Set(1.479084, -4.370661, 3.119761);
@@ -75,38 +52,97 @@ TEveTrack* make_track(TEveTrackPropagator* prop, Int_t sign)
   pm2->fV.Set(57.72345, -89.77011, -9.783746);
   track->AddPathMark(*pm2);
 
-  // color by sign
-  if (sign)
-  {
-    track->SetLineColor(kRed-3);
-    track->SetLineWidth(2);
-  }
-  else
-  {
-    track->SetLineColor(kOrange);
-  }
-
-  track->MakeTrack();
-  gEve->AddElement(track, prop);
-
   return track;
 }
 
-//______________________________________________________________________________
-void make_projected(TEveTrack *track)
+
+void track(Int_t bCase = 3, Bool_t isRungeKutta = kTRUE)
 {
-   // Make non-linear projected view.
-
-  TEveViewer* v1 = gEve->SpawnNewViewer("2D Viewer");
-  TEveScene*  s1 = gEve->SpawnNewScene("Projected Event");
-  v1->AddScene(s1);
-  TGLViewer* v = v1->GetGLViewer();
-  v->SetCurrentCamera(TGLViewer::kCameraOrthoXOY);
-  v->SetGuideState(TGLUtil::kAxesOrigin, kTRUE, kFALSE, 0);
-
-  TEveProjectionManager* mng = new TEveProjectionManager();
-  mng->SetProjection(TEveProjection::kPT_RhoZ);
-  gEve->AddElement(mng, s1);
-  gEve->AddToListTree(mng, kTRUE);
-  mng->ImportElements(track);
+#if defined (__CINT__)
+   Error("track.C", "Must be run in compiled mode!");
+   return;
+#endif
+
+   gSystem->IgnoreSignal(kSigSegmentationViolation, true);
+   TEveManager::Create();
+
+   TEveTrackList *list = new TEveTrackList();
+   TEveTrackPropagator* prop = list->GetPropagator();
+   prop->SetFitDaughters(kFALSE);
+   prop->SetMaxZ(1000);
+
+   if (isRungeKutta)
+   {
+      prop->SetStepper(TEveTrackPropagator::kRungeKutta);
+      list->SetName("RK Propagator");
+   }
+   else
+   {
+      list->SetName("Heix Propagator");
+   }
+
+   TEveTrack *track = 0;
+   switch (bCase)
+   {
+      case 0:
+      {
+         // B = 0 no difference btween signed and charge particles
+         prop->SetMagField(0.);
+         list->SetElementName(Form("%s, zeroB", list->GetElementName()));
+         track = make_track(prop, 1);
+         break;
+      }
+
+      case 1:
+      {
+         // constant B field, const angle
+         prop->SetMagFieldObj(new TEveMagFieldConst(0., 0., -3.8));
+         list->SetElementName(Form("%s, constB", list->GetElementName()));
+         track = make_track(prop, 1);
+         break;
+      }
+      case 2:
+      {
+         // variable B field, sign change at  R = 200 cm
+         prop->SetMagFieldObj(new TEveMagFieldDuo(200, -4.4, 2));
+         list->SetElementName(Form("%s, duoB", list->GetElementName()));
+         track = make_track(prop, 1);
+         break;
+      }
+      case 3:
+      {
+         // gapped field
+         prop->SetMagFieldObj(new GappedField());
+         list->SetElementName(Form("%s, gappedB", list->GetElementName()));
+
+      
+         TEveRecTrack *rc = new TEveRecTrack();
+         rc->fV.Set(0.028558, -0.000918, 3.691919);
+         rc->fP.Set(0.767095, -0.400006, 2.313103);
+         rc->fSign = 1;
+         track = new TEveTrack(rc, prop);
+
+         TEvePointSet* marker = new TEvePointSet(2);  
+         marker->SetElementName("B field break points");
+         marker->SetPoint(0, 0., 0., 300.f);
+         marker->SetPoint(1, 0., 0., 600.f);
+         marker->SetMarkerColor(3);
+         gEve->AddElement(marker);
+      }
+   };
+       
+   if (isRungeKutta)
+      list->SetLineColor(kMagenta);
+   else 
+      list->SetLineColor(kCyan);
+
+   track->SetLineColor(list->GetLineColor());
+ 
+   gEve->AddElement(track, list);
+   gEve->AddElement(list);
+   track->MakeTrack();
+
+   TEveViewer* v = gEve->GetDefaultViewer();
+   v->GetGLViewer()->SetGuideState(TGLUtil::kAxesOrigin, kTRUE, kFALSE, 0);
+   gEve->Redraw3D(1);
 }

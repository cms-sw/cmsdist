commit aae20bb8409d729824375dbd9af26ed584448a16
Author: Giulio Eulisse <giulio.eulisse@cern.ch>
Date:   Sat Oct 9 11:15:44 2010 +0200

    ../CMSDIST/root-5.22-00d-fireworks5.patch

diff --git a/graf3d/eve/Module.mk b/graf3d/eve/Module.mk
index 356fbbd..2b98f8b 100644
--- a/graf3d/eve/Module.mk
+++ b/graf3d/eve/Module.mk
@@ -37,7 +37,8 @@ EVEH2     := TEveArrow TEveBoxSet TEveCalo \
              TEveGridStepper TEveLegoEventHandler \
              TEveLine TEvePointSet TEvePolygonSetProjected TEveQuadSet \
              TEveRGBAPalette TEveScalableStraightLineSet TEveStraightLineSet \
-             TEveText TEveTrack TEveTriangleSet TEveJetCone
+             TEveText TEveTrack TEveTriangleSet TEveJetCone \
+	     TEvePlot3D
 
 EVEH1     := $(foreach stem, $(EVEH1), $(wildcard $(MODDIRI)/$(stem)*.h))
 EVEH2     := $(foreach stem, $(EVEH2), $(wildcard $(MODDIRI)/$(stem)*.h))
diff --git a/graf3d/eve/inc/LinkDef1.h b/graf3d/eve/inc/LinkDef1.h
index a5dd76d..aaa528d 100644
--- a/graf3d/eve/inc/LinkDef1.h
+++ b/graf3d/eve/inc/LinkDef1.h
@@ -28,6 +28,7 @@
 // TEveManager
 #pragma link C++ class TEveManager+;
 #pragma link C++ global gEve;
+#pragma link C++ class TEveManager::TRedrawDisabler+;
 #pragma link C++ class TEveManager::TExceptionHandler+;
 
 // TEveVSD
diff --git a/graf3d/eve/inc/LinkDef2.h b/graf3d/eve/inc/LinkDef2.h
index 0af238f..f4aeb62 100644
--- a/graf3d/eve/inc/LinkDef2.h
+++ b/graf3d/eve/inc/LinkDef2.h
@@ -123,14 +123,14 @@
 // TEveLegoEventHandler
 #pragma link C++ class TEveLegoEventHandler+;
 
-
 // TEveJetCone
 #pragma link C++ class TEveJetCone+;
 #pragma link C++ class TEveJetConeEditor+;
 #pragma link C++ class TEveJetConeGL+;
 
-//______________________________________________________________________________
-// Helper classes
+// TEvePlots
+#pragma link C++ class TEvePlot3D+;
+#pragma link C++ class TEvePlot3DGL+;
 
 // TEveFrameBox
 #pragma link C++ class TEveFrameBox+;
diff --git a/graf3d/eve/inc/TEveCalo.h b/graf3d/eve/inc/TEveCalo.h
index 487bbaf..9c3330d 100644
--- a/graf3d/eve/inc/TEveCalo.h
+++ b/graf3d/eve/inc/TEveCalo.h
@@ -210,6 +210,7 @@ public:
 class TEveCaloLego : public TEveCaloViz
 {
    friend class TEveCaloLegoGL;
+   friend class TEveCaloLegoOverlay;
 
 public:
    enum EProjection_e { kAuto, k3D, k2D };
@@ -245,6 +246,10 @@ protected:
    Float_t                 fHPlaneVal;
 
    Int_t                   fTowerPicked;
+   Int_t                   fBinStep;
+
+   Int_t                   fDrawNumberCellPixels;
+   Int_t                   fCellPixelFontSize;
 
    virtual void BuildCellIdCache();
 
@@ -291,7 +296,7 @@ public:
    void       Set2DMode(E2DMode_e p) { f2DMode = p; }
    E2DMode_e  Get2DMode() { return f2DMode; }
 
-   void       SetBoxMode(EBoxMode_e p) { fBoxMode = p; }
+   void        SetBoxMode(EBoxMode_e p) { fBoxMode = p; }
    EBoxMode_e  GetBoxMode() { return fBoxMode; }
 
    Bool_t   GetDrawHPlane() const { return fDrawHPlane; }
@@ -303,6 +308,11 @@ public:
    Int_t    GetTowerPicked() const { return fTowerPicked; }
    void     SetTowerPicked(Int_t p) { fTowerPicked = p;}
 
+   Int_t    GetDrawNumberCellPixels() { return fDrawNumberCellPixels; }
+   void     SetDrawNumberCellPixels(Int_t x) { fDrawNumberCellPixels = x; }
+   Int_t    GetCellPixelFontSize() { return fCellPixelFontSize; }
+   void     SetCellPixelFontSize(Int_t x) { fCellPixelFontSize = x; }
+   
    virtual void ComputeBBox();
 
    ClassDef(TEveCaloLego, 0);  // Class for visualization of calorimeter histogram data.
diff --git a/graf3d/eve/inc/TEveCaloLegoGL.h b/graf3d/eve/inc/TEveCaloLegoGL.h
index 73d8c0c..d759f7a 100644
--- a/graf3d/eve/inc/TEveCaloLegoGL.h
+++ b/graf3d/eve/inc/TEveCaloLegoGL.h
@@ -43,8 +43,6 @@ private:
    mutable TEveVector  fBackPlaneYConst[2];
 
    mutable TGLAxisPainter fAxisPainter;
-   mutable Int_t          fBinStep;
-
 
 protected:
    Int_t   GetGridStep(TGLRnrCtx &rnrCtx) const;
@@ -55,7 +53,7 @@ protected:
    void    DrawAxis2D(TGLRnrCtx &rnrCtx) const;
    void    DrawHistBase(TGLRnrCtx &rnrCtx) const;
 
-   void    DrawCells2D() const;
+   void    DrawCells2D(TGLRnrCtx & rnrCtx) const;
 
    void    DrawCells3D(TGLRnrCtx & rnrCtx) const;
    void    MakeQuad(Float_t x, Float_t y, Float_t z, Float_t xw, Float_t yw, Float_t zh) const;
@@ -73,7 +71,6 @@ protected:
    mutable TEveCaloData::RebinData_t fRebinData;
 
    mutable Bool_t                    fCells3D;
-
 public:
    TEveCaloLegoGL();
    virtual ~TEveCaloLegoGL();
diff --git a/graf3d/eve/inc/TEveCaloLegoOverlay.h b/graf3d/eve/inc/TEveCaloLegoOverlay.h
index 8dc7c9a..3f37119 100644
--- a/graf3d/eve/inc/TEveCaloLegoOverlay.h
+++ b/graf3d/eve/inc/TEveCaloLegoOverlay.h
@@ -17,66 +17,86 @@
 
 class TEveCaloLego;
 
-class TEveCaloLegoOverlay : public TGLCameraOverlay,
-                        public TEveElementList
+class TEveCaloLegoOverlay : public TGLCameraOverlay
 {
 private:
    TEveCaloLegoOverlay(const TEveCaloLegoOverlay&);            // Not implemented
    TEveCaloLegoOverlay& operator=(const TEveCaloLegoOverlay&); // Not implemented
 
-   void DrawSlider(TGLRnrCtx& rnrCtx);
-
    Bool_t SetSliderVal(Event_t* event,TGLRnrCtx& rnrCtx );
 
-   TString        fHeaderTxt;
-   Bool_t         fHeaderSelected;
 
 protected:
-   TEveCaloLego*  fCalo;
-   TAxis         *fSliderAxis;
-
-   Color_t        fMainColor;
+   void   RenderScales(TGLRnrCtx& rnrCtx);
+   void   RenderPlaneInterface(TGLRnrCtx& rnrCtx);
+   void   RenderHeader(TGLRnrCtx& rnrCtx);
+
+   TEveCaloLego*  fCalo; // model
+
+   // 2D scales
+   Bool_t         fShowScales;
+   Color_t        fScaleColor;
+   UChar_t        fScaleTransparency; //transaprency in %
+   Double_t       fScaleCoordX;
+   Double_t       fScaleCoordY;
+   Double_t       fCellX;
+   Double_t       fCellY;
+
+   Color_t        fFrameColor;
+   UChar_t        fFrameLineTransp;
+   UChar_t        fFrameBgTransp;
+
+   // move of scales
+   Int_t             fMouseX, fMouseY; //! last mouse position
+   Bool_t            fInDrag; 
+
+   // text top right corner
+   TString        fHeaderTxt;
+   Bool_t         fHeaderSelected;
 
-   Bool_t         fShowCamera;
+   // plane ojects
+   TAxis         *fPlaneAxis;
+   Color_t        fAxisPlaneColor;
    Bool_t         fShowPlane;
-
-   // plane-value
+   // plane state
    Float_t        fMenuW;
    Float_t        fButtonW;
+   Bool_t         fShowSlider;
    Float_t        fSliderH;    // slider height in % of viewport
    Float_t        fSliderPosY; // y position of slider bottom up
-   Bool_t         fShowSlider;
    Float_t        fSliderVal;
+   // plane event-handling
+   Int_t          fActiveID;
+   Color_t        fActiveCol;
 
-   // event handling
-   Int_t           fActiveID;
-   Color_t         fActiveCol;
-
-   virtual  void   RenderPlaneInterface(TGLRnrCtx& rnrCtx);
-   virtual  void   RenderHeader(TGLRnrCtx& rnrCtx);
 
 public:
    TEveCaloLegoOverlay();
    virtual ~TEveCaloLegoOverlay(){}
 
+   //rendering
+   virtual  void   Render(TGLRnrCtx& rnrCtx);
+
    // event handling
    virtual  Bool_t MouseEnter(TGLOvlSelectRecord& selRec);
    virtual  Bool_t Handle(TGLRnrCtx& rnrCtx, TGLOvlSelectRecord& selRec, Event_t* event);
    virtual  void   MouseLeave();
 
-   //rendering
-   virtual  void   Render(TGLRnrCtx& rnrCtx);
 
    TEveCaloLego* GetCaloLego() {return fCalo;}
-   void SetCaloLego(TEveCaloLego* c) {fCalo = c;}
+   void          SetCaloLego(TEveCaloLego* c) {fCalo = c;}
+
+   void          SetShowPlane (Bool_t x) { fShowPlane = x; }
+   Bool_t        GetShowPlane() const { return fShowPlane; }
+
+   void          SetHeaderTxt(const char *txt) {fHeaderTxt = txt; }
+   const char*   GetHeaderTxt() const { return fHeaderTxt; }
 
-   void SetShowCamera (Bool_t x) { fShowCamera = x; }
-   Bool_t GetShowCamera() const { return fShowCamera; }
-   void SetShowPlane (Bool_t x) { fShowPlane = x; }
-   Bool_t GetShowPlane() const { return fShowPlane; }
+   void          SetShowScales(Bool_t x) { fShowScales = x;}
+   void          SetScaleColorTransparency(Color_t colIdx, UChar_t transp);
+   void          SetScalePosition(Double_t x, Double_t y);
 
-   void  SetHeaderTxt(const char *txt) {fHeaderTxt = txt; }
-   const char* GetHeaderTxt() const { return fHeaderTxt; }
+   void          SetFrameAttribs(Color_t frameCol, UChar_t lineTransp, UChar_t bgTransp);
 
    ClassDef(TEveCaloLegoOverlay, 0); // GL-overaly control GUI for TEveCaloLego.
 };
diff --git a/graf3d/eve/inc/TEveElement.h b/graf3d/eve/inc/TEveElement.h
index 6daedf3..d9695f8 100644
--- a/graf3d/eve/inc/TEveElement.h
+++ b/graf3d/eve/inc/TEveElement.h
@@ -238,6 +238,7 @@ public:
    virtual Bool_t GetRnrSelf()     const { return fRnrSelf; }
    virtual Bool_t GetRnrChildren() const { return fRnrChildren; }
    virtual Bool_t GetRnrState()    const { return fRnrSelf && fRnrChildren; }
+   virtual Bool_t GetRnrAnything() const { return fRnrSelf || (fRnrChildren && HasChildren()); }
    virtual Bool_t SetRnrSelf(Bool_t rnr);
    virtual Bool_t SetRnrChildren(Bool_t rnr);
    virtual Bool_t SetRnrSelfChildren(Bool_t rnr_self, Bool_t rnr_children);
diff --git a/graf3d/eve/inc/TEveGeoNode.h b/graf3d/eve/inc/TEveGeoNode.h
index a939a42..4a7ac0b 100644
--- a/graf3d/eve/inc/TEveGeoNode.h
+++ b/graf3d/eve/inc/TEveGeoNode.h
@@ -104,6 +104,8 @@ public:
 
    void         UseNodeTrans();
 
+   TGeoManager* GetGeoManager() const { return fManager; }
+
    Int_t GetVisOption()      const { return fVisOption; }
    void  SetVisOption(Int_t vo)    { fVisOption = vo;   }
    Int_t GetVisLevel()       const { return fVisLevel;  }
diff --git a/graf3d/eve/inc/TEveLine.h b/graf3d/eve/inc/TEveLine.h
index 8aa2026..82cb291 100644
--- a/graf3d/eve/inc/TEveLine.h
+++ b/graf3d/eve/inc/TEveLine.h
@@ -55,6 +55,9 @@ public:
 
    void   ReduceSegmentLengths(Float_t max);
 
+   TEveVector GetLineStart() const;
+   TEveVector GetLineEnd()   const;
+
    virtual void CopyVizParams(const TEveElement* el);
    virtual void WriteVizParams(ostream& out, const TString& var);
 
diff --git a/graf3d/eve/inc/TEveManager.h b/graf3d/eve/inc/TEveManager.h
index 3e53a24..be021a9 100644
--- a/graf3d/eve/inc/TEveManager.h
+++ b/graf3d/eve/inc/TEveManager.h
@@ -61,8 +61,10 @@ public:
    public:
       TRedrawDisabler(TEveManager* m) : fMgr(m)
       { if (fMgr) fMgr->DisableRedraw(); }
-      ~TRedrawDisabler()
+      virtual ~TRedrawDisabler()
       { if (fMgr) fMgr->EnableRedraw(); }
+
+      ClassDef(TRedrawDisabler, 0); // Exception-safe EVE redraw-disabler.
    };
 
    class TExceptionHandler : public TStdExceptionHandler
diff --git a/graf3d/eve/inc/TEvePlot3D.h b/graf3d/eve/inc/TEvePlot3D.h
new file mode 100644
index 0000000..d5a0a4b
--- /dev/null
+++ b/graf3d/eve/inc/TEvePlot3D.h
@@ -0,0 +1,61 @@
+// @(#)root/eve:$Id: TEvePlot3D.h 29909 2009-08-25 19:04:28Z matevz $
+// Author: Matevz Tadel, 2009
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#ifndef ROOT_TEvePlot3D
+#define ROOT_TEvePlot3D
+
+#include "TEveElement.h"
+#include "TAttBBox.h"
+
+class TEvePlot3D : public TEveElementList // , public TAttBBox
+{
+   friend class TEvePlot3DGL;
+
+private:
+   TEvePlot3D(const TEvePlot3D&);            // Not implemented
+   TEvePlot3D& operator=(const TEvePlot3D&); // Not implemented
+
+protected:
+   TObject     *fPlot;       // Plot object.
+   TString      fPlotOption; // Options for the plot-painter.
+
+   Bool_t       fLogX;
+   Bool_t       fLogY;
+   Bool_t       fLogZ;
+
+public:
+   TEvePlot3D(const char* n="TEvePlot3D", const char* t="");
+   virtual ~TEvePlot3D() {}
+
+   // For TAttBBox:
+   // virtual void ComputeBBox();
+
+   void SetPlot(TObject* obj, const TString& opt) { fPlot = obj; fPlotOption = opt; }
+
+   TObject* GetPlot()       const { return fPlot;   }
+   TString  GetPlotOption() const { return fPlotOption; }
+
+   void     SetLogXYZ(Bool_t lx, Bool_t ly, Bool_t lz) { fLogX = lx; fLogY = ly; fLogZ = lz; }
+
+   void     SetLogX(Bool_t l) { fLogX = l; }
+   void     SetLogY(Bool_t l) { fLogY = l; }
+   void     SetLogZ(Bool_t l) { fLogZ = l; }
+
+   Bool_t   GetLogX() const { return fLogX; }
+   Bool_t   GetLogY() const { return fLogY; }
+   Bool_t   GetLogZ() const { return fLogZ; }
+
+   virtual void Paint(Option_t* option="");
+
+   ClassDef(TEvePlot3D, 0); // Short description.
+};
+
+#endif
diff --git a/graf3d/eve/inc/TEvePlot3DGL.h b/graf3d/eve/inc/TEvePlot3DGL.h
new file mode 100644
index 0000000..11e772a
--- /dev/null
+++ b/graf3d/eve/inc/TEvePlot3DGL.h
@@ -0,0 +1,51 @@
+// @(#)root/eve:$Id: TEvePlot3DGL.h 29909 2009-08-25 19:04:28Z matevz $
+// Author: Matevz Tadel, 2009
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#ifndef ROOT_TEvePlot3DGL
+#define ROOT_TEvePlot3DGL
+
+#include "TGLObject.h"
+
+class TGLViewer;
+class TGLScene;
+
+class TEvePlot3D;
+class TGLPlot3D;
+
+class TEvePlot3DGL : public TGLObject
+{
+private:
+   TEvePlot3DGL(const TEvePlot3DGL&);            // Not implemented
+   TEvePlot3DGL& operator=(const TEvePlot3DGL&); // Not implemented
+
+protected:
+   TEvePlot3D      *fM;           // Model object.
+   TGLPlot3D       *fPlotLogical; // Actual painter.
+
+public:
+   TEvePlot3DGL();
+   virtual ~TEvePlot3DGL() {}
+
+   virtual Bool_t KeepDuringSmartRefresh() const { return kFALSE; }
+
+   virtual Bool_t SetModel(TObject* obj, const Option_t* opt=0);
+   virtual void   SetBBox();
+
+   virtual void DirectDraw(TGLRnrCtx & rnrCtx) const;
+
+   // To support two-level selection
+   // virtual Bool_t SupportsSecondarySelect() const { return kTRUE; }
+   // virtual void ProcessSelection(TGLRnrCtx & rnrCtx, TGLSelectRecord & rec);
+
+   ClassDef(TEvePlot3DGL, 0); // GL renderer class for TEvePlot3D.
+};
+
+#endif
diff --git a/graf3d/eve/inc/TEveScene.h b/graf3d/eve/inc/TEveScene.h
index 414fd35..a34a986 100644
--- a/graf3d/eve/inc/TEveScene.h
+++ b/graf3d/eve/inc/TEveScene.h
@@ -13,8 +13,8 @@
 #define ROOT_TEveScene
 
 #include "TEveElement.h"
-#include "TEvePad.h"
 
+class TEvePad;
 class TGLScenePad;
 
 
@@ -34,6 +34,9 @@ protected:
 
    Bool_t       fChanged;
    Bool_t       fSmartRefresh;
+   Bool_t       fHierarchical;
+
+   void RetransHierarchicallyRecurse(TEveElement* el, const TEveTrans& tp);
 
 public:
    TEveScene(const char* n="TEveScene", const char* t="");
@@ -41,9 +44,16 @@ public:
 
    virtual void CollectSceneParents(List_t& scenes);
 
+   virtual Bool_t SingleRnrState() const { return kTRUE; }
+
    void   Changed()         { fChanged = kTRUE; }
    Bool_t IsChanged() const { return fChanged;  }
+
+   void   SetHierarchical(Bool_t h) { fHierarchical = h;    }
+   Bool_t GetHierarchical()   const { return fHierarchical; }
+
    void   Repaint(Bool_t dropLogicals=kFALSE);
+   void   RetransHierarchically();
 
    TGLScenePad* GetGLScene() const { return fGLScene; }
    void SetGLScene(TGLScenePad* s) { fGLScene = s; }
diff --git a/graf3d/eve/inc/TEveStraightLineSetGL.h b/graf3d/eve/inc/TEveStraightLineSetGL.h
index 6066ec7..af62842 100644
--- a/graf3d/eve/inc/TEveStraightLineSetGL.h
+++ b/graf3d/eve/inc/TEveStraightLineSetGL.h
@@ -37,8 +37,7 @@ public:
    virtual void   Draw(TGLRnrCtx& rnrCtx) const;
    virtual void   DirectDraw(TGLRnrCtx& rnrCtx) const;
 
-   // To support two-level selectionvirtual
-   Bool_t IgnoreSizeForOfInterest() const { return kTRUE; }
+   virtual Bool_t IgnoreSizeForOfInterest() const { return kTRUE; }
 
    virtual Bool_t ShouldDLCache(const TGLRnrCtx& rnrCtx) const;
    virtual Bool_t SupportsSecondarySelect() const { return kTRUE; }
diff --git a/graf3d/eve/inc/TEveTrack.h b/graf3d/eve/inc/TEveTrack.h
index 0765dd5..a592baa 100644
--- a/graf3d/eve/inc/TEveTrack.h
+++ b/graf3d/eve/inc/TEveTrack.h
@@ -49,6 +49,7 @@ protected:
    Int_t              fCharge;     // Charge in units of e0
    Int_t              fLabel;      // Simulation label
    Int_t              fIndex;      // Reconstruction index
+   Int_t              fStatus;     // Status-word, user-defined.
    Bool_t             fLockPoints; // Lock points that are currently in - do nothing in MakeTrack().
    vPathMark_t        fPathMarks;  // TEveVector of known points along the track
 
@@ -60,9 +61,9 @@ protected:
 
 public:
    TEveTrack();
-   TEveTrack(TParticle* t, Int_t label, TEveTrackPropagator* rs);
-   TEveTrack(TEveMCTrack*  t, TEveTrackPropagator* rs);
-   TEveTrack(TEveRecTrack* t, TEveTrackPropagator* rs);
+   TEveTrack(TParticle* t, Int_t label, TEveTrackPropagator* prop=0);
+   TEveTrack(TEveMCTrack*  t, TEveTrackPropagator* prop=0);
+   TEveTrack(TEveRecTrack* t, TEveTrackPropagator* prop=0);
    TEveTrack(const TEveTrack& t);
    virtual ~TEveTrack();
 
@@ -74,7 +75,7 @@ public:
    virtual void MakeTrack(Bool_t recurse=kTRUE);
 
    TEveTrackPropagator* GetPropagator() const  { return fPropagator; }
-   void SetPropagator(TEveTrackPropagator* rs);
+   void SetPropagator(TEveTrackPropagator* prop);
    void SetAttLineAttMarker(TEveTrackList* tl);
 
    const TEveVector& GetVertex()      const { return fV;    }
@@ -89,6 +90,8 @@ public:
    void  SetLabel(Int_t lbl)  { fLabel = lbl;   }
    Int_t GetIndex()  const    { return fIndex;  }
    void  SetIndex(Int_t idx)  { fIndex = idx;   }
+   Int_t GetStatus()  const   { return fStatus; }
+   void  SetStatus(Int_t idx) { fStatus = idx;  }
 
    void  AddPathMark(const TEvePathMark& pm) { fPathMarks.push_back(pm); }
    void  SortPathMarksByTime();
@@ -158,14 +161,14 @@ protected:
    void    SanitizeMinMaxCuts();
 
 public:
-   TEveTrackList(TEveTrackPropagator* rs=0);
-   TEveTrackList(const char* name, TEveTrackPropagator* rs=0);
+   TEveTrackList(TEveTrackPropagator* prop=0);
+   TEveTrackList(const char* name, TEveTrackPropagator* prop=0);
    virtual ~TEveTrackList();
 
    void  MakeTracks(Bool_t recurse=kTRUE);
    void  FindMomentumLimits(Bool_t recurse=kTRUE);
 
-   void  SetPropagator(TEveTrackPropagator* rs);
+   void  SetPropagator(TEveTrackPropagator* prop);
    TEveTrackPropagator* GetPropagator() { return fPropagator; }
 
    Bool_t GetRecurse() const   { return fRecurse; }
diff --git a/graf3d/eve/inc/TEveTrackPropagator.h b/graf3d/eve/inc/TEveTrackPropagator.h
index f7d0bcf..2886cb0 100644
--- a/graf3d/eve/inc/TEveTrackPropagator.h
+++ b/graf3d/eve/inc/TEveTrackPropagator.h
@@ -131,17 +131,19 @@ public:
       TEveVector fB;        // Current magnetic field, cached.
       TEveVector fE1, fE2, fE3; // Base vectors: E1 -> B dir, E2->pT dir, E3 = E1xE2.
       TEveVector fPt, fPl;  // Transverse and longitudinal momentum.
-      Float_t fPtMag;       // Magnitude of pT
-      Float_t fPlDir;       // Momentum parallel to mag field.
+      Float_t fPtMag;       // Magnitude of pT.
+      Float_t fPlMag;       // Momentum parallel to mag field.
       Float_t fLStep;       // Transverse step arc-length in cm.
 
       // ----------------------------------------------------------------
 
       Helix_t();
 
+      void UpdateCommon(const TEveVector & p, const TEveVector& b);
       void UpdateHelix(const TEveVector & p, const TEveVector& b, Bool_t fullUpdate);
       void UpdateRK   (const TEveVector & p, const TEveVector& b);
-      void Step  (const TEveVector4& v, const TEveVector& p, TEveVector4& vOut, TEveVector& pOut);
+
+      void Step(const TEveVector4& v, const TEveVector& p, TEveVector4& vOut, TEveVector& pOut);
 
       Float_t GetStep()  { return fLStep * TMath::Sqrt(1 + fLam*fLam); }
       Float_t GetStep2() { return fLStep * fLStep * (1 + fLam*fLam);   }
@@ -186,7 +188,8 @@ protected:
    Helix_t                  fH;             // Helix.
 
    void    RebuildTracks();
-   void    Step(TEveVector4 &v, TEveVector &p, TEveVector4 &vOut, TEveVector &pOut);
+   void    Update(const TEveVector4& v, const TEveVector& p, Bool_t full_update=kFALSE);
+   void    Step(const TEveVector4 &v, const TEveVector &p, TEveVector4 &vOut, TEveVector &pOut);
 
    Bool_t  LoopToVertex(TEveVector& v, TEveVector& p);
    void    LoopToBounds(TEveVector& p);
@@ -201,7 +204,7 @@ protected:
    Bool_t  LineIntersectPlane(const TEveVector& p, const TEveVector& point, const TEveVector& normal,
                               TEveVector& itsect);
 
-   Bool_t PointOverVertex(const TEveVector4& v0, const TEveVector4& v);
+   Bool_t PointOverVertex(const TEveVector4& v0, const TEveVector4& v, Float_t* p=0);
 
 public:
    TEveTrackPropagator(const char* n="TEveTrackPropagator", const char* t="",
@@ -279,7 +282,7 @@ public:
 
    static Float_t             fgDefMagField; // Default value for constant solenoid magnetic field.
    static const Float_t       fgkB2C;        // Constant for conversion of momentum to curvature.
-   static TEveTrackPropagator fgDefStyle;    // Default track render-style.
+   static TEveTrackPropagator fgDefault;     // Default track propagator.
 
    ClassDef(TEveTrackPropagator, 0); // Calculates path of a particle taking into account special path-marks and imposed boundaries.
 };
@@ -298,13 +301,35 @@ inline Bool_t TEveTrackPropagator::IsOutsideBounds(const TEveVector& point,
 
 //______________________________________________________________________________
 inline Bool_t TEveTrackPropagator::PointOverVertex(const TEveVector4 &v0,
-                                                   const TEveVector4 &v)
+                                                   const TEveVector4 &v,
+                                                   Float_t           *p)
 {
-   Float_t dotV = fH.fB.fX*(v0.fX-v.fX)
-                + fH.fB.fY*(v0.fY-v.fY)
-                + fH.fB.fZ*(v0.fZ-v.fZ);
+   static const Float_t kMinPl = 1e-5;
+
+   TEveVector dv; dv.Sub(v0, v);
+
+   Float_t dotV;
+
+   if (TMath::Abs(fH.fPlMag) > kMinPl)
+   {
+      // Use longitudinal momentum to determine crossing point.
+      // Works ok for spiraling helices, also for loopers.
+
+      dotV = fH.fE1.Dot(dv);
+      if (fH.fPlMag < 0)
+         dotV = -dotV;
+   }
+   else
+   {
+      // Use full momentum, which is pT, under this conditions.
+
+      dotV = fH.fE2.Dot(dv);
+   }
+
+   if (p)
+      *p = dotV;
 
-   return (fH.fPlDir > 0 && dotV < 0) || (fH.fPlDir < 0 && dotV >0);
+   return dotV < 0;
 }
 
 #endif
diff --git a/graf3d/eve/inc/TEveTrans.h b/graf3d/eve/inc/TEveTrans.h
index d6578c0..a089957 100644
--- a/graf3d/eve/inc/TEveTrans.h
+++ b/graf3d/eve/inc/TEveTrans.h
@@ -14,6 +14,8 @@
 
 #include "TVector3.h"
 
+class TEveVector;
+
 class TGeoMatrix;
 class TGeoHMatrix;
 class TBuffer3D;
@@ -54,12 +56,14 @@ public:
    // General operations
 
    void     UnitTrans();
+   void     ZeroTrans(Double_t w=1.0);
    void     UnitRot();
    void     SetTrans(const TEveTrans& t, Bool_t copyAngles=kTRUE);
    void     SetFromArray(const Double_t arr[16]);
    void     SetFromArray(const Float_t  arr[16]);
    TEveTrans&  operator=(const TEveTrans& t) { SetTrans(t); return *this; }
    void     SetupRotation(Int_t i, Int_t j, Double_t f);
+   void     SetupFromToVec(const TEveVector& from, const TEveVector& to);
 
    void     OrtoNorm3();
    Double_t Invert();
@@ -149,6 +153,8 @@ public:
    TVector3 Multiply(const TVector3& v, Double_t w=1) const;
    void     Multiply(const Double_t *vin, Double_t* vout, Double_t w=1) const;
    void     RotateIP(TVector3& v) const;
+   void     RotateIP(Double_t* v) const;
+   void     RotateIP(TEveVector& v) const;
    TVector3 Rotate(const TVector3& v) const;
 
    virtual void Print(Option_t* option = "") const;
diff --git a/graf3d/eve/inc/TEveVSDStructs.h b/graf3d/eve/inc/TEveVSDStructs.h
index 7f54c71..3816995 100644
--- a/graf3d/eve/inc/TEveVSDStructs.h
+++ b/graf3d/eve/inc/TEveVSDStructs.h
@@ -68,7 +68,7 @@ public:
    Float_t  operator [] (Int_t indx) const;
 
    const Float_t* Arr() const { return &fX; }
-         Float_t* Arr()       { return &fX; }
+   Float_t* Arr()       { return &fX; }
 
    void Set(const Float_t*  v) { fX = v[0]; fY = v[1]; fZ = v[2]; }
    void Set(const Double_t* v) { fX = v[0]; fY = v[1]; fZ = v[2]; }
@@ -94,33 +94,47 @@ public:
 
    Float_t Distance(const TEveVector& v) const;
    Float_t SquareDistance(const TEveVector& v) const;
-   Float_t Dot(const TEveVector&a) const;
 
-   TEveVector& Mult(const TEveVector& a, Float_t af)
-   { fX = a.fX*af; fY = a.fY*af; fZ = a.fZ*af; return *this; }
+   Float_t    Dot(const TEveVector& a) const;
+   TEveVector Cross(const TEveVector& a) const;
+
+   TEveVector& Sub(const TEveVector& p, const TEveVector& q);
+
+   TEveVector& Mult(const TEveVector& a, Float_t af);
 
    TEveVector Orthogonal() const;
-   void OrthoNormBase(TEveVector& a, TEveVector& b) const;
+   void       OrthoNormBase(TEveVector& a, TEveVector& b) const;
 
    ClassDef(TEveVector, 1); // Float three-vector; a minimal Float_t copy of TVector3 used to represent points and momenta (also used in VSD).
 };
 
 //______________________________________________________________________________
 inline Float_t TEveVector::Phi() const
-{ return fX == 0.0 && fY == 0.0 ? 0.0 : TMath::ATan2(fY, fX); }
+{
+   return fX == 0.0 && fY == 0.0 ? 0.0 : TMath::ATan2(fY, fX);
+}
 
+//______________________________________________________________________________
 inline Float_t TEveVector::Theta() const
-{ return fX == 0.0 && fY == 0.0 && fZ == 0.0 ? 0.0 : TMath::ATan2(Perp(), fZ); }
+{
+   return fX == 0.0 && fY == 0.0 && fZ == 0.0 ? 0.0 : TMath::ATan2(Perp(), fZ);
+}
 
+//______________________________________________________________________________
 inline Float_t TEveVector::CosTheta() const
-{ Float_t ptot = Mag(); return ptot == 0.0 ? 1.0 : fZ/ptot; }
+{
+   Float_t ptot = Mag(); return ptot == 0.0 ? 1.0 : fZ/ptot;
+}
 
+//______________________________________________________________________________
 inline Float_t TEveVector::Distance( const TEveVector& b) const
 {
    return TMath::Sqrt((fX - b.fX)*(fX - b.fX) +
                       (fY - b.fY)*(fY - b.fY) +
                       (fZ - b.fZ)*(fZ - b.fZ));
 }
+
+//______________________________________________________________________________
 inline Float_t TEveVector::SquareDistance(const TEveVector& b) const
 {
    return ((fX - b.fX) * (fX - b.fX) +
@@ -134,11 +148,45 @@ inline Float_t TEveVector::Dot(const TEveVector& a) const
    return a.fX*fX + a.fY*fY + a.fZ*fZ;
 }
 
+//______________________________________________________________________________
+inline TEveVector TEveVector::Cross(const TEveVector& a) const
+{
+   TEveVector r;
+   r.fX = fY * a.fZ - fZ * a.fY;
+   r.fY = fZ * a.fX - fX * a.fZ;
+   r.fZ = fX * a.fY - fY * a.fX;
+   return r;
+}
+
+//______________________________________________________________________________
+inline TEveVector& TEveVector::Sub(const TEveVector& p, const TEveVector& q)
+{
+   fX = p.fX - q.fX;
+   fY = p.fY - q.fY;
+   fZ = p.fZ - q.fZ;
+   return *this;
+}
+
+//______________________________________________________________________________
+inline TEveVector& TEveVector::Mult(const TEveVector& a, Float_t af)
+{
+   fX = a.fX * af;
+   fY = a.fY * af;
+   fZ = a.fZ * af;
+   return *this;
+}
+
+//______________________________________________________________________________
 inline Float_t& TEveVector::operator [] (Int_t idx)
-{ return (&fX)[idx]; }
+{
+   return (&fX)[idx];
+}
 
+//______________________________________________________________________________
 inline Float_t TEveVector::operator [] (Int_t idx) const
-{ return (&fX)[idx]; }
+{
+   return (&fX)[idx];
+}
 
 
 /******************************************************************************/
@@ -158,13 +206,13 @@ public:
 
    void Dump() const;
 
-   TEveVector4 operator + (const TEveVector4 & b)
+   TEveVector4 operator + (const TEveVector4 & b) const
    { return TEveVector4(fX + b.fX, fY + b.fY, fZ + b.fZ, fT + b.fT); }
 
-   TEveVector4 operator - (const TEveVector4 & b)
+   TEveVector4 operator - (const TEveVector4 & b) const
    { return TEveVector4(fX - b.fX, fY - b.fY, fZ - b.fZ, fT - b.fT); }
 
-   TEveVector4 operator * (Float_t a)
+   TEveVector4 operator * (Float_t a) const
    { return TEveVector4(a*fX, a*fY, a*fZ, a*fT); }
 
    TEveVector4& operator += (const TEveVector4 & b)
diff --git a/graf3d/eve/src/TEveCalo.cxx b/graf3d/eve/src/TEveCalo.cxx
index cee1309..b83c9ba 100644
--- a/graf3d/eve/src/TEveCalo.cxx
+++ b/graf3d/eve/src/TEveCalo.cxx
@@ -572,8 +572,6 @@ void TEveCalo2D::ComputeBBox()
    x = 0, y = -r, z = 0;
    fManager->GetProjection()->ProjectPoint(x, y, z);
    BBoxCheckPoint(x, y, z);
-
-   AssertBBoxExtents(0.1);
 }
 
 
@@ -612,7 +610,11 @@ TEveCaloLego::TEveCaloLego(TEveCaloData* d, const char* n, const char* t):
    fDrawHPlane(kFALSE),
    fHPlaneVal(0),
 
-   fTowerPicked(-1)
+   fTowerPicked(-1),
+
+   fBinStep(-1),
+   fDrawNumberCellPixels(30), // draw numbers on cell above 30 pixels
+   fCellPixelFontSize(15) // size of cell fonts in pixels 
 {
    // Constructor.
 
diff --git a/graf3d/eve/src/TEveCaloData.cxx b/graf3d/eve/src/TEveCaloData.cxx
index a2bd125..32c6178 100644
--- a/graf3d/eve/src/TEveCaloData.cxx
+++ b/graf3d/eve/src/TEveCaloData.cxx
@@ -213,10 +213,10 @@ TEveCaloDataVec::TEveCaloDataVec(Int_t nslices):
    TEveCaloData(),
 
    fTower(0),
-   fEtaMin( 10),
-   fEtaMax(-10),
-   fPhiMin( 10),
-   fPhiMax(-10)
+   fEtaMin( 1e3),
+   fEtaMax(-1e3),
+   fPhiMin( 1e3),
+   fPhiMax(-1e3)
 {
    // Constructor.
 
diff --git a/graf3d/eve/src/TEveCaloLegoGL.cxx b/graf3d/eve/src/TEveCaloLegoGL.cxx
index dee8ae4..d0359ae 100644
--- a/graf3d/eve/src/TEveCaloLegoGL.cxx
+++ b/graf3d/eve/src/TEveCaloLegoGL.cxx
@@ -42,8 +42,6 @@ TEveCaloLegoGL::TEveCaloLegoGL() :
       fEtaAxis(0),
       fPhiAxis(0),
       fZAxis(0),
-      fBinStep(1),
-
       fM(0),
       fDLCacheOK(kFALSE),
       fCells3D(kTRUE)
@@ -54,18 +52,9 @@ TEveCaloLegoGL::TEveCaloLegoGL() :
 
    // need to set dummy parent, else loose settings in rebin
 
-   // X axis
    fEtaAxis = new TAxis();
-
-   // Y axis
    fPhiAxis = new TAxis();
-
-   // fZAxis
    fZAxis = new TAxis();
-   fZAxis->SetLabelSize(0.05);
-   fZAxis->SetTitleSize(0.05);
-   fZAxis->SetTickLength(1);
-   fZAxis->SetLabelOffset(0.5);
 
     fAxisPainter.SetFontMode(TGLFont::kPixmap);
 }
@@ -108,6 +97,7 @@ void TEveCaloLegoGL::DLCacheDrop()
 {
    // Drop all display-list definitions.
 
+   fDLCacheOK = kFALSE;
    for (SliceDLMap_i i = fDLMap.begin(); i != fDLMap.end(); ++i)
       i->second = 0;
 
@@ -119,6 +109,7 @@ void TEveCaloLegoGL::DLCachePurge()
 {
    // Unregister all display-lists.
 
+   fDLCacheOK = kFALSE;
    if (! fDLMap.empty()) {
       for (SliceDLMap_i i = fDLMap.begin(); i != fDLMap.end(); ++i) {
          if (i->second) {
@@ -208,7 +199,7 @@ void TEveCaloLegoGL::MakeDisplayList() const
    // Create display-list that draws histogram bars.
    // It is used for filled and outline passes.
 
-   if (fBinStep>1)
+   if (fM->fBinStep > 1)
    {
       Int_t nSlices = fM->fData->GetNSlices();
       Float_t *vals;
@@ -437,9 +428,10 @@ void TEveCaloLegoGL::DrawAxis3D(TGLRnrCtx & rnrCtx) const
                               + (up[2] - dn[2]) * (up[2] - dn[2]));
 
    TGLVertex3 worldRef(fZAxisTitlePos.fX, fZAxisTitlePos.fY, fZAxisTitlePos.fZ);
-   fAxisPainter.RefTMOff(0) = rnrCtx.RefCamera().ViewportDeltaToWorld(worldRef, -10, 0,  &mm);
-   fAxisPainter.SetLabelPixelFontSize(TMath::CeilNint(len*fZAxis->GetLabelSize()));
-   fAxisPainter.SetTitlePixelFontSize(TMath::CeilNint(len*fZAxis->GetTitleSize()));
+
+   fAxisPainter.RefTMOff(0) = rnrCtx.RefCamera().ViewportDeltaToWorld(worldRef, -len, 0,  &mm);
+   fAxisPainter.SetLabelPixelFontSize(TMath::CeilNint(len*fM->GetData()->GetEtaBins()->GetLabelSize()));
+   fAxisPainter.SetTitlePixelFontSize(TMath::CeilNint(len*fM->GetData()->GetEtaBins()->GetTitleSize()));
 
    // Z axis
    //
@@ -459,7 +451,9 @@ void TEveCaloLegoGL::DrawAxis3D(TGLRnrCtx & rnrCtx) const
       glTranslatef(fZAxisTitlePos.fX, fZAxisTitlePos.fY, 0);
 
       // tickmark vector = 10 pixels left
-      fAxisPainter.RefTitlePos().Set(fAxisPainter.RefTMOff(0).X(),  fAxisPainter.RefTMOff(0).Y(), fZAxisTitlePos.fZ);
+      fAxisPainter.RefTitlePos().Set(fAxisPainter.RefTMOff(0).X()*0.05,  fAxisPainter.RefTMOff(0).Y()*0.05, fZAxisTitlePos.fZ);
+      fZAxis->SetLabelOffset(0.05);
+      fZAxis->SetTickLength(0.05);
       fAxisPainter.PaintAxis(rnrCtx, fZAxis);
       glTranslated( fAxisPainter.RefTMOff(0).X(),  fAxisPainter.RefTMOff(0).Y(),  fAxisPainter.RefTMOff(0).Z());
       glPopMatrix();
@@ -483,7 +477,7 @@ void TEveCaloLegoGL::DrawAxis3D(TGLRnrCtx & rnrCtx) const
          glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT);
 
          // box verticals
-         glLineWidth(1);
+         TGLUtil::LineWidth(1);
          glBegin(GL_LINES);
          TGLUtil::Color(fM->GetGridColor());
 
@@ -543,8 +537,6 @@ void TEveCaloLegoGL::DrawAxis3D(TGLRnrCtx & rnrCtx) const
    ax.SetTitleFont(fM->GetData()->GetEtaBins()->GetTitleFont());
    ax.SetLabelOffset(0.02);
    ax.SetTickLength(0.05);
-   ax.SetLabelSize(0.03);
-
    fAxisPainter.SetTMNDim(2);
    fAxisPainter.RefTMOff(1).Set(0, 0, -fDataMax);
    fAxisPainter.SetLabelAlign(TGLFont::kCenterUp);
@@ -559,8 +551,6 @@ void TEveCaloLegoGL::DrawAxis3D(TGLRnrCtx & rnrCtx) const
    ax.SetTitle(fM->GetData()->GetEtaBins()->GetTitle());
    fAxisPainter.RefTitlePos().Set(fXAxisTitlePos.fX, yOff*1.5*ax.GetTickLength(), -fDataMax*ax.GetTickLength());
    fAxisPainter.PaintAxis(rnrCtx, &ax);
-   glTranslatef(0, yOff*1.5*ax.GetTickLength(), -fDataMax*ax.GetTickLength());
-   //   fAxisPainter.RnrTitle(fM->GetData()->GetEtaBins()->GetTitle(), fXAxisTitlePos.fX, TGLFont::kCenterUp);
    glPopMatrix();
 
    // phi
@@ -573,8 +563,6 @@ void TEveCaloLegoGL::DrawAxis3D(TGLRnrCtx & rnrCtx) const
    glTranslatef(fYAxisTitlePos.fX, 0, 0);
    fAxisPainter.RefTitlePos().Set( xOff*1.5*ax.GetTickLength(), fYAxisTitlePos.fY,  -fDataMax*ax.GetTickLength());
    fAxisPainter.PaintAxis(rnrCtx, &ax);
-   glTranslatef(xOff*1.5*ax.GetTickLength(), 0,  -fDataMax*ax.GetTickLength());
-   //fAxisPainter.RnrTitle(fM->GetData()->GetPhiBins()->GetTitle(), fYAxisTitlePos.fY, TGLFont::kCenterUp);
    glPopMatrix();
 
 } // DrawAxis3D
@@ -610,10 +598,10 @@ void TEveCaloLegoGL::DrawAxis2D(TGLRnrCtx & rnrCtx) const
    Double_t len = TMath::Sqrt((up[0] - dn[0]) * (up[0] - dn[0])
                               + (up[1] - dn[1]) * (up[1] - dn[1])
                               + (up[2] - dn[2]) * (up[2] - dn[2]));
-   fAxisPainter.SetLabelPixelFontSize(TMath::CeilNint(len*0.02));
-   fAxisPainter.SetTitlePixelFontSize(TMath::CeilNint(len*0.02));
 
    // eta
+   fAxisPainter.SetLabelPixelFontSize(TMath::CeilNint(len*fM->GetData()->GetEtaBins()->GetLabelSize()));
+   fAxisPainter.SetTitlePixelFontSize(TMath::CeilNint(len*fM->GetData()->GetEtaBins()->GetTitleSize()));
    ax.SetNdivisions(710);
    ax.SetLimits(fM->GetEtaMin(), fM->GetEtaMax());
    ax.SetTitle(fM->GetData()->GetEtaBins()->GetTitle());
@@ -628,9 +616,11 @@ void TEveCaloLegoGL::DrawAxis2D(TGLRnrCtx & rnrCtx) const
    glPopMatrix();
 
    // phi
+   fAxisPainter.SetLabelPixelFontSize(TMath::CeilNint(len*fM->GetData()->GetPhiBins()->GetLabelSize()));
+   fAxisPainter.SetTitlePixelFontSize(TMath::CeilNint(len*fM->GetData()->GetPhiBins()->GetTitleSize()));
    ax.SetNdivisions(510);
    ax.SetLimits(fM->GetPhiMin(), fM->GetPhiMax());
-   ax.SetTitle(fM->GetData()->GetPhiBins()->GetTitle());  
+   ax.SetTitle(fM->GetData()->GetPhiBins()->GetTitle());
    fAxisPainter.RefTitlePos().Set(-fM->GetEtaRng()*(ax.GetTickLength()+ ax.GetLabelOffset()), fM->GetPhiMax(), 0);
    fAxisPainter.RefDir().Set(0, 1, 0);
    fAxisPainter.RefTMOff(0).Set(-fM->GetEtaRng(), 0, 0);
@@ -647,8 +637,6 @@ Int_t TEveCaloLegoGL::GetGridStep(TGLRnrCtx &rnrCtx) const
 {
    // Calculate view-dependent grid density.
 
-   if (!fM->fAutoRebin) return 1;
-
    using namespace TMath;
 
    GLdouble x0, y0, z0, x1, y1, z1;
@@ -675,17 +663,18 @@ Int_t TEveCaloLegoGL::GetGridStep(TGLRnrCtx &rnrCtx) const
    Int_t j0 = fM->fData->GetPhiBins()->FindBin(fM->GetPhiMin());
    Int_t j1 = fM->fData->GetPhiBins()->FindBin(fM->GetPhiMax());
 
-   Float_t ppb = d / Sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
-
-   Int_t ngroup;
-   if (ppb < fM->fPixelsPerBin*0.5) {
-      ngroup = 4;
-   } else if (ppb < fM->fPixelsPerBin) {
-      ngroup = 2;
-   } else {
-      ngroup = 1;
+   Int_t pixelsPerBin = TMath::Nint(d / Sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1)));
+   Int_t ngroup = 1;
+   if (fM->fAutoRebin)
+   {
+      if (pixelsPerBin < fM->fPixelsPerBin*0.5) {
+         ngroup = 4;
+      } else if (pixelsPerBin < fM->fPixelsPerBin) {
+         ngroup = 2;
+      } else {
+         ngroup = 1;
+      }
    }
-
    return ngroup;
 }
 
@@ -694,14 +683,18 @@ void TEveCaloLegoGL::RebinAxis(TAxis *orig, TAxis *curr) const
 {
    // Rebin eta, phi axis.
 
-   Int_t nb = orig->GetNbins();
-   Int_t newbins = nb/fBinStep;
-   Double_t *bins = new Double_t[newbins+1];
+   Double_t center = 0.5 * (orig->GetXmin() + orig->GetXmax());
+   Int_t idx0 = orig->FindBin(center);
+   Double_t bc = orig->GetBinCenter(idx0);
+   if (bc > center) idx0--;
 
-   for(Int_t i = 0; i <= newbins; ++i)
-      bins[i] = orig->GetBinLowEdge(1+i*fBinStep);
+   Int_t nbR = TMath::FloorNint(idx0/fM->fBinStep) + TMath::FloorNint((orig->GetNbins() - idx0)/fM->fBinStep);
+   Double_t *bins = new Double_t[nbR+1];
+   Int_t off = idx0 - TMath::FloorNint(idx0/fM->fBinStep)*fM->fBinStep;
+   for(Int_t i = 0; i <= nbR; i++)
+      bins[i] = orig->GetBinUpEdge(off + i*fM->fBinStep);
 
-   curr->Set(newbins,bins);
+   curr->Set(nbR, bins);
    delete [] bins;
 }
 
@@ -721,7 +714,7 @@ void TEveCaloLegoGL::DrawHistBase(TGLRnrCtx &rnrCtx) const
    // XY grid
    //
    TGLUtil::Color(fM->fGridColor);
-   glLineWidth(1);
+   TGLUtil::LineWidth(1);
    glBegin(GL_LINES);
    glVertex2f(eta0, phi0);
    glVertex2f(eta0, phi1);
@@ -734,30 +727,26 @@ void TEveCaloLegoGL::DrawHistBase(TGLRnrCtx &rnrCtx) const
    glVertex2f(eta1, phi1);
 
    // eta grid
-   Int_t   eFirst = fEtaAxis->FindBin(eta0);
-   Int_t   bin    = eFirst;
-   Float_t val    = fEtaAxis->GetBinUpEdge(bin);
-   while (val < eta1)
+   Float_t val;
+   Int_t neb = fEtaAxis->GetNbins();
+   for (Int_t i = 0; i<= neb; i++)
    {
-      glVertex2f(val, phi0);
-      glVertex2f(val, phi1);
-      ++bin;
-      val = fEtaAxis->GetBinUpEdge(bin);
+      val = fEtaAxis->GetBinUpEdge(i);
+      if (val > eta0 && val < eta1 )
+      {
+         glVertex2f(val, phi0);
+         glVertex2f(val, phi1);
+      }
    }
 
    // phi grid
    Int_t npb = fPhiAxis->GetNbins();
-   Float_t binLow = 0, binUp;
    for (Int_t i = 1; i <= npb; i++) {
-      binLow = fPhiAxis->GetBinLowEdge(i);
-      binUp =  fPhiAxis->GetBinUpEdge(i);
-      WrapTwoPi(binLow, binUp);
-      if (binLow >= phi0 && binUp <= phi1)
+       val = fPhiAxis->GetBinUpEdge(i);
+      if (val > phi0 && val < phi1)
       {
-         glVertex2f(eta0, binLow);
-         glVertex2f(eta1, binLow);
-         glVertex2f(eta0, binUp);
-         glVertex2f(eta1, binUp);
+         glVertex2f(eta0, val);
+         glVertex2f(eta1, val);
       }
    }
 
@@ -766,7 +755,7 @@ void TEveCaloLegoGL::DrawHistBase(TGLRnrCtx &rnrCtx) const
    // XYZ axes
    //
    glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT | GL_POLYGON_BIT);
-   glLineWidth(2);
+   TGLUtil::LineWidth(2);
    if (fCells3D)
    {
       SetAxis3DTitlePos(rnrCtx, eta0, eta1, phi0, phi1);
@@ -804,37 +793,24 @@ void TEveCaloLegoGL::DrawCells3D(TGLRnrCtx & rnrCtx) const
 }
 
 //______________________________________________________________________________
-void TEveCaloLegoGL::DrawCells2D() const
+void TEveCaloLegoGL::DrawCells2D(TGLRnrCtx & rnrCtx) const
 {
    // Draw projected histogram.
 
-   static const TEveException eh("TEveCaloLegoGL::DrawCells2D ");
-
-   using namespace TMath;
-
-   typedef std::vector<TEveVector>            vTEveVec_t;
-   typedef std::vector<TEveVector>::iterator  vTEveVec_i;
-   typedef std::vector<vTEveVec_t>           vvTEveVec_t;
-   typedef std::vector<vTEveVec_t>::iterator vvTEveVec_i;
-
-   // When kValSize is used, plot gl-points at tower-centers avoid flickering.
-   vvTEveVec_t antiFlick(1);
-   if (fM->f2DMode == TEveCaloLego::kValSize && fM->fTopViewUseMaxColor) {
-      antiFlick.resize(fM->GetData()->GetNSlices());
-   }
+   std::vector<Double_t>  cellGeom;
+   std::vector<Float_t>   sumVal;
+   std::vector<Int_t>     maxSlice;
+   std::vector<Int_t>     id;
 
-   fM->AssertPalette();
+   Int_t max_energy_slice, cellID=0;
+   Float_t sum, max_energy, x1, x2, y1, y2;
 
-   UChar_t col[4];
-   Color_t defCol = fM->GetTopViewTowerColor();
-   if (fBinStep == 1) {
-      // draw in original binning
-      Int_t   name = 0, max_energy_slice;
-      Float_t sum, max_energy, x1 = 0, x2 = 0, y1 = 0, y2 = 0;
-      TGLUtil::Color(defCol);
+   if (fM->fBinStep == 1)
+   {
       TEveCaloData::vCellId_t::iterator currentCell = fM->fCellList.begin();
       TEveCaloData::vCellId_t::iterator nextCell    = currentCell;
       ++nextCell;
+
       while (currentCell != fM->fCellList.end()) {
          TEveCaloData::CellData_t currentCellData;
          TEveCaloData::CellData_t nextCellData;
@@ -842,7 +818,6 @@ void TEveCaloLegoGL::DrawCells2D() const
          fM->fData->GetCellData(*currentCell, currentCellData);
          sum = max_energy = currentCellData.Value(fM->fPlotEt);
          max_energy_slice = currentCell->fSlice;
-
          while (nextCell != fM->fCellList.end() && currentCell->fTower == nextCell->fTower) {
             fM->fData->GetCellData(*nextCell, nextCellData);
             Float_t energy = nextCellData.Value(fM->fPlotEt);
@@ -852,56 +827,25 @@ void TEveCaloLegoGL::DrawCells2D() const
                max_energy_slice = nextCell->fSlice;
             }
             ++nextCell;
+            ++cellID;
          }
 
-         glLoadName(name);
-         glBegin(GL_QUADS);
          WrapTwoPi(currentCellData.fPhiMin, currentCellData.fPhiMax);
-         if (fM->f2DMode == TEveCaloLego::kValColor) {
-            fM->fPalette->ColorFromValue(FloorNint(sum), col);
-            TGLUtil::Color4ubv(col);
-
-            x1 = Max(fM->GetEtaMin(), currentCellData.EtaMin());
-            x2 = Min(fM->GetEtaMax(), currentCellData.EtaMax());
-
-            y1 = Max(fM->GetPhiMin(), currentCellData.PhiMin());
-            y2 = Min(fM->GetPhiMax(), currentCellData.PhiMax());
-         } else if (fM->f2DMode == TEveCaloLego::kValSize) {
-            Double_t scaleFactor = 0;
-            Double_t range = 100;
-            if (range*sum / fDataMax > 1) scaleFactor = Log(range * sum / fDataMax) / Log(range);
-            Float_t etaW = (currentCellData.EtaDelta() * 0.5f) * scaleFactor;
-            Float_t phiW = (currentCellData.PhiDelta() * 0.5f) * scaleFactor;
-
-            x1 = Max(fM->GetEtaMin(), currentCellData.Eta() - etaW);
-            x2 = Min(fM->GetEtaMax(), currentCellData.Eta() + etaW);
-
-            y1 = Max(fM->GetPhiMin(), currentCellData.Phi() - phiW);
-            y2 = Min(fM->GetPhiMax(), currentCellData.Phi() + phiW);
-
-            if (fM->fTopViewUseMaxColor) {
-               TGLUtil::Color(fM->GetData()->GetSliceColor(max_energy_slice));
-               antiFlick[max_energy_slice].push_back(TEveVector(0.5f*(x1 + x2), 0.5f*(y1 + y2), sum));
-            } else {
-               antiFlick[0].push_back(TEveVector(0.5f*(x1 + x2), 0.5f*(y1 + y2), sum));
-            }
-         }
 
-         glVertex3f(x1, y1, sum);
-         glVertex3f(x2, y1, sum);
-         glVertex3f(x2, y2, sum);
-         glVertex3f(x1, y2, sum);
+         cellGeom.push_back(currentCellData.fEtaMin); cellGeom.push_back(currentCellData.fPhiMin);
+         cellGeom.push_back(currentCellData.fEtaMax); cellGeom.push_back(currentCellData.fPhiMax);
 
-         glEnd();
+         sumVal.push_back(sum);
+         maxSlice.push_back(max_energy_slice);
+         id.push_back(cellID);
 
          currentCell = nextCell;
          ++nextCell;
-         ++name;
+         ++cellID;
       }
    }
-   else
-   {
-      // values in the scaled cells
+   else {
+      // get sum value in agragated cells
       const Int_t nEta = fEtaAxis->GetNbins();
       const Int_t nPhi = fPhiAxis->GetNbins();
       std::vector<Float_t> vec;
@@ -912,7 +856,6 @@ void TEveCaloLegoGL::DrawCells2D() const
          max_e.assign((nEta + 2) * (nPhi + 2), 0.f);
          max_e_slice.assign((nEta + 2) * (nPhi + 2), -1);
       }
-
       for (UInt_t bin = 0; bin < fRebinData.fBinData.size(); ++bin) {
          Float_t ssum = 0;
          if (fRebinData.fBinData[bin] != -1) {
@@ -928,14 +871,6 @@ void TEveCaloLegoGL::DrawCells2D() const
          vec[bin] = ssum;
       }
 
-      Float_t maxv = 0;
-      for (UInt_t i = 0; i < vec.size(); ++i)
-         if (vec[i] > maxv) maxv = vec[i];
-
-      Float_t scale    = fM->fData->GetMaxVal(fM->fPlotEt) / maxv;
-      Float_t logMax   = Log(maxv + 1);
-      Float_t scaleLog = fM->fData->GetMaxVal(fM->fPlotEt) / logMax;
-
       // take smallest threshold
       Float_t threshold = fM->GetDataSliceThreshold(0);
       for (Int_t s = 1; s < fM->fData->GetNSlices(); ++s) {
@@ -943,75 +878,143 @@ void TEveCaloLegoGL::DrawCells2D() const
             threshold = fM->GetDataSliceThreshold(s);
       }
 
-      // draw  scaled
-      TGLUtil::Color(defCol);
-      Float_t y0, y1, eta, etaW, phi, phiW;
       for (Int_t i = 1; i <= fEtaAxis->GetNbins(); ++i) {
          for (Int_t j = 1; j <= fPhiAxis->GetNbins(); ++j) {
             const Int_t bin = j * (nEta + 2) + i;
             if (vec[bin] > threshold && fRebinData.fBinData[bin] != -1) {
-               y0 = fPhiAxis->GetBinLowEdge(j);
-               y1 = fPhiAxis->GetBinUpEdge(j);
-               WrapTwoPi(y0, y1);
-
-               const Float_t binVal = vec[bin] * scale;
-               const Float_t logVal = Log(vec[bin] + 1);
-
-               glLoadName(bin);
-               glBegin(GL_QUADS);
-
-               if (fM->f2DMode == TEveCaloLego::kValColor) {
-                  fM->fPalette->ColorFromValue((Int_t)(logVal*scaleLog), col);
-                  TGLUtil::Color4ubv(col);
-
-                  eta  = fEtaAxis->GetBinLowEdge(i);
-                  etaW = fEtaAxis->GetBinWidth(i);
-
-                  glVertex3f(eta     , y0, binVal);
-                  glVertex3f(eta + etaW, y0, binVal);
-                  glVertex3f(eta + etaW, y1, binVal);
-                  glVertex3f(eta     , y1, binVal);
-
-               } else if (fM->f2DMode == TEveCaloLego::kValSize) {
-                  eta  = fEtaAxis->GetBinCenter(i);
-                  etaW = fEtaAxis->GetBinWidth(i) * 0.5f * logVal / logMax;
-                  phi  = 0.5f * (y0 + y1);
-                  phiW = 0.5f * (y1 - y0) * logVal / logMax;
-
-                  if (fM->fTopViewUseMaxColor) {
-                     TGLUtil::Color(fM->GetData()->GetSliceColor(max_e_slice[bin]));
-                     antiFlick[max_e_slice[bin]].push_back(TEveVector(eta, phi, binVal));
-                  } else {
-                     antiFlick[0].push_back(TEveVector(eta, phi, binVal));
-                  }
-
-                  glVertex3f(eta - etaW, phi - phiW, binVal);
-                  glVertex3f(eta + etaW, phi - phiW, binVal);
-                  glVertex3f(eta + etaW, phi + phiW, binVal);
-                  glVertex3f(eta - etaW, phi + phiW, binVal);
-               }
-               glEnd();
+               x1 = fEtaAxis->GetBinLowEdge(i);
+               x2 = fEtaAxis->GetBinUpEdge(i);
+               y1 = fPhiAxis->GetBinLowEdge(j);
+               y2 = fPhiAxis->GetBinUpEdge(j);
+               cellGeom.push_back(x1); cellGeom.push_back(y1);
+               cellGeom.push_back(x2); cellGeom.push_back(y2);
+               sumVal.push_back(vec[bin]);
+               maxSlice.push_back(max_e_slice[bin]);
+               id.push_back(bin);
             }
          }
       }
    }
 
-   if (fM->f2DMode == TEveCaloLego::kValSize) {
-      TGLUtil::Color(defCol);
-      glPointSize(1);
+   //
+   // drawcells
+   //
+
+   if (fM->f2DMode == TEveCaloLego::kValColor ) {
+      fM->AssertPalette();
+      UChar_t col[4];
+
+      for (UInt_t i=0; i < sumVal.size(); i++) {
+         glLoadName(id[i]);
+         glBegin(GL_POLYGON);
+
+         fM->fPalette->ColorFromValue(TMath::FloorNint(sumVal[i]), col);
+         TGLUtil::Color4ubv(col);
+
+         x1 = cellGeom[4*i];
+         y1 = cellGeom[4*i+1];
+         x2 = cellGeom[4*i+2];
+         y2 = cellGeom[4*i+3];
+
+         glVertex3f(x1, y1, 0);
+         glVertex3f(x2, y1, 0);
+         glVertex3f(x2, y2, 0);
+         glVertex3f(x1, y2, 0);
+         glEnd();
+      }
+   }
+   else {
+      // antiflicekring
+      Float_t maxv =0;
+      Float_t x, y;
       glBegin(GL_POINTS);
-      Int_t slice = 0;
-      for (vvTEveVec_i i = antiFlick.begin(); i != antiFlick.end(); ++i, ++slice) {
-         if (fM->fTopViewUseMaxColor)
-            TGLUtil::Color(fM->GetData()->GetSliceColor(slice));
+      for (UInt_t i=0; i< sumVal.size(); i++) {
+         TGLUtil::Color(fM->fData->GetSliceColor(maxSlice[i]));
+         x = 0.5* (cellGeom[4*i] +cellGeom[4*i+2]);
+         y = 0.5* (cellGeom[4*i+1] +cellGeom[4*i+3]);
+         glVertex3f(x, y, sumVal[i]);
+         if (sumVal[i] > maxv) maxv = sumVal[i];
+      }
+      glEnd();
+
+      // scale cells
+      Float_t logMax   = TMath::Log10(maxv + 1);
+
+      // get smallest bin to deduce bin size 
+      Float_t bw = 1e5;
+      for (UInt_t i=0; i< cellGeom.size(); i += 4 ) {
+         if ( cellGeom[i+2] -cellGeom[i] < bw)   bw =  cellGeom[i+2] -cellGeom[i];
+         if ( cellGeom[i+3] -cellGeom[i+1] < bw) bw =  cellGeom[i+3] -cellGeom[i+1];
+      }
+      bw *= 0.5;
+
+      for (UInt_t i=0; i< sumVal.size(); i++) {
+         glLoadName(id[i]);
+         glBegin(GL_POLYGON);
+         TGLUtil::Color(fM->fData->GetSliceColor(maxSlice[i]));
+
+         Float_t bws = bw*TMath::Log10(sumVal[i]+1)/logMax;
+
+         x = 0.5* (cellGeom[4*i] +cellGeom[4*i+2]) ;
+         y = 0.5* (cellGeom[4*i+1] +cellGeom[4*i+3]) ;
+         glVertex3f(x - bws, y - bws, 0);
+         glVertex3f(x + bws, y - bws, 0);
+         glVertex3f(x + bws, y + bws, 0);
+         glVertex3f(x - bws, y + bws, 0);
+
+         glEnd();
+
+      }
+
+      // get value to pixels
+
+      // get projected length of diagonal to determine
+      TGLMatrix mm;
+      GLdouble pm[16];
+      GLint    vp[4];
+      glGetDoublev(GL_MODELVIEW_MATRIX, mm.Arr());
+      glGetDoublev(GL_PROJECTION_MATRIX, pm);
+      glGetIntegerv(GL_VIEWPORT, vp);
+
+      GLdouble dn[3];
+      GLdouble up[3];
+      gluProject(fM->GetEtaMin(), 0, 0, mm.Arr(), pm, vp, &dn[0], &dn[1], &dn[2]);
+      gluProject(fM->GetEtaMax(), 0, 0, mm.Arr(), pm, vp, &up[0], &up[1], &up[2]);
+      Double_t etaLenPix = up[0]-dn[0];
+      Float_t sx = etaLenPix/fM->GetEtaRng();
+
+      TGLUtil::Color(fM->GetFontColor());
+      Float_t llx, lly, llz, urx, ury, urz;
+      Float_t xOff, yOff;
+      TGLFont font;
+      rnrCtx.RegisterFont(TGLFontManager::GetFontSize(fM->fCellPixelFontSize), "arial", TGLFont::kPixmap, font);
+      for (UInt_t i=0; i< sumVal.size(); i++) {
+
+         Float_t bws = bw*TMath::Log10(sumVal[i]+1)/logMax;
+         if (bws*sx >  fM->fDrawNumberCellPixels)
+         {
+            x = 0.5* (cellGeom[4*i] +cellGeom[4*i+2]) ;
+            y = 0.5* (cellGeom[4*i+1] +cellGeom[4*i+3]) ;
+            const char* txt = Form("%.1f", sumVal[i]);
+            xOff = 0;
+            yOff = 0;
+            font.BBox(txt, llx, lly, llz, urx, ury, urz);
+            if (txt[0] == '-')
+               urx += (urx-llx)/strlen(txt);
+            xOff = -0.5 * urx;
+            yOff = -0.5 * (ury -lly);
+            glPushMatrix();
+            glTranslatef(x, y, 0.1);
+            glRasterPos2i(0, 0);
+            glBitmap(0, 0, 0, 0, xOff, yOff, 0);
+            font.Render(txt);
+            glPopMatrix();
 
-         for (vTEveVec_i j = i->begin(); j != i->end(); ++j) {
-            glVertex3fv(j->Arr());
          }
       }
-      glEnd();
    }
-}
+} // end DrawCells2D
+
 //______________________________________________________________________________
 void TEveCaloLegoGL::DirectDraw(TGLRnrCtx & rnrCtx) const
 {
@@ -1042,10 +1045,9 @@ void TEveCaloLegoGL::DirectDraw(TGLRnrCtx & rnrCtx) const
    glScalef(sx / unit, sy / unit, fM->fData->Empty() ? 1 : fM->GetValToHeight());
    glTranslatef(-fM->GetEta(), -fM->fPhi, 0);
 
-
    // rebin axsis , check limits, fix TwoPi cycling
-   Int_t oldBinStep = fBinStep;
-   fBinStep = GetGridStep(rnrCtx);
+   Int_t oldBinStep = fM->fBinStep;
+   fM->fBinStep = GetGridStep(rnrCtx);
    RebinAxis(fM->fData->GetEtaBins(), fEtaAxis);
    RebinAxis(fM->fData->GetPhiBins(), fPhiAxis);
 
@@ -1057,13 +1059,11 @@ void TEveCaloLegoGL::DirectDraw(TGLRnrCtx & rnrCtx) const
    }
 
    // rebin data
-   if (oldBinStep != fBinStep || idCacheChanged) {
-      fDLCacheOK = kFALSE;
-
+   if (fDLCacheOK==kFALSE || oldBinStep != fM->fBinStep || idCacheChanged ) {
       fRebinData.fSliceData.clear();
       fRebinData.fSliceData.clear();
 
-      if (fBinStep > 1) {
+      if (fM->fBinStep > 1) {
          fM->fData->Rebin(fEtaAxis, fPhiAxis, fM->fCellList, fM->fPlotEt, fRebinData);
          if (fM->fNormalizeRebin) {
             Double_t maxVal = 0;
@@ -1084,7 +1084,7 @@ void TEveCaloLegoGL::DirectDraw(TGLRnrCtx & rnrCtx) const
 
    if (!fM->fData->Empty()) {
       glPushAttrib(GL_LINE_BIT | GL_POLYGON_BIT);
-      glLineWidth(1);
+      TGLUtil::LineWidth(1);
       glDisable(GL_LIGHTING);
       glEnable(GL_NORMALIZE);
       glEnable(GL_POLYGON_OFFSET_FILL);
@@ -1096,7 +1096,7 @@ void TEveCaloLegoGL::DirectDraw(TGLRnrCtx & rnrCtx) const
          if (!fDLCacheOK) MakeDisplayList();
          DrawCells3D(rnrCtx);
       } else {
-         DrawCells2D();
+         DrawCells2D(rnrCtx);
       }
       glPopName();
       glPopAttrib();
@@ -1122,7 +1122,6 @@ void TEveCaloLegoGL::DirectDraw(TGLRnrCtx & rnrCtx) const
          glPopAttrib();
       }
    }
-
    glPopMatrix();
 }
 
@@ -1132,29 +1131,44 @@ void TEveCaloLegoGL::ProcessSelection(TGLRnrCtx & /*rnrCtx*/, TGLSelectRecord &
    // Processes secondary selection from TGLViewer.
 
    if (rec.GetN() < 2) return;
-   Int_t cellID = rec.GetItem(1);
 
-   if (fBinStep == 1) {
+   if (fM->fBinStep == 1) {
+      Int_t cellID = rec.GetItem(1);
       TEveCaloData::CellData_t cellData;
       fM->fData->GetCellData(fM->fCellList[cellID], cellData);
+      printf(">> Selected cell in eta %f phi %f \n", cellData.Eta(), cellData.Phi());
 
       if (fCells3D) {
-         printf("Bin %d selected in slice %d val %f\n",
+         printf("Tower %d in slice %d val %f\n",
                 fM->fCellList[cellID].fTower,
                 fM->fCellList[cellID].fSlice, cellData.fValue);
       } else {
-         printf("Bin %d selected\n", fM->fCellList[cellID].fTower);
+         printf("Tower %d in slice %d val %f\n",
+                fM->fCellList[cellID].fTower,
+                fM->fCellList[cellID].fSlice, cellData.fValue);
       }
+
    } else {
-      if (fCells3D) {
-         Float_t* v = fRebinData.GetSliceVals(rec.GetItem(2));
-         Int_t s = rec.GetItem(1);
-         printf("Rebined bin %d selected in slice %d val %f\n", rec.GetItem(2), s, v[s]);
-      } else {
-         Float_t* v = fRebinData.GetSliceVals(rec.GetItem(1));
-         printf("Rebined bin %d selected\n", rec.GetItem(1));
-         for (Int_t s = 0; s < 2; s++) {
-            printf("slice %d val %f\n", s, v[s]);
+      Int_t cellID = fCells3D ? rec.GetItem(2) : rec.GetItem(1);
+      if (cellID)
+      {
+         Int_t nEta   = fEtaAxis->GetNbins();
+         Int_t phiBin = Int_t(cellID/(nEta+2));
+         Int_t etaBin = cellID - phiBin*(nEta+2);
+         Float_t* v = fRebinData.GetSliceVals(cellID);
+
+         printf(">> Selected cell in eta %f phi %f \n", fEtaAxis->GetBinCenter(etaBin), fPhiAxis->GetBinCenter(phiBin));
+
+         if (fCells3D) {
+            Int_t s = rec.GetItem(1);
+            printf("Tower %d slice %d val %f \n", rec.GetItem(2), s, v[s]);
+         }
+         else
+         {
+            printf("Tower %d vals: \n", cellID);
+            for (Int_t s = 0; s < fRebinData.fNSlices; s++) {
+               printf("slice %d val %f\n", s, v[s]);
+            }
          }
       }
    }
diff --git a/graf3d/eve/src/TEveCaloLegoOverlay.cxx b/graf3d/eve/src/TEveCaloLegoOverlay.cxx
index 8ac1f1d..044acb8 100644
--- a/graf3d/eve/src/TEveCaloLegoOverlay.cxx
+++ b/graf3d/eve/src/TEveCaloLegoOverlay.cxx
@@ -22,6 +22,7 @@
 
 #include "TEveCalo.h"
 #include "TEveCaloData.h"
+#include <KeySymbols.h>
 
 
 //______________________________________________________________________________
@@ -36,84 +37,182 @@ ClassImp(TEveCaloLegoOverlay);
 //______________________________________________________________________________
 TEveCaloLegoOverlay::TEveCaloLegoOverlay() :
    TGLCameraOverlay(),
-   TEveElementList("Lego Menu", "TEveCaloLegoOverlay", kTRUE),
-   fHeaderSelected(kFALSE),
 
    fCalo(0),
-   fSliderAxis(0),
-   fMainColor(kGray),
 
-   fShowCamera(kTRUE),
+   fShowScales(kTRUE),
+   fScaleColor(kWhite), fScaleTransparency(0),
+   fScaleCoordX(0.8), fScaleCoordY(0.2),
+   fCellX(-1), fCellY(-1),
+
+   fFrameColor(kGray), fFrameLineTransp(0), fFrameBgTransp(90),
+
+   fMouseX(0),  fMouseY(0),
+   fInDrag(kFALSE),
+
+   fHeaderSelected(kFALSE),
+
+   fPlaneAxis(0), fAxisPlaneColor(kGray),
    fShowPlane(kFALSE),
 
    fMenuW(0.08),
    fButtonW(0.5),
+   fShowSlider(kFALSE),
    fSliderH(0.6),
    fSliderPosY(0.15),
-
-   fShowSlider(kFALSE),
    fSliderVal(0),
 
-   fActiveID(-1),
-   fActiveCol(kRed-4)
+   fActiveID(-1), fActiveCol(kRed-4)
 {
    // Constructor.
-  fMainColorPtr = &fMainColor;
-  fSliderAxis = new TAxis();
 
+   fPlaneAxis = new TAxis();
 }
 
-
 /******************************************************************************/
-void TEveCaloLegoOverlay::DrawSlider(TGLRnrCtx& rnrCtx)
+// Virtual event handlers from TGLOverlayElement
+/******************************************************************************/
+
+Bool_t TEveCaloLegoOverlay::SetSliderVal(Event_t* event, TGLRnrCtx &rnrCtx)
 {
-   // Draw slider and calorimeter Z scale on left side of screen.
+   // Set height of horizontal plane in the calorimeter.
 
-   glTranslatef(0, fSliderPosY, 0.5);
+   TGLRect& wprt = rnrCtx.RefCamera().RefViewport();
+   fSliderVal = (1 -event->fY*1./wprt.Height() -fSliderPosY)/fSliderH;
 
-   // event handler
-   if (rnrCtx.Selection())
+   if (fSliderVal < 0 )
+      fSliderVal = 0;
+   else if (fSliderVal > 1)
+      fSliderVal = 1;
+
+   fCalo->SetHPlaneVal(fSliderVal);
+
+   return kTRUE;
+}
+
+//______________________________________________________________________________
+Bool_t TEveCaloLegoOverlay::Handle(TGLRnrCtx          & rnrCtx,
+                                   TGLOvlSelectRecord & selRec,
+                                   Event_t            * event)
+{
+   // Handle overlay event.
+   // Return TRUE if event was handled.
+
+   if (selRec.GetN() < 2) return kFALSE;
+
+   switch (event->fType)
    {
-      glLoadName(2);
-      Float_t w = fButtonW*fMenuW*0.5f;
-      glBegin(GL_QUADS);
-      glVertex2f(-w, 0);
-      glVertex2f( w, 0);
-      glVertex2f( w, fSliderH);
-      glVertex2f(-w, fSliderH);
-      glEnd();
+      case kButtonPress:
+      {
+         fMouseX = event->fX;
+         fMouseY = event->fY;
+         fInDrag = kTRUE;
+         return kTRUE;
+      }
+      case kButtonRelease:
+      {
+         fInDrag = kFALSE;
+         return kTRUE;
+      }
+      case kMotionNotify:
+      {
+         if (fInDrag)
+         {
+            const TGLRect& vp = rnrCtx.RefCamera().RefViewport();
+            fScaleCoordX += (Float_t)(event->fX - fMouseX) / vp.Width();
+            fScaleCoordY -= (Float_t)(event->fY - fMouseY) / vp.Height();
+            fMouseX = event->fX;
+            fMouseY = event->fY;
+         }
+         return kTRUE;
+      }
+      default:
+      {
+         return kFALSE;
+      }
    }
+}
 
-   // render
-   if ( fCalo->GetData() && fCalo->GetData()->Empty() == kFALSE)
-   {
-      // slider axis
-      Double_t maxVal = fCalo->GetMaxVal();
-      fAxisPainter->SetLabelPixelFontSize(TMath::CeilNint(rnrCtx.GetCamera()->RefViewport().Height()*0.06));
-      fAxisPainter->RefDir().Set(0, 1, 0);
-      fAxisPainter->RefTMOff(0).Set(1, 0, 0);
-      fAxisPainter->SetLabelAlign(TGLFont::kLeft);
-      fSliderAxis->SetRangeUser(0, maxVal);
-      fSliderAxis->SetLimits(0, maxVal);
-      fSliderAxis->SetNdivisions(710);
-      fSliderAxis->SetTickLength(0.02*maxVal);
-      fSliderAxis->SetLabelOffset(0.02*maxVal);
-      fSliderAxis->SetLabelSize(0.05);
-      fSliderAxis->SetAxisColor(fMainColor);
-      fSliderAxis->SetLabelColor(fMainColor);
+//______________________________________________________________________________
+Bool_t TEveCaloLegoOverlay::MouseEnter(TGLOvlSelectRecord& /*rec*/)
+{
+   // Mouse has entered overlay area.
 
-      glPushMatrix();
-      glScalef(fSliderH/maxVal, fSliderH/maxVal, 1.);
-      fAxisPainter->PaintAxis(rnrCtx, fSliderAxis);
-      glPopMatrix();
+   return kTRUE;
+}
 
-      // marker
-      TGLUtil::Color((fActiveID == 2) ? fActiveCol : 3);
-      glPointSize(8);
-      glBegin(GL_POINTS);
-      glVertex3f(0, fSliderVal*fSliderH, -0.1);
+ //______________________________________________________________________________
+void TEveCaloLegoOverlay::MouseLeave()
+{
+   // Mouse has left overlay area.
+
+   fActiveID = -1;
+}
+
+//______________________________________________________________________________
+void TEveCaloLegoOverlay::SetScaleColorTransparency(Color_t colIdx, UChar_t transp)
+{
+   // Set color and transparency of scales.
+
+   fScaleColor = colIdx;
+   fScaleTransparency = transp;
+}
+
+//______________________________________________________________________________
+void TEveCaloLegoOverlay::SetScalePosition(Double_t x, Double_t y)
+{
+   // Set scale coordinates in range [0,1]. 
+
+   fScaleCoordX = x;
+   fScaleCoordY = y;
+}
+
+//______________________________________________________________________________
+void TEveCaloLegoOverlay:: SetFrameAttribs(Color_t frameColor, UChar_t lineTransp, UChar_t bgTransp)
+{
+   // Set frame attribs.
+   
+   fFrameColor = frameColor;
+   fFrameLineTransp = lineTransp;
+   fFrameBgTransp = bgTransp;
+}
+
+//==============================================================================
+void TEveCaloLegoOverlay::RenderHeader(TGLRnrCtx& rnrCtx)
+{
+   // Render text on top right corner of the screen.
+
+   TGLRect &vp = rnrCtx.GetCamera()->RefViewport();
+
+   TGLFont font;
+   Int_t fs = TGLFontManager::GetFontSize(vp.Height()*0.035, 12, 36);
+   rnrCtx.RegisterFont(fs, "arial", TGLFont::kPixmap, font);
+   font.PreRender();
+   Float_t off = fs*0.2;
+   Float_t bb[6];
+   font.BBox(fHeaderTxt.Data(), bb[0], bb[1], bb[2], bb[3], bb[4], bb[5]);
+   Float_t x = vp.Width()  -bb[3] -off;
+   Float_t y = vp.Height() -bb[4] -off;
+   if (rnrCtx.Selection())
+   {
+      glPushName(0);
+      glLoadName(3);
+      glBegin(GL_QUADS);
+      glVertex2f(x/vp.Width(), y/ vp.Height());
+      glVertex2f(1,  y/ vp.Height());
+      glVertex2f(1, 1);
+      glVertex2f(x/vp.Width(), 1);
       glEnd();
+      glPopName();
    }
+   else
+   {
+      TGLUtil::Color(fHeaderSelected ? fActiveCol : fCalo->GetFontColor());
+      glRasterPos2i(0, 0);
+      glBitmap(0, 0, 0, 0, x, y, 0);
+      font.Render(fHeaderTxt.Data());
+   }
+   font.PostRender();
 }
 
 //______________________________________________________________________________
@@ -133,14 +232,14 @@ void TEveCaloLegoOverlay::RenderPlaneInterface(TGLRnrCtx &rnrCtx)
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glPushName(0);
 
-
    // move to the center of menu
-   glPushMatrix();
-   glTranslatef(1 -fMenuW, 0, 0); // translate to lower left corner
+   Double_t maxVal = fCalo->GetMaxVal();
+   glScalef(fSliderH/(maxVal), fSliderH/maxVal, 1.);
 
    // button
    glPushMatrix();
    glTranslatef(0, (1-fButtonW )*fMenuW*0.8, 0);
+
    glLoadName(1);
    Float_t a=0.6;
    (fActiveID == 1) ? TGLUtil::Color(fActiveCol):TGLUtil::Color4f(0, 1, 0, a);
@@ -156,212 +255,311 @@ void TEveCaloLegoOverlay::RenderPlaneInterface(TGLRnrCtx &rnrCtx)
 
    TGLUtil::Color(4);
 
-   glLineWidth(1);
+   TGLUtil::LineWidth(1);
    glBegin(GL_LINES);
    glVertex2f(0, 0); glVertex2f(0, bh);
    glVertex2f((bw+bwt)*0.5, bh*0.5); glVertex2f(-(bw+bwt)*0.5, bh*0.5);
    glEnd();
 
-   glLineWidth(2);
+   TGLUtil::LineWidth(2);
    glBegin(GL_LINE_LOOP);
    glVertex2f(-bw, 0);
    glVertex2f( bw, 0);
    glVertex2f( bwt, bh);
    glVertex2f(-bwt, bh);
    glEnd();
-   glLineWidth(1);
+   TGLUtil::LineWidth(1);
 
-   glPopMatrix();
-   if (fShowSlider) DrawSlider(rnrCtx);
+   glTranslatef(0, fSliderPosY, 0.5);
+
+   if (fShowSlider)
+   {
+      // event handler
+      if (rnrCtx.Selection())
+      {
+         glLoadName(2);
+         Float_t w = fButtonW*fMenuW*0.5f;
+         glBegin(GL_QUADS);
+         glVertex2f(-w, 0);
+         glVertex2f( w, 0);
+         glVertex2f( w, fSliderH);
+         glVertex2f(-w, fSliderH);
+         glEnd();
+      }
+
+      // slider axis
+      glPushMatrix();
+      fAxisPainter->SetLabelPixelFontSize(TMath::CeilNint(rnrCtx.GetCamera()->RefViewport().Height()*GetAttAxis()->GetLabelSize()));
+      fAxisPainter->RefDir().Set(0, 1, 0);
+      fAxisPainter->RefTMOff(0).Set(1, 0, 0);
+      fAxisPainter->SetLabelAlign(TGLFont::kLeft);
+      fPlaneAxis->SetRangeUser(0, maxVal);
+      fPlaneAxis->SetLimits(0, maxVal);
+      fPlaneAxis->SetNdivisions(710);
+      fPlaneAxis->SetTickLength(0.02*maxVal);
+      fPlaneAxis->SetLabelOffset(0.02*maxVal);
+      fPlaneAxis->SetLabelSize(0.05);
+      fPlaneAxis->SetAxisColor(fAxisPlaneColor);
+      fPlaneAxis->SetLabelColor(fAxisPlaneColor);
+
+      glPushMatrix();
+      glScalef(fSliderH/(maxVal), fSliderH/maxVal, 1.);
+      fAxisPainter->PaintAxis(rnrCtx, fPlaneAxis);
+      glPopMatrix();
+
+      // marker
+      TGLUtil::Color((fActiveID == 2) ? fActiveCol : 3);
+      TGLUtil::PointSize(8);
+      glBegin(GL_POINTS);
+      glVertex3f(0, fSliderVal*fSliderH, -0.1);
+      glEnd();
+   }
 
    glPopName();
    glPopAttrib();
-
    glPopMatrix();
-
 }
 
 /******************************************************************************/
-void TEveCaloLegoOverlay::RenderHeader(TGLRnrCtx& rnrCtx)
+void TEveCaloLegoOverlay::RenderScales(TGLRnrCtx& rnrCtx)
 {
-   // Render text on top right corner of the screen.
+   // Draw slider of calo 2D.
+
+   // scale position
 
    TGLRect &vp = rnrCtx.GetCamera()->RefViewport();
 
-   TGLFont font;
-   Int_t fs = TGLFontManager::GetFontSize(vp.Height()*0.035, 12, 36);
-   rnrCtx.RegisterFont(fs, "arial", TGLFont::kPixmap, font);
-   Float_t off = fs*0.2;
-   Float_t bb[6];
-   font.BBox(fHeaderTxt.Data(), bb[0], bb[1], bb[2], bb[3], bb[4], bb[5]);
-   Float_t x = vp.Width() -bb[3] -off;
-   Float_t y = vp.Height() -bb[4] -off;
-   if (rnrCtx.Selection())
-   {
-      glPushName(0);
-      glLoadName(3);
-      glBegin(GL_QUADS);
-      glVertex2f(x/vp.Width(), y/ vp.Height());
-      glVertex2f(1,  y/ vp.Height());
-      glVertex2f(1, 1);
-      glVertex2f(x/vp.Width(), 1);
-      glEnd();
-      glPopName();
-   }
-   else
-   {
-      TGLUtil::Color(fHeaderSelected ? fActiveCol : fCalo->GetFontColor());
-      glRasterPos2i(0, 0);
-      glBitmap(0, 0, 0, 0, x, y, 0);
-      font.Render(fHeaderTxt.Data());
-   }
-}
+   Double_t maxVal = fCalo->GetMaxVal();
+   Int_t maxe = TMath::CeilNint(TMath::Log10(maxVal+1)); // max round exponent
+   Double_t sqv = TMath::Power(10, maxe)+1; // starting max square value
+   Double_t fc = TMath::Log10(sqv)/TMath::Log10(fCalo->GetMaxVal()+1);
+   Double_t cellX = fCellX*fc;
+   Double_t cellY = fCellY*fc;
 
-/******************************************************************************/
-void TEveCaloLegoOverlay::Render(TGLRnrCtx& rnrCtx)
-{
-   // Render the overlay elements.
+   Double_t scaleStepY = 0.1; // step is 10% of screen
+   Double_t scaleStepX =  scaleStepY*vp.Height()/vp.Width(); // step is 10% of screen
+  
 
-   if (fShowPlane || fHeaderTxt.Length())
+   // define max starting exponent not to take more than scalStepY height
+   while(cellY > scaleStepY)
    {
-      // go to normalised coordinates
-      glMatrixMode(GL_PROJECTION);
-      glPushMatrix();
-      glLoadIdentity();
-      if (rnrCtx.Selection())
-      {
-         TGLRect rect(*rnrCtx.GetPickRectangle());
-         rnrCtx.GetCamera()->WindowToViewport(rect);
-         gluPickMatrix(rect.X(), rect.Y(), rect.Width(), rect.Height(), rnrCtx.RefCamera().RefViewport().CArr());
-      }
-      glMatrixMode(GL_MODELVIEW);
-      glPushMatrix();
-      glLoadIdentity();
+      fc = TMath::Log10(TMath::Power(10, maxe-1)+1)/TMath::Log10(TMath::Power(10, maxe)+1);
+      maxe --;
+      cellX *= fc;
+      cellY *= fc;
+   }
 
-      glTranslatef(-1, -1, 0);
+   sqv =  TMath::Power(10, maxe)+1;
+   glPushMatrix();
+   glTranslatef(fScaleCoordX, fScaleCoordY, 0); // translate to lower left corner
 
-      glScalef(2, 2, 1);
-      if (fShowPlane) RenderPlaneInterface(rnrCtx);
-      RenderHeader(rnrCtx);
+   glPushAttrib(GL_ENABLE_BIT | GL_POLYGON_BIT | GL_LINE_BIT | GL_POINT_BIT);
+   glEnable(GL_BLEND);
+   glDisable(GL_CULL_FACE);
+   glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+   glEnable(GL_POLYGON_OFFSET_FILL);
+   glPolygonOffset(0.1, 1);
+
+   // draw cells
+   TGLUtil::ColorTransparency(fScaleColor, fScaleTransparency);
+   Float_t pos, dx, dy;
+   glBegin(GL_QUADS);
+   Int_t ne = 3; // max number of columns
+   for (Int_t i=0; i < ne; ++i)
+   { 
+      Float_t valFac = TMath::Log10(TMath::Power(10, maxe-i)+1)/TMath::Log10(sqv);
+      dx = 0.5* cellX * valFac;
+      dy = 0.5* cellY * valFac;
+      pos = i* scaleStepY;
+      dx = 0.5* cellX * TMath::Power(10, -i);
+      dy = 0.5* cellY * TMath::Power(10, -i);
+      glVertex2f( - dx, pos - dy);
+      glVertex2f( - dx, pos + dy);
+      glVertex2f( + dx, pos + dy);
+      glVertex2f( + dx, pos - dy);
 
-      glPopMatrix();
-      glMatrixMode(GL_PROJECTION);
-      glPopMatrix();
-      glMatrixMode(GL_MODELVIEW);
    }
+   glEnd();
 
+   // draw points in case suare is below pixels
+   glBegin(GL_POINTS);
+   for (Int_t i=0; i < ne; ++i)
+      glVertex2f(0, i* scaleStepY);
+   glEnd();
 
-   // call TGLCamera overlay render
-   if (fShowCamera)
+   // draw numbers 
+   TGLUtil::Color(fScaleColor);
+   TGLFont fontB;
+   Int_t fsb = TGLFontManager::GetFontSize(vp.Height()*0.03, 12, 36);
+   rnrCtx.RegisterFont(fsb, "arial", TGLFont::kPixmap, fontB);
+   TGLFont fontE;
+   Int_t fsE = TGLFontManager::GetFontSize(vp.Height()*0.008, 8, 36);
+   rnrCtx.RegisterFont(fsE, "arial", TGLFont::kPixmap, fontE);
+
+   Float_t llx, lly, llz, urx, ury, urz;
+   fontB.BBox("10", llx, lly, llz, urx, ury, urz);
+   Float_t expX = urx/vp.Width();
+   Float_t expY = (ury-lly)*0.5/vp.Height();
+   Float_t expOff = 1;
+   fontB.PreRender();
+   fontE.PreRender();
+   glPushMatrix();
+   glTranslatef(0.5*scaleStepX, 0, 0.1);
+   for (Int_t i = 0; i < ne; ++i)
    {
-      TGLCamera& cam = rnrCtx.RefCamera();
-      TGLRect& vp = cam.RefViewport();
-      Bool_t skip = kFALSE;
-      // check if lego axis are already visible
-      if (cam.IsOrthographic())
+      if (i == maxe)
       {
-         using namespace TMath;
-
-         Float_t x0 = fCalo->GetEtaMin();
-         Float_t y0 = fCalo->GetPhiMin();
-
-         const GLdouble *pm = rnrCtx.RefCamera().RefLastNoPickProjM().CArr();
-         GLdouble mm[16];
-         glGetDoublev(GL_MODELVIEW_MATRIX,  mm);
-
-         GLdouble x, y, z;
-         gluProject(x0, y0, 0, mm, pm, (Int_t*)vp.CArr(), &x, &y, &z);
-         // viewport height goes from top to bottom
-         if ( x > vp.Left() && y > vp.Top())
-            skip = kTRUE;
+         fontB.RenderBitmap("1", 0, i*scaleStepY, 0, TGLFont::kLeft);
+      }
+      else if ( i == (maxe -1))
+      {
+         fontB.RenderBitmap("10", 0, i*scaleStepY, 0, TGLFont::kLeft);
       }
+      else
+      {
+         fontB.RenderBitmap("10", 0, i*scaleStepY, 0, TGLFont::kLeft);
+         fontB.BBox(Form("%d",  maxe-i), llx, lly, llz, urx, ury, urz);
+         if (expOff >  urx/vp.Width()) expOff = urx/vp.Width();
+         fontE.RenderBitmap(Form("%d",  maxe-i), expX , i*scaleStepY+expY, 0, TGLFont::kLeft );
+      }
+   }
+   glPopMatrix();
+   fontB.PostRender();
+   fontE.PostRender();
+   if (expOff < 1)  expX += expOff;
 
-      if (!skip) TGLCameraOverlay::Render(rnrCtx);
+   // draw frame
+   {
+      Double_t off = 0.1;
+      Double_t x0 = -(0.5+off) * scaleStepX;
+      Double_t x1 = (0.5+off) * scaleStepX + expX;
+      Double_t y0 = -(0.5+off) * scaleStepY; 
+      Double_t y1 = scaleStepY*(ne - 0.5 + off);
+      Double_t zf = -0.2;
+
+      TGLUtil::ColorTransparency(fFrameColor, fFrameLineTransp);
+      glBegin(GL_LINE_LOOP);
+      glVertex3f(x0, y0, zf); glVertex3f(x1, y0, zf);
+      glVertex3f(x1, y1, zf); glVertex3f(x0, y1, zf);
+      glEnd();
+
+      TGLUtil::ColorTransparency(fFrameColor, fFrameBgTransp);
+      glPushName(0);
+      glLoadName(1);
+      glBegin(GL_QUADS);
+      glVertex2f(x0, y0); glVertex2f(x1, y0);
+      glVertex2f(x1, y1); glVertex2f(x0, y1);
+      glEnd();
+      glPopName();
    }
-}
+   
+   glPopMatrix();
+   glPopAttrib();
+} // end draw scales
 
-/******************************************************************************/
-// Virtual event handlers from TGLOverlayElement
-/******************************************************************************/
+ /******************************************************************************/
 
-Bool_t TEveCaloLegoOverlay::SetSliderVal(Event_t* event, TGLRnrCtx &rnrCtx)
+void TEveCaloLegoOverlay::Render(TGLRnrCtx& rnrCtx)
 {
-   // Set height of horizontal plane in the calorimeter.
+   // Draw calorimeter scale info and plane interface.
 
-   TGLRect& wprt = rnrCtx.RefCamera().RefViewport();
-   fSliderVal = (1 -event->fY*1./wprt.Height() -fSliderPosY)/fSliderH;
+   if ( fCalo == 0 || fCalo->GetData()->Empty()) return;
 
-   if (fSliderVal < 0 )
-      fSliderVal = 0;
-   else if (fSliderVal > 1)
-      fSliderVal = 1;
+   Float_t old_depth_range[2];
+   glGetFloatv(GL_DEPTH_RANGE, old_depth_range);
+   glDepthRange(0, 0.001);
 
-   fCalo->SetHPlaneVal(fSliderVal);
+   glMatrixMode(GL_PROJECTION);
+   glPushMatrix();
+   glLoadIdentity();
+   if (rnrCtx.Selection())
+   {
+      TGLRect rect(*rnrCtx.GetPickRectangle());
+      rnrCtx.GetCamera()->WindowToViewport(rect);
+      gluPickMatrix(rect.X(), rect.Y(), rect.Width(), rect.Height(),
+                    (Int_t*) rnrCtx.GetCamera()->RefViewport().CArr());
+   }
+   glMatrixMode(GL_MODELVIEW);
+   glPushMatrix();
+   glLoadIdentity();
 
-   return kTRUE;
-}
+   glTranslatef(-1, -1, 0);
+   glScalef(2, 2, 1);
 
-//______________________________________________________________________________
-Bool_t TEveCaloLegoOverlay::Handle(TGLRnrCtx          & rnrCtx,
-                               TGLOvlSelectRecord & rec,
-                               Event_t            * event)
-{
-   // Handle overlay event.
-   // Return TRUE if event was handled.
+   TGLCamera& cam = rnrCtx.RefCamera();
+   Bool_t drawOverlayAxis = kFALSE;
 
-   switch (event->fType)
+   if (cam.IsOrthographic())
    {
-      case kMotionNotify:
-      {
-         Int_t item = rec.GetN() < 2 ? -1 : (Int_t)rec.GetItem(1);
-         if (fActiveID != item) {
-            fActiveID = item;
-            return kTRUE;
-         } else {
-            if (fActiveID == 2 && event->fState == 256)
-               return SetSliderVal(event, rnrCtx);
-
-            return kFALSE;
-         }
-         break;
-      }
-      case kButtonPress:
+      // in 2D need pixel cell dimension
+      // project lego eta-phi boundraries
+      TGLVector3 rng(fCalo->GetEtaRng(), fCalo->GetPhiRng(), 0);
+      TGLVertex3 p;
+      TGLVector3 res = cam.WorldDeltaToViewport(p, rng);
+
+      if (fShowScales)
       {
-         if (event->fCode != kButton1) {
-            return kFALSE;
+         // get smallest bin
+         Double_t sq = 1e4;
+         if (fCalo->fBinStep == 1)
+         {
+            TEveCaloData::CellData_t cellData;
+            for ( TEveCaloData::vCellId_t::iterator i = fCalo->fCellList.begin(); i != fCalo->fCellList.end(); ++i)
+            {
+               fCalo->fData->GetCellData(*i, cellData);
+               if (sq > cellData.EtaDelta()) sq = cellData.EtaDelta();
+               if (sq > cellData.PhiDelta()) sq = cellData.PhiDelta();
+            }
          }
-         switch (rec.GetItem(1))
+         else
          {
-            case 1:
-               fShowSlider = !fShowSlider;
-               fCalo->SetDrawHPlane(fShowSlider);
-               break;
-            case 2:
-               return SetSliderVal(event, rnrCtx);
-            case 3:
-               fHeaderSelected = !fHeaderSelected;
-            default:
-               break;
+            TAxis* a;
+            Int_t nb;
+            a = fCalo->GetData()->GetEtaBins();
+            nb = a->GetNbins();
+            for (Int_t i=1 ; i<=nb; i++)
+            {
+               if (sq > a->GetBinWidth(i)) sq = a->GetBinWidth(i);
+            }
+
+            a = fCalo->GetData()->GetPhiBins();
+            nb = a->GetNbins();
+            for (Int_t i=1 ; i<=nb; i++)
+            {
+               if (sq > a->GetBinWidth(i)) sq = a->GetBinWidth(i);
+            }
+
+            sq *= fCalo->fBinStep;
          }
+         fCellX = (res.X()*sq)/(fCalo->GetEtaRng()*1.*cam.RefViewport().Width());
+         fCellY = (res.Y()*sq)/(fCalo->GetPhiRng()*1.*cam.RefViewport().Height());
+         // printf("bin width %f cells size %f %f\n", sq, fCellX, fCellY);
+
+         RenderScales(rnrCtx);
       }
-      default:
-         break;
+
+      // draw camera overlay if projected lego bbox to large
+      if (res.X() > cam.RefViewport().Width()*0.8 || res.Y() > cam.RefViewport().Height()*0.8)
+         drawOverlayAxis = kTRUE;
    }
-   return kFALSE;
-}
 
-//______________________________________________________________________________
-Bool_t TEveCaloLegoOverlay::MouseEnter(TGLOvlSelectRecord& /*rec*/)
-{
-   // Mouse has entered overlay area.
+   if (cam.IsPerspective() && fShowPlane)
+   {
+      RenderPlaneInterface(rnrCtx);
+   }
 
-   return kTRUE;
-}
+   // draw info text on yop right corner
+   if (fHeaderTxt.Length())
+   {
+      RenderHeader(rnrCtx);
+   }
 
-//______________________________________________________________________________
-void TEveCaloLegoOverlay::MouseLeave()
-{
-   // Mouse has left overlay area.
+   glPopMatrix();
+   glMatrixMode(GL_PROJECTION);
+   glPopMatrix();
+   glMatrixMode(GL_MODELVIEW);
 
-   fActiveID = -1;
+   glDepthRange(old_depth_range[0], old_depth_range[1]);
+
+   if (drawOverlayAxis) TGLCameraOverlay::Render(rnrCtx);
 }
diff --git a/graf3d/eve/src/TEveElement.cxx b/graf3d/eve/src/TEveElement.cxx
index 4fd8c71..8024dc3 100644
--- a/graf3d/eve/src/TEveElement.cxx
+++ b/graf3d/eve/src/TEveElement.cxx
@@ -22,7 +22,6 @@
 #include "TPRegexp.h"
 #include "TROOT.h"
 #include "TColor.h"
-#include "TCanvas.h"
 #include "TEveBrowser.h"
 #include "TGListTree.h"
 #include "TGPicture.h"
diff --git a/graf3d/eve/src/TEveFrameBoxGL.cxx b/graf3d/eve/src/TEveFrameBoxGL.cxx
index 729f071..f9181fd 100644
--- a/graf3d/eve/src/TEveFrameBoxGL.cxx
+++ b/graf3d/eve/src/TEveFrameBoxGL.cxx
@@ -98,7 +98,7 @@ void TEveFrameBoxGL::Render(const TEveFrameBox* box)
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glEnable(GL_LINE_SMOOTH);
 
-   glLineWidth(b.fFrameWidth);
+   TGLUtil::LineWidth(b.fFrameWidth);
    TGLUtil::Color4ubv(b.fFrameRGBA);
    RenderFrame(b, b.fFrameFill);
 
diff --git a/graf3d/eve/src/TEveGedEditor.cxx b/graf3d/eve/src/TEveGedEditor.cxx
index f70dba1..3cd12cb 100644
--- a/graf3d/eve/src/TEveGedEditor.cxx
+++ b/graf3d/eve/src/TEveGedEditor.cxx
@@ -14,8 +14,6 @@
 #include "TEveManager.h"
 
 #include "TGedFrame.h"
-#include "TGCanvas.h"
-#include "TCanvas.h"
 
 #include "TClass.h"
 
diff --git a/graf3d/eve/src/TEveGeoNode.cxx b/graf3d/eve/src/TEveGeoNode.cxx
index b60cc2f..657916e 100644
--- a/graf3d/eve/src/TEveGeoNode.cxx
+++ b/graf3d/eve/src/TEveGeoNode.cxx
@@ -21,7 +21,6 @@
 #include "TGLFaceSet.h"
 
 #include "TROOT.h"
-#include "TPad.h"
 #include "TBuffer3D.h"
 #include "TVirtualViewer3D.h"
 #include "TColor.h"
diff --git a/graf3d/eve/src/TEveGeoShape.cxx b/graf3d/eve/src/TEveGeoShape.cxx
index 12814ec..db35148 100644
--- a/graf3d/eve/src/TEveGeoShape.cxx
+++ b/graf3d/eve/src/TEveGeoShape.cxx
@@ -14,13 +14,9 @@
 #include "TEvePolygonSetProjected.h"
 
 #include "TEveGeoShapeExtract.h"
-#include "TEvePad.h"
 #include "TEveGeoPolyShape.h"
-#include "TGLScenePad.h"
-#include "TGLFaceSet.h"
 
 #include "TROOT.h"
-#include "TPad.h"
 #include "TBuffer3D.h"
 #include "TVirtualViewer3D.h"
 #include "TColor.h"
@@ -62,10 +58,16 @@ TGeoManager* init_geo_mangeur()
 //
 // Wrapper for TGeoShape with absolute positioning and color
 // attributes allowing display of extracted TGeoShape's (without an
-// active TGeoManager) and simplified geometries (needed for NLT
+// active TGeoManager) and simplified geometries (needed for non-linear
 // projections).
 //
 // TGeoCompositeShapes and TGeoAssemblies are supported.
+//
+// If fNSegments data-member is < 2 (0 by default), the default number of
+// segments is used for tesselation and special GL objects are
+// instantiated for selected shapes (spheres, tubes). If fNSegments is > 2,
+// it gets forwarded to geo-manager and this tesselation detail is
+// used when creating the buffer passed to GL.
 
 ClassImp(TEveGeoShape);
 
diff --git a/graf3d/eve/src/TEveLegoEventHandler.cxx b/graf3d/eve/src/TEveLegoEventHandler.cxx
index f5679e8..1762819 100644
--- a/graf3d/eve/src/TEveLegoEventHandler.cxx
+++ b/graf3d/eve/src/TEveLegoEventHandler.cxx
@@ -107,7 +107,7 @@ Bool_t TEveLegoEventHandler::Rotate(Int_t xDelta, Int_t yDelta, Bool_t mod1, Boo
    TGLCamera &cam =  fGLViewer->GetRnrCtx()->RefCamera();
    Double_t hRotate = cam.AdjustDelta(-yDelta, Pi()/cam.RefViewport().Height(), mod1, mod2);
 
-   if (fMode == kLocked)
+   if (cam.IsOrthographic())
    {
       fTheta += hRotate;
       if (fTheta < 0) fTheta = 0;
diff --git a/graf3d/eve/src/TEveLine.cxx b/graf3d/eve/src/TEveLine.cxx
index dc4f5cd..e2cbbbd 100644
--- a/graf3d/eve/src/TEveLine.cxx
+++ b/graf3d/eve/src/TEveLine.cxx
@@ -169,6 +169,30 @@ void TEveLine::ReduceSegmentLengths(Float_t max)
 }
 
 //______________________________________________________________________________
+TEveVector TEveLine::GetLineStart() const
+{
+   // Return the first point of the line.
+   // If there are no points (0,0,0) is returned.
+
+   TEveVector v;
+   GetPoint(0, v.fX, v.fY, v.fZ);
+   return v;
+}
+
+//______________________________________________________________________________
+TEveVector TEveLine::GetLineEnd() const
+{
+   // Return the last point of the line.
+   // If there are no points (0,0,0) is returned.
+
+   TEveVector v;
+   GetPoint(fLastPoint, v.fX, v.fY, v.fZ);
+   return v;
+}
+
+//==============================================================================
+
+//______________________________________________________________________________
 void TEveLine::CopyVizParams(const TEveElement* el)
 {
    // Copy visualization parameters from element el.
diff --git a/graf3d/eve/src/TEveManager.cxx b/graf3d/eve/src/TEveManager.cxx
index 1bc94ae..9a5562d 100644
--- a/graf3d/eve/src/TEveManager.cxx
+++ b/graf3d/eve/src/TEveManager.cxx
@@ -14,7 +14,6 @@
 #include "TEveSelection.h"
 #include "TEveViewer.h"
 #include "TEveScene.h"
-#include "TEvePad.h"
 #include "TEveEventManager.h"
 #include "TEveWindowManager.h"
 
@@ -33,7 +32,6 @@
 #include "TMacro.h"
 #include "TFolder.h"
 #include "TBrowser.h"
-#include "TPad.h"
 #include "TCanvas.h"
 #include "TSystem.h"
 #include "TRint.h"
diff --git a/graf3d/eve/src/TEvePlot3D.cxx b/graf3d/eve/src/TEvePlot3D.cxx
new file mode 100644
index 0000000..421ae90
--- /dev/null
+++ b/graf3d/eve/src/TEvePlot3D.cxx
@@ -0,0 +1,78 @@
+// @(#)root/eve:$Id: TEvePlot3D.cxx 29909 2009-08-25 19:04:28Z matevz $
+// Author: Matevz Tadel, 2009
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#include "TEvePlot3D.h"
+#include "TEveTrans.h"
+
+#include "TPad.h"
+#include "TVirtualViewer3D.h"
+#include "TBuffer3D.h"
+#include "TBuffer3DTypes.h"
+
+
+//______________________________________________________________________________
+// Description of TEvePlot3D
+//
+
+ClassImp(TEvePlot3D);
+
+//______________________________________________________________________________
+TEvePlot3D::TEvePlot3D(const char* n, const char* t) :
+   TEveElementList(n, t),
+   fPlot(0),
+   fLogX(kFALSE), fLogY(kFALSE), fLogZ(kFALSE)
+{
+   // Constructor.
+
+   InitMainTrans();
+}
+
+
+/******************************************************************************/
+
+/*
+// For now use true sizes of plots.
+//______________________________________________________________________________
+void TEvePlot3D::ComputeBBox()
+{
+   // Compute bounding-box of the data.
+
+   if (fPlot)
+      BBoxZero(); // should be BBoxZero(0.5); once the plots are stuffed into unit box.
+   else
+      BBoxZero();
+}
+*/
+
+//______________________________________________________________________________
+void TEvePlot3D::Paint(Option_t*)
+{
+   // Paint object.
+   // This is for direct rendering (using TEvePlot3DGL class).
+
+   static const TEveException eh("TEvePlot3D::Paint ");
+
+   if (fRnrSelf == kFALSE) return;
+
+   TBuffer3D buff(TBuffer3DTypes::kGeneric);
+
+   // Section kCore
+   buff.fID           = this;
+   buff.fColor        = GetMainColor();
+   buff.fTransparency = GetMainTransparency();
+   if (HasMainTrans())
+      RefMainTrans().SetBuffer3D(buff);
+   buff.SetSectionsValid(TBuffer3D::kCore);
+
+   Int_t reqSections = gPad->GetViewer3D()->AddObject(buff);
+   if (reqSections != TBuffer3D::kNone)
+      Error(eh, "only direct GL rendering supported.");
+}
diff --git a/graf3d/eve/src/TEvePlot3DGL.cxx b/graf3d/eve/src/TEvePlot3DGL.cxx
new file mode 100644
index 0000000..75af072
--- /dev/null
+++ b/graf3d/eve/src/TEvePlot3DGL.cxx
@@ -0,0 +1,71 @@
+// @(#)root/eve:$Id: TEvePlot3DGL.cxx 29909 2009-08-25 19:04:28Z matevz $
+// Author: Matevz Tadel, 2009
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#include "TEvePlot3DGL.h"
+#include "TEvePlot3D.h"
+#include "TGLPlot3D.h"
+
+#include "TGLRnrCtx.h"
+#include "TGLIncludes.h"
+
+//______________________________________________________________________________
+// OpenGL renderer class for TEvePlot3D.
+//
+
+ClassImp(TEvePlot3DGL);
+
+//______________________________________________________________________________
+TEvePlot3DGL::TEvePlot3DGL() :
+   TGLObject(), fM(0), fPlotLogical(0)
+{
+   // Constructor.
+
+   fDLCache = kFALSE; // Disable display list.
+}
+
+/******************************************************************************/
+
+//______________________________________________________________________________
+Bool_t TEvePlot3DGL::SetModel(TObject* obj, const Option_t* /*opt*/)
+{
+   // Set model object.
+
+   if (SetModelCheckClass(obj, TEvePlot3D::Class())) {
+      fM = dynamic_cast<TEvePlot3D*>(obj);
+      fPlotLogical = TGLPlot3D::CreatePlot(fM->fPlot, fM->fPlotOption, fM->fLogX, fM->fLogY, fM->fLogZ);
+      return kTRUE;
+   }
+   return kFALSE;
+}
+
+//______________________________________________________________________________
+void TEvePlot3DGL::SetBBox()
+{
+   // Set bounding box.
+
+   // !! This ok if master sub-classed from TAttBBox
+   //SetAxisAlignedBBox(((TEvePlot3D*)fExternalObj)->AssertBBox());
+   fBoundingBox = fPlotLogical->BoundingBox();
+}
+
+/******************************************************************************/
+
+//______________________________________________________________________________
+void TEvePlot3DGL::DirectDraw(TGLRnrCtx & rnrCtx) const
+{
+   // Render with OpenGL.
+
+   // printf("TEvePlot3DGL::DirectDraw LOD %d\n", rnrCtx.CombiLOD());
+   if (fPlotLogical)
+   {
+      fPlotLogical->DirectDraw(rnrCtx);
+   }
+}
diff --git a/graf3d/eve/src/TEvePointSet.cxx b/graf3d/eve/src/TEvePointSet.cxx
index a82b5ea..37cb5e1 100644
--- a/graf3d/eve/src/TEvePointSet.cxx
+++ b/graf3d/eve/src/TEvePointSet.cxx
@@ -20,7 +20,6 @@
 #include "TF3.h"
 
 #include "TColor.h"
-#include "TCanvas.h"
 #include "TBuffer3D.h"
 #include "TBuffer3DTypes.h"
 #include "TVirtualViewer3D.h"
@@ -157,7 +156,6 @@ void TEvePointSet::ComputeBBox()
    // Override of virtual method from TAttBBox.
 
    TPointSet3D::ComputeBBox();
-   AssertBBoxExtents(0.1);
 }
 
 //______________________________________________________________________________
diff --git a/graf3d/eve/src/TEvePolygonSetProjected.cxx b/graf3d/eve/src/TEvePolygonSetProjected.cxx
index 17dbea0..442a0e5 100644
--- a/graf3d/eve/src/TEvePolygonSetProjected.cxx
+++ b/graf3d/eve/src/TEvePolygonSetProjected.cxx
@@ -426,10 +426,13 @@ void TEvePolygonSetProjected::ComputeBBox()
 {
    // Override of virtual method from TAttBBox.
 
-   BBoxInit();
-   for (Int_t pi = 0; pi<fNPnts; ++pi)
-      BBoxCheckPoint(fPnts[pi].fX, fPnts[pi].fY, fPnts[pi].fZ);
-   AssertBBoxExtents(0.1);
+   if (fNPnts > 0) {
+      BBoxInit();
+      for (Int_t pi = 0; pi < fNPnts; ++pi)
+         BBoxCheckPoint(fPnts[pi].fX, fPnts[pi].fY, fPnts[pi].fZ);
+   } else {
+      BBoxZero();
+   }
 }
 
 //______________________________________________________________________________
diff --git a/graf3d/eve/src/TEvePolygonSetProjectedGL.cxx b/graf3d/eve/src/TEvePolygonSetProjectedGL.cxx
index edd3aaf..99cc65a 100644
--- a/graf3d/eve/src/TEvePolygonSetProjectedGL.cxx
+++ b/graf3d/eve/src/TEvePolygonSetProjectedGL.cxx
@@ -130,7 +130,7 @@ void TEvePolygonSetProjectedGL::DirectDraw(TGLRnrCtx & /*rnrCtx*/) const
    TGLUtil::Color(refPS.fLineColor);
    glEnable(GL_LINE_SMOOTH);
 
-   glLineWidth(refPS.fLineWidth);
+   TGLUtil::LineWidth(refPS.fLineWidth);
    Int_t vi;
    for (TEvePolygonSetProjected::vpPolygon_ci i = refPS.fPols.begin();
         i != refPS.fPols.end(); ++i)
diff --git a/graf3d/eve/src/TEveProjectionManager.cxx b/graf3d/eve/src/TEveProjectionManager.cxx
index 1a3cf1f..3ecdf73 100644
--- a/graf3d/eve/src/TEveProjectionManager.cxx
+++ b/graf3d/eve/src/TEveProjectionManager.cxx
@@ -14,7 +14,6 @@
 #include "TEveProjectionBases.h"
 #include "TEveCompound.h"
 
-#include "TAttBBox.h"
 #include "TBuffer3D.h"
 #include "TBuffer3DTypes.h"
 #include "TVirtualPad.h"
@@ -170,8 +169,8 @@ Bool_t TEveProjectionManager::ShouldImport(TEveElement* el)
 //______________________________________________________________________________
 void TEveProjectionManager::UpdateDependentElsAndScenes(TEveElement* root)
 {
-   // Update dependent elements' vounding box and mark scenes
-   // cointaining element root or its children as requiring a repaint.
+   // Update dependent elements' bounding box and mark scenes
+   // containing element root or its children as requiring a repaint.
 
    for (List_i i=fDependentEls.begin(); i!=fDependentEls.end(); ++i)
    {
@@ -256,7 +255,10 @@ TEveElement* TEveProjectionManager::ImportElements(TEveElement* el,
       AssertBBox();
       ProjectChildrenRecurse(new_el);
       AssertBBoxExtents(0.1);
+      StampTransBBox();
+
       UpdateDependentElsAndScenes(new_el);
+
       if (ext_list)
          ext_list->AddElement(new_el);
    }
@@ -295,8 +297,10 @@ void TEveProjectionManager::ProjectChildren()
    // TEveManger about the scenes that have been changed.
 
    BBoxInit();
-   ProjectChildrenRecurse(this);
+   for (List_i i=BeginChildren(); i!=EndChildren(); ++i)
+      ProjectChildrenRecurse(*i);
    AssertBBoxExtents(0.1);
+   StampTransBBox();
 
    UpdateDependentElsAndScenes(this);
 }
diff --git a/graf3d/eve/src/TEveQuadSet.cxx b/graf3d/eve/src/TEveQuadSet.cxx
index 6d6c2f8..e5fa884 100644
--- a/graf3d/eve/src/TEveQuadSet.cxx
+++ b/graf3d/eve/src/TEveQuadSet.cxx
@@ -494,6 +494,4 @@ void TEveQuadSet::ComputeBBox()
 
       } // end switch quad-type
    } // end if frame ... else ...
-
-   AssertBBoxExtents(0.001);
 }
diff --git a/graf3d/eve/src/TEveScene.cxx b/graf3d/eve/src/TEveScene.cxx
index 68e105d..ea6591d 100644
--- a/graf3d/eve/src/TEveScene.cxx
+++ b/graf3d/eve/src/TEveScene.cxx
@@ -13,6 +13,7 @@
 #include "TEveViewer.h"
 #include "TEveManager.h"
 #include "TEveTrans.h"
+#include "TEvePad.h"
 
 #include "TList.h"
 #include "TGLScenePad.h"
@@ -29,6 +30,10 @@
 // Eve representation of TGLScene.
 // The GLScene is owned by this class - it is created on construction
 // time and deleted at destruction.
+//
+// Normally all objects are positioned directly in global scene-space.
+// By setting the fHierarchical flag, positions of children get
+// calculated by multiplying the transformation matrices of all parents.
 
 ClassImp(TEveScene);
 
@@ -38,7 +43,8 @@ TEveScene::TEveScene(const char* n, const char* t) :
    fPad    (0),
    fGLScene(0),
    fChanged      (kFALSE),
-   fSmartRefresh (kTRUE)
+   fSmartRefresh (kTRUE),
+   fHierarchical (kFALSE)
 {
    // Constructor.
 
@@ -86,7 +92,6 @@ void TEveScene::Repaint(Bool_t dropLogicals)
    if (dropLogicals) fGLScene->SetSmartRefresh(kTRUE);
    fChanged = kFALSE;
 
-
    // Hack to propagate selection state to physical shapes.
    //
    // Should actually be published in PadPaint() following a direct
@@ -105,6 +110,49 @@ void TEveScene::Repaint(Bool_t dropLogicals)
          pshp->Select(elm->GetSelectedLevel());
       }
    }
+
+   // Fix positions for hierarchical scenes.
+   if (fHierarchical)
+   {
+      RetransHierarchically();
+   }
+}
+
+//______________________________________________________________________________
+void TEveScene::RetransHierarchically()
+{
+   // Entry point for hierarchical transformation update.
+   // Calls the recursive variant on all children.
+
+   fGLScene->BeginUpdate();
+
+   RetransHierarchicallyRecurse(this, RefMainTrans());
+
+   fGLScene->EndUpdate();
+}
+
+void TEveScene::RetransHierarchicallyRecurse(TEveElement* el, const TEveTrans& tp)
+{
+   // Set transformation matrix for physical shape of element el in
+   // the GL-scene and recursively descend into children (if enabled).
+
+   TEveTrans t(tp);
+   if (el->HasMainTrans())
+      t *= el->RefMainTrans();
+
+   if (el->GetRnrSelf() && el != this)
+   {
+      fGLScene->UpdatePhysioLogical(el->GetRenderObject(), t.Array(), 0);
+   }
+
+   if (el->GetRnrChildren())
+   {
+      for (List_i i = el->BeginChildren(); i != el->EndChildren(); ++i)
+      {
+         if ((*i)->GetRnrAnything())
+            RetransHierarchicallyRecurse(*i, t);
+      }
+   }
 }
 
 /******************************************************************************/
@@ -123,7 +171,7 @@ void TEveScene::Paint(Option_t* option)
 {
    // Paint the scene. Iterate over children and calls PadPaint().
 
-   if (fRnrChildren)
+   if (GetRnrState())
    {
       for(List_i i=fChildren.begin(); i!=fChildren.end(); ++i)
          (*i)->PadPaint(option);
@@ -264,6 +312,7 @@ void TEveSceneList::ProcessSceneChanges(Bool_t dropLogicals, Set_t& stampSet)
       {
          Bool_t updateViewers = kFALSE;
          Bool_t incTimeStamp  = kFALSE;
+         Bool_t transbboxChg  = kFALSE;
 
          s->GetGLScene()->BeginUpdate();
 
@@ -303,6 +352,7 @@ void TEveSceneList::ProcessSceneChanges(Bool_t dropLogicals, Set_t& stampSet)
                      pshp->SetTransform(el->PtrMainTrans()->Array());
                   lshp->UpdateBoundingBox();
                   incTimeStamp = kTRUE;
+                  transbboxChg = kTRUE;
                }
 
                if (bits & kCBObjProps)
@@ -324,6 +374,12 @@ void TEveSceneList::ProcessSceneChanges(Bool_t dropLogicals, Set_t& stampSet)
          }
 
          s->GetGLScene()->EndUpdate(updateViewers, incTimeStamp, updateViewers);
+
+         // Fix positions for hierarchical scenes.
+         if (s->GetHierarchical() && transbboxChg)
+         {
+            s->RetransHierarchically();
+         }
       }
    }
 }
diff --git a/graf3d/eve/src/TEveStraightLineSetGL.cxx b/graf3d/eve/src/TEveStraightLineSetGL.cxx
index 9e42daa..9c2bb68 100644
--- a/graf3d/eve/src/TEveStraightLineSetGL.cxx
+++ b/graf3d/eve/src/TEveStraightLineSetGL.cxx
@@ -36,7 +36,7 @@ TEveStraightLineSetGL::TEveStraightLineSetGL() : TGLObject(), fM(0)
    fMultiColor = kTRUE;
 }
 
-/******************************************************************************/
+//==============================================================================
 
 //______________________________________________________________________________
 Bool_t TEveStraightLineSetGL::SetModel(TObject* obj, const Option_t* /*opt*/)
@@ -55,7 +55,6 @@ void TEveStraightLineSetGL::SetBBox()
 {
    // Setup bounding box information.
 
-   // !! This ok if master sub-classed from TAttBBox
    SetAxisAlignedBBox(((TEveStraightLineSet*)fExternalObj)->AssertBBox());
 }
 
@@ -88,7 +87,7 @@ void TEveStraightLineSetGL::DirectDraw(TGLRnrCtx& rnrCtx) const
 {
    // Render the line-set with GL.
 
-   // printf("TEveStraightLineSetGL::DirectDraw Style %d, LOD %d\n", flags.Style(), flags.LOD());
+   // printf("TEveStraightLineSetGL::DirectDraw LOD %d\n", rnrCtx.ShapeLOD());
 
    TEveStraightLineSet& mL = * fM;
 
@@ -103,7 +102,7 @@ void TEveStraightLineSetGL::DirectDraw(TGLRnrCtx& rnrCtx) const
    if (mL.GetRnrLines() && mL.GetLinePlex().Size() > 0)
    {
       glPushAttrib(GL_LINE_BIT | GL_ENABLE_BIT);
-      glLineWidth(mL.GetLineWidth());
+      TGLUtil::LineWidth(mL.GetLineWidth());
       if (mL.GetLineStyle() > 1) {
          Int_t    fac = 1;
          UShort_t pat = 0xffff;
@@ -198,7 +197,7 @@ void TEveStraightLineSetGL::DirectDraw(TGLRnrCtx& rnrCtx) const
       glPopAttrib();
 }
 
-/******************************************************************************/
+//==============================================================================
 
 //______________________________________________________________________________
 void TEveStraightLineSetGL::ProcessSelection(TGLRnrCtx& /*rnrCtx*/,
diff --git a/graf3d/eve/src/TEveTrack.cxx b/graf3d/eve/src/TEveTrack.cxx
index 65e654b..d32b846 100644
--- a/graf3d/eve/src/TEveTrack.cxx
+++ b/graf3d/eve/src/TEveTrack.cxx
@@ -54,6 +54,7 @@ TEveTrack::TEveTrack() :
    fCharge(0),
    fLabel(kMinInt),
    fIndex(kMinInt),
+   fStatus(0),
    fLockPoints(kFALSE),
    fPathMarks(),
    fPropagator(0),
@@ -63,7 +64,7 @@ TEveTrack::TEveTrack() :
 }
 
 //______________________________________________________________________________
-TEveTrack::TEveTrack(TParticle* t, Int_t label, TEveTrackPropagator* rs):
+TEveTrack::TEveTrack(TParticle* t, Int_t label, TEveTrackPropagator* prop):
    TEveLine(),
 
    fV(t->Vx(), t->Vy(), t->Vz()),
@@ -74,6 +75,7 @@ TEveTrack::TEveTrack(TParticle* t, Int_t label, TEveTrackPropagator* rs):
    fCharge(0),
    fLabel(label),
    fIndex(kMinInt),
+   fStatus(t->GetStatusCode()),
    fLockPoints(kFALSE),
    fPathMarks(),
    fPropagator(0),
@@ -81,7 +83,7 @@ TEveTrack::TEveTrack(TParticle* t, Int_t label, TEveTrackPropagator* rs):
 {
    // Constructor from TParticle.
 
-   SetPropagator(rs);
+   SetPropagator(prop);
    fMainColorPtr = &fLineColor;
 
    TParticlePDG* pdgp = t->GetPDG();
@@ -94,7 +96,7 @@ TEveTrack::TEveTrack(TParticle* t, Int_t label, TEveTrackPropagator* rs):
 }
 
 //______________________________________________________________________________
-TEveTrack::TEveTrack(TEveMCTrack* t, TEveTrackPropagator* rs):
+TEveTrack::TEveTrack(TEveMCTrack* t, TEveTrackPropagator* prop):
    TEveLine(),
 
    fV(t->Vx(), t->Vy(), t->Vz()),
@@ -105,6 +107,7 @@ TEveTrack::TEveTrack(TEveMCTrack* t, TEveTrackPropagator* rs):
    fCharge(0),
    fLabel(t->fLabel),
    fIndex(t->fIndex),
+   fStatus(t->GetStatusCode()),
    fLockPoints(kFALSE),
    fPathMarks(),
    fPropagator(0),
@@ -112,7 +115,7 @@ TEveTrack::TEveTrack(TEveMCTrack* t, TEveTrackPropagator* rs):
 {
    // Constructor from TEveUtil Monte Carlo track.
 
-   SetPropagator(rs);
+   SetPropagator(prop);
    fMainColorPtr = &fLineColor;
 
    TParticlePDG* pdgp = t->GetPDG();
@@ -125,7 +128,7 @@ TEveTrack::TEveTrack(TEveMCTrack* t, TEveTrackPropagator* rs):
 }
 
 //______________________________________________________________________________
-TEveTrack::TEveTrack(TEveRecTrack* t, TEveTrackPropagator* rs) :
+TEveTrack::TEveTrack(TEveRecTrack* t, TEveTrackPropagator* prop) :
    TEveLine(),
 
    fV(t->fV),
@@ -136,6 +139,7 @@ TEveTrack::TEveTrack(TEveRecTrack* t, TEveTrackPropagator* rs) :
    fCharge(t->fSign),
    fLabel(t->fLabel),
    fIndex(t->fIndex),
+   fStatus(t->fStatus),
    fLockPoints(kFALSE),
    fPathMarks(),
    fPropagator(0),
@@ -143,7 +147,7 @@ TEveTrack::TEveTrack(TEveRecTrack* t, TEveTrackPropagator* rs) :
 {
    // Constructor from TEveUtil reconstructed track.
 
-   SetPropagator(rs);
+   SetPropagator(prop);
    fMainColorPtr = &fLineColor;
 
    SetName(t->GetName());
@@ -160,6 +164,7 @@ TEveTrack::TEveTrack(const TEveTrack& t) :
    fCharge(t.fCharge),
    fLabel(t.fLabel),
    fIndex(t.fIndex),
+   fStatus(t.fStatus),
    fLockPoints(t.fLockPoints),
    fPathMarks(),
    fPropagator(0),
@@ -264,15 +269,15 @@ void TEveTrack::SetPathMarks(const TEveTrack& t)
 /******************************************************************************/
 
 //______________________________________________________________________________
-void TEveTrack::SetPropagator(TEveTrackPropagator* rs)
+void TEveTrack::SetPropagator(TEveTrackPropagator* prop)
 {
    // Set track's render style.
-   // Reference counts of old and new render-style are updated.
+   // Reference counts of old and new propagator are updated.
 
-   if (fPropagator == rs) return;
+   if (fPropagator == prop) return;
    if (fPropagator) fPropagator->DecRefCount(this);
-   fPropagator = rs;
-   if (fPropagator) rs->IncRefCount(this);
+   fPropagator = prop;
+   if (fPropagator) prop->IncRefCount(this);
 }
 
 /******************************************************************************/
@@ -299,14 +304,14 @@ void TEveTrack::SetAttLineAttMarker(TEveTrackList* tl)
 void TEveTrack::MakeTrack(Bool_t recurse)
 {
    // Calculate track representation based on track data and current
-   // settings of the render-style.
+   // settings of the propagator.
    // If recurse is true, descend into children.
 
    if (!fLockPoints)
    {
       Reset(0);
 
-      TEveTrackPropagator& rTP((fPropagator != 0) ? *fPropagator : TEveTrackPropagator::fgDefStyle);
+      TEveTrackPropagator& rTP((fPropagator != 0) ? *fPropagator : TEveTrackPropagator::fgDefault);
 
       const Float_t maxRsq = rTP.GetMaxR() * rTP.GetMaxR();
       const Float_t maxZ   = rTP.GetMaxZ();
@@ -531,7 +536,7 @@ void TEveTrack::SetLineStyle(Style_t lstyle)
 ClassImp(TEveTrackList);
 
 //______________________________________________________________________________
-TEveTrackList::TEveTrackList(TEveTrackPropagator* rs) :
+TEveTrackList::TEveTrackList(TEveTrackPropagator* prop) :
    TEveElementList(),
    TAttMarker(1, 20, 1),
    TAttLine(1,1,1),
@@ -551,12 +556,12 @@ TEveTrackList::TEveTrackList(TEveTrackPropagator* rs) :
 
    fMainColorPtr = &fLineColor;
 
-   if (rs == 0) rs = new TEveTrackPropagator;
-   SetPropagator(rs);
+   if (prop == 0) prop = new TEveTrackPropagator;
+   SetPropagator(prop);
 }
 
 //______________________________________________________________________________
-TEveTrackList::TEveTrackList(const char* name, TEveTrackPropagator* rs) :
+TEveTrackList::TEveTrackList(const char* name, TEveTrackPropagator* prop) :
    TEveElementList(name),
    TAttMarker(1, 20, 1),
    TAttLine(1,1,1),
@@ -576,8 +581,8 @@ TEveTrackList::TEveTrackList(const char* name, TEveTrackPropagator* rs) :
 
    fMainColorPtr = &fLineColor;
 
-   if (rs == 0) rs = new TEveTrackPropagator;
-   SetPropagator(rs);
+   if (prop == 0) prop = new TEveTrackPropagator;
+   SetPropagator(prop);
 }
 
 //______________________________________________________________________________
@@ -591,16 +596,16 @@ TEveTrackList::~TEveTrackList()
 /******************************************************************************/
 
 //______________________________________________________________________________
-void TEveTrackList::SetPropagator(TEveTrackPropagator* rs)
+void TEveTrackList::SetPropagator(TEveTrackPropagator* prop)
 {
-   // Set default render-style for tracks.
+   // Set default propagator for tracks.
    // This is not enforced onto the tracks themselves but this is the
-   // render-style that is show in the TEveTrackListEditor.
+   // propagator that is shown in the TEveTrackListEditor.
 
-   if (fPropagator == rs) return;
+   if (fPropagator == prop) return;
    if (fPropagator) fPropagator->DecRefCount();
-   fPropagator = rs;
-   if (fPropagator) rs->IncRefCount();
+   fPropagator = prop;
+   if (fPropagator) prop->IncRefCount();
 }
 
 /******************************************************************************/
diff --git a/graf3d/eve/src/TEveTrackPropagator.cxx b/graf3d/eve/src/TEveTrackPropagator.cxx
index cc9f5e6..6fe3473 100644
--- a/graf3d/eve/src/TEveTrackPropagator.cxx
+++ b/graf3d/eve/src/TEveTrackPropagator.cxx
@@ -9,8 +9,10 @@
  * For the list of contributors see $ROOTSYS/README/CREDITS.             *
  *************************************************************************/
 
+
 #include "TEveTrackPropagator.h"
 #include "TEveTrack.h"
+#include "TEveTrans.h"
 
 #include "TMath.h"
 
@@ -30,28 +32,36 @@ TEveTrackPropagator::Helix_t::Helix_t() :
    fMaxStep(20.f), fCurrentStep(20.f),
    fPhi(0), fValid(kFALSE),
    fLam(-1), fR(-1), fPhiStep(-1), fSin(-1), fCos(-1),
-   fPtMag(-1), fPlDir(-1), fLStep(-1)
+   fPtMag(-1), fPlMag(-1), fLStep(-1)
 {
    // Default constructor.
 }
 
 //______________________________________________________________________________
-void TEveTrackPropagator::Helix_t::UpdateHelix(const TEveVector& p, const TEveVector& b, Bool_t fullUpdate)
+void TEveTrackPropagator::Helix_t::UpdateCommon(const TEveVector & p, const TEveVector& b)
 {
-   // Update helix parameters.
+   // Common update code for helix and RK propagation.
 
    fB = b;
 
    // base vectors
    fE1 = b;
    fE1.Normalize();
-   fPlDir = p.Dot(fE1);
-   fPl    = fE1*fPlDir;
+   fPlMag = p.Dot(fE1);
+   fPl    = fE1*fPlMag;
 
    fPt    = p - fPl;
    fPtMag = fPt.Mag();
    fE2    = fPt;
    fE2.Normalize();
+}
+
+//______________________________________________________________________________
+void TEveTrackPropagator::Helix_t::UpdateHelix(const TEveVector& p, const TEveVector& b, Bool_t fullUpdate)
+{
+   // Update helix parameters.
+
+   UpdateCommon(p, b);
 
    // helix parameters
    TMath::Cross(fE1.Arr(), fE2.Arr(), fE3.Arr());
@@ -67,7 +77,7 @@ void TEveTrackPropagator::Helix_t::UpdateHelix(const TEveVector& p, const TEveVe
 
          fR   = Abs(fPtMag / a);
          fLam = fPl.Mag() / fPtMag;
-         if (fPlDir < 0) fLam = - fLam;
+         if (fPlMag < 0) fLam = - fLam;
 
          // get phi step, compare fMinAng with fDelta
          fPhiStep = fMinAng * DegToRad();
@@ -94,6 +104,27 @@ void TEveTrackPropagator::Helix_t::UpdateHelix(const TEveVector& p, const TEveVe
 }
 
 //______________________________________________________________________________
+void TEveTrackPropagator::Helix_t::UpdateRK(const TEveVector& p, const TEveVector& b)
+{
+   // Update helix for stepper RungeKutta.
+
+   UpdateCommon(p, b);
+
+   if (fCharge)
+   {
+      fValid = kTRUE;
+
+      // cached values for propagator
+      fB = b;
+      fPlMag = p.Dot(fB);
+   }
+   else
+   {
+      fValid = kFALSE;
+   }
+}
+
+//______________________________________________________________________________
 void TEveTrackPropagator::Helix_t::Step(const TEveVector4& v, const TEveVector& p,
                                         TEveVector4& vOut, TEveVector& pOut)
 {
@@ -121,26 +152,6 @@ void TEveTrackPropagator::Helix_t::Step(const TEveVector4& v, const TEveVector&
 }
 
 
-//______________________________________________________________________________
-void TEveTrackPropagator::Helix_t::UpdateRK(const TEveVector& p, const TEveVector& b)
-{
-   // Update helix for stepper RungeKutta.
-
-   if (fCharge)
-   {
-      fValid = kTRUE;
-
-      // cached values for propagator
-      fB = b;
-      fPlDir = p.Dot(fB);
-   }
-   else
-   {
-      fValid = kFALSE;
-   }
-}
-
-
 //==============================================================================
 // TEveTrackPropagator
 //==============================================================================
@@ -161,7 +172,7 @@ ClassImp(TEveTrackPropagator);
 
 Float_t             TEveTrackPropagator::fgDefMagField = 0.5;
 const Float_t       TEveTrackPropagator::fgkB2C        = 0.299792458e-2;
-TEveTrackPropagator TEveTrackPropagator::fgDefStyle;
+TEveTrackPropagator TEveTrackPropagator::fgDefault;
 
 //______________________________________________________________________________
 TEveTrackPropagator::TEveTrackPropagator(const char* n, const char* t,
@@ -299,7 +310,7 @@ Bool_t TEveTrackPropagator::GoToVertex(TEveVector& v, TEveVector& p)
       return kTRUE;
    }
 
-   return fH.fValid ? LoopToVertex(v, p): LineToVertex(v);
+   return fH.fValid ? LoopToVertex(v, p) : LineToVertex(v);
 }
 
 //______________________________________________________________________________
@@ -317,19 +328,31 @@ void TEveTrackPropagator::GoToBounds(TEveVector& p)
 }
 
 //______________________________________________________________________________
-void TEveTrackPropagator::Step(TEveVector4 &v, TEveVector &p, TEveVector4 &vOut, TEveVector &pOut)
+void TEveTrackPropagator::Update(const TEveVector4& v, const TEveVector& p, Bool_t full_update)
 {
-   // Wrapper to step helix.
+   // Update helix / B-field projection state.
 
    if (fStepper == kHelix)
    {
-      fH.UpdateHelix(p, fMagFieldObj->GetField(v), !fMagFieldObj->IsConst());
-      fH.Step(v, p, vOut, pOut);
+      fH.UpdateHelix(p, fMagFieldObj->GetField(v), !fMagFieldObj->IsConst() || full_update);
    }
    else
    {
       fH.UpdateRK(p, fMagFieldObj->GetField(v));
+   }
+}
+
+//______________________________________________________________________________
+void TEveTrackPropagator::Step(const TEveVector4 &v, const TEveVector &p, TEveVector4 &vOut, TEveVector &pOut)
+{
+   // Wrapper to step helix.
 
+   if (fStepper == kHelix)
+   {
+      fH.Step(v, p, vOut, pOut);
+   }
+   else
+   {
       Double_t vecRKIn[7];
       vecRKIn[0] = v.fX;
       vecRKIn[1] = v.fY;
@@ -346,7 +369,7 @@ void TEveTrackPropagator::Step(TEveVector4 &v, TEveVector &p, TEveVector4 &vOut,
       vOut.fX = vecRKOut[0];
       vOut.fY = vecRKOut[1];
       vOut.fZ = vecRKOut[2];
-      vOut.fT += fH.fMaxStep;
+      vOut.fT = v.fT + fH.fMaxStep;
       Double_t pm = vecRKOut[6];
       pOut.fX = vecRKOut[3]*pm;
       pOut.fY = vecRKOut[4]*pm;
@@ -370,6 +393,7 @@ void TEveTrackPropagator::LoopToBounds(TEveVector& p)
 
    while (fH.fPhi < maxPhi && np<fNMax)
    {
+      Update(currV, p);
       Step(currV, p, forwV, forwP);
 
       // cross R
@@ -405,7 +429,7 @@ void TEveTrackPropagator::LoopToBounds(TEveVector& p)
          }
          TEveVector d(forwV -currV);
          d *= t;
-         d +=currV;
+         d += currV;
          fPoints.push_back(d);
          return;
       }
@@ -422,7 +446,7 @@ Bool_t TEveTrackPropagator::LoopToVertex(TEveVector& v, TEveVector& p)
 {
    // Propagate charged particle with momentum p to vertex v.
 
-   const Float_t maxRsq = fMaxR*fMaxR;
+   const Float_t maxRsq = fMaxR * fMaxR;
 
    TEveVector4 currV(fV);
    TEveVector4 forwV(fV);
@@ -431,12 +455,18 @@ Bool_t TEveTrackPropagator::LoopToVertex(TEveVector& v, TEveVector& p)
    Int_t first_point = fPoints.size();
    Int_t np          = first_point;
 
+   Float_t prod0=0, prod1;
+
+   Update(currV, p);
    do
    {
       Step(currV, p, forwV, forwP);
+      Update(forwV, forwP);
 
-      if (PointOverVertex(v, forwV))
+      if (PointOverVertex(v, forwV, &prod1))
+      {
          break;
+      }
 
       if (IsOutsideBounds(forwV, maxRsq, fMaxZ))
       {
@@ -447,41 +477,66 @@ Bool_t TEveTrackPropagator::LoopToVertex(TEveVector& v, TEveVector& p)
       fPoints.push_back(forwV);
       currV = forwV;
       p     = forwP;
+      prod0 = prod1;
       ++np;
    } while (np < fNMax);
 
    // make the remaining fractional step
    if (np > first_point)
    {
-      TEveVector d1 = v;     d1 -= currV;
-      TEveVector d2 = forwV; d2 -= currV;
-      TEveVector pln =  fH.fPl;
-      pln.Normalize();
+      TEveVector d1 = v;
+      d1 -= currV;
 
       if (d1.Mag() > kStepEps)
       {
-         // step for forced step size;
-         Float_t origMaxStep = fH.fMaxStep;
-         fH.fMaxStep = d1.Mag();
-         if (fStepper == kHelix)
-            fH.UpdateHelix(p, fMagFieldObj->GetField(fV), kTRUE);
-         else
-            fH.UpdateRK(p, fMagFieldObj->GetField(fV));
-
-         Step(currV, p, forwV, forwP);
-         p = forwP;
-         currV = forwV;
-         fPoints.push_back(currV); np++;
-         fH.fMaxStep =  origMaxStep;
-
-         // distibute offset
+         Float_t step_frac = prod0 / (prod0 - prod1);
+         if (step_frac > 0)
+         {
+            // Step for fraction of previous step size.
+            // !!! This does not work well for helix stepper - need a way to
+            // !!! enforce it.
+            // !! Maybe special Update() method, taking fraction as argument.
+            Float_t origMaxStep = fH.fMaxStep;
+            fH.fMaxStep *= step_frac;
+            Update(currV, p, kTRUE);
+            Step(currV, p, forwV, forwP);
+            p     = forwP;
+            currV = forwV;
+            fPoints.push_back(currV);
+            ++np;
+            fH.fMaxStep = origMaxStep;
+         }
+
+         // Distribute offset to desired crossing point over all segment.
+
          TEveVector off(v); off -= currV;
          off *= 1.0f / currV.fT;
+
+         // Calculate the required momentum rotation.
+         // lpd - last-points-delta
+         TEveVector lpd0(fPoints[np-1]);
+         lpd0 -= fPoints[np-2];
+         lpd0.Normalize();
+
          for (Int_t i = first_point; i < np; ++i)
          {
             fPoints[i] += off * fPoints[i].fT;
          }
 
+         TEveVector lpd1(fPoints[np-1]);
+         lpd1 -= fPoints[np-2];
+         lpd1.Normalize();
+
+         TEveTrans tt;
+         tt.SetupFromToVec(lpd0, lpd1);
+
+         // TEveVector pb4(p);
+         // printf("Rotating momentum: p0 = "); p.Dump();
+         tt.RotateIP(p);
+         // printf("                   p1 = "); p.Dump();
+         // printf("  n1=%f, n2=%f, dp = %f deg\n", pb4.Mag(), p.Mag(),
+         //        TMath::RadToDeg()*TMath::ACos(p.Dot(pb4)/(pb4.Mag()*p.Mag())));
+
          fV = v;
          return kTRUE;
       }
@@ -548,6 +603,8 @@ Bool_t TEveTrackPropagator::HelixIntersectPlane(const TEveVector& p,
                                                 const TEveVector& normal,
                                                 TEveVector& itsect)
 {
+   // Intersect helix with a plane. Current position and argument p define
+   // the helix.
 
    TEveVector pos(fV);
    TEveVector mom(p);
@@ -563,10 +620,11 @@ Bool_t TEveTrackPropagator::HelixIntersectPlane(const TEveVector& p,
    }
 
    TEveVector4 forwV;
-   TEveVector forwP;
+   TEveVector  forwP;
    TEveVector4 pos4(pos);
-   while (1)
+   while (kTRUE)
    {
+      Update(pos4, mom);
       Step(pos4, mom, forwV , forwP);
       Float_t new_d = (forwV - point).Dot(n);
       if (new_d < d)
@@ -592,6 +650,9 @@ Bool_t TEveTrackPropagator::LineIntersectPlane(const TEveVector& p,
                                                const TEveVector& normal,
                                                      TEveVector& itsect)
 {
+   // Intersect line with a plane. Current position and argument p define
+   // the line.
+
    TEveVector pos(fV.fX, fV.fY, fV.fZ);
    TEveVector delta = pos - point;
 
@@ -892,24 +953,21 @@ void TEveTrackPropagator::OneStepRungeKutta(Double_t charge, Double_t step,
   for(Int_t j = 0; j < 7; j++)
     vout[j] = vect[j];
 
-  Double_t  pinv   = kec * charge / vect[6];
+  Double_t pinv   = kec * charge / vect[6];
   Double_t tl = 0.;
   Double_t h = step;
   Double_t rest;
 
   do {
     rest  = step - tl;
-    if (TMath::Abs(h) > TMath::Abs(rest)) h = rest;
-    //cmodif: call gufld(vout,f) changed into:
-    // GetField(vout,f);
+    if (TMath::Abs(h) > TMath::Abs(rest))
+       h = rest;
+
     f[0] = -fH.fB.fX;
     f[1] = -fH.fB.fY;
     f[2] = -fH.fB.fZ;
 
-
-    // *
-    // *             start of integration
-    // *
+    // * start of integration
     x      = vout[0];
     y      = vout[1];
     z      = vout[2];
@@ -933,10 +991,8 @@ void TEveTrackPropagator::OneStepRungeKutta(Double_t charge, Double_t step,
     xt     = x + dxt;
     yt     = y + dyt;
     zt     = z + dzt;
-    // *
-    // *              second intermediate point
-    // *
 
+    // * second intermediate point
     est = TMath::Abs(dxt) + TMath::Abs(dyt) + TMath::Abs(dzt);
     if (est > h) {
       if (ncut++ > maxcut) break;
@@ -948,7 +1004,6 @@ void TEveTrackPropagator::OneStepRungeKutta(Double_t charge, Double_t step,
     xyzt[1] = yt;
     xyzt[2] = zt;
 
-    //cmodif: call gufld(xyzt,f) changed into:
     fH.fB = fMagFieldObj->GetField(xt, yt, zt);
     f[0] = -fH.fB.fX;
     f[1] = -fH.fB.fY;
@@ -988,7 +1043,6 @@ void TEveTrackPropagator::OneStepRungeKutta(Double_t charge, Double_t step,
     xyzt[1] = yt;
     xyzt[2] = zt;
 
-    //cmodif: call gufld(xyzt,f) changed into:
     fH.fB = fMagFieldObj->GetField(xt, yt, zt);
     f[0] = -fH.fB.fX;
     f[1] = -fH.fB.fY;
@@ -1016,10 +1070,9 @@ void TEveTrackPropagator::OneStepRungeKutta(Double_t charge, Double_t step,
     }
 
     ncut = 0;
-    // *               if too many iterations, go to helix
+    // * if too many iterations, go to helix
     if (iter++ > maxit) break;
 
-    // printf("write value \n");
     tl += h;
     if (est < kdlt32)
       h *= 2.;
@@ -1036,8 +1089,6 @@ void TEveTrackPropagator::OneStepRungeKutta(Double_t charge, Double_t step,
 
   } while(1);
 
-  //  printf("MAKE HELIX \n");
-
   // angle too big, use helix
 
   f1  = f[0];
diff --git a/graf3d/eve/src/TEveTrans.cxx b/graf3d/eve/src/TEveTrans.cxx
index d6b34af..7ec6451 100644
--- a/graf3d/eve/src/TEveTrans.cxx
+++ b/graf3d/eve/src/TEveTrans.cxx
@@ -9,34 +9,9 @@
  * For the list of contributors see $ROOTSYS/README/CREDITS.             *
  *************************************************************************/
 
-//______________________________________________________________________________
-// TEveTrans
-//
-// TEveTrans is a 4x4 transformation matrix for homogeneous coordinates
-// stored internaly in a column-major order to allow direct usage by
-// GL. The element type is Double32_t as statically the floats would
-// be precise enough but continuous operations on the matrix must
-// retain precision of column vectors.
-//
-// Cartan angles are stored in fA[1-3] (+z, -y, +x). They are
-// recalculated on demand.
-//
-// Direct  element access (first two should be used with care):
-// operator[i]    direct access to elements,   i:0->15
-// CM(i,j)        element 4*j + i;           i,j:0->3    { CM ~ c-matrix }
-// operator(i,j)  element 4*(j-1) + i - 1    i,j:1->4
-//
-// Column-vector access:
-// USet Get/SetBaseVec(), Get/SetPos() and Arr[XYZT]() methods.
-//
-// For all methods taking the matrix indices:
-// 1->X, 2->Y, 3->Z; 4->Position (if applicable). 0 reserved for time.
-//
-// Shorthands in method-names:
-// LF ~ LocalFrame; PF ~ ParentFrame; IP ~ InPlace
-
 #include "TEveTrans.h"
 #include "TEveUtil.h"
+#include "TEveVSDStructs.h"
 #include "TMath.h"
 #include "TClass.h"
 
@@ -63,7 +38,32 @@
 #define F32 11
 #define F33 15
 
-ClassImp(TEveTrans)
+//______________________________________________________________________________
+//
+// TEveTrans is a 4x4 transformation matrix for homogeneous coordinates
+// stored internaly in a column-major order to allow direct usage by
+// GL. The element type is Double32_t as statically the floats would
+// be precise enough but continuous operations on the matrix must
+// retain precision of column vectors.
+//
+// Cartan angles are stored in fA[1-3] (+z, -y, +x). They are
+// recalculated on demand.
+//
+// Direct  element access (first two should be used with care):
+// operator[i]    direct access to elements,   i:0->15
+// CM(i,j)        element 4*j + i;           i,j:0->3    { CM ~ c-matrix }
+// operator(i,j)  element 4*(j-1) + i - 1    i,j:1->4
+//
+// Column-vector access:
+// USet Get/SetBaseVec(), Get/SetPos() and Arr[XYZT]() methods.
+//
+// For all methods taking the matrix indices:
+// 1->X, 2->Y, 3->Z; 4->Position (if applicable). 0 reserved for time.
+//
+// Shorthands in method-names:
+// LF ~ LocalFrame; PF ~ ParentFrame; IP ~ InPlace
+
+ClassImp(TEveTrans);
 
 //______________________________________________________________________________
 TEveTrans::TEveTrans() :
@@ -129,6 +129,18 @@ void TEveTrans::UnitTrans()
 }
 
 //______________________________________________________________________________
+void TEveTrans::ZeroTrans(Double_t w)
+{
+   // Reset matrix to zero, only the perspective scaling is set to w
+   // (1 by default).
+
+   memset(fM, 0, 16*sizeof(Double_t));
+   fM[F33] = w;
+   fA1 = fA2 = fA3 = 0;
+   fAsOK = kFALSE;
+}
+
+//______________________________________________________________________________
 void TEveTrans::UnitRot()
 {
    // Reset rotation part of the matrix to unity.
@@ -187,6 +199,94 @@ void TEveTrans::SetupRotation(Int_t i, Int_t j, Double_t f)
    fAsOK = kFALSE;
 }
 
+//______________________________________________________________________________
+void TEveTrans::SetupFromToVec(const TEveVector& from, const TEveVector& to)
+{
+   // A function for creating a rotation matrix that rotates a vector called
+   // "from" into another vector called "to".
+   // Input : from[3], to[3] which both must be *normalized* non-zero vectors
+   // Output: mtx[3][3] -- a 3x3 matrix in colum-major form
+   // Authors: Tomas Mller, John Hughes
+   //          "Efficiently Building a Matrix to Rotate One Vector to Another"
+   //          Journal of Graphics Tools, 4(4):1-4, 1999
+
+   static const float kFromToEpsilon = 0.000001f;
+
+   ZeroTrans();
+
+   Float_t e, f;
+   e = from.Dot(to);
+   f = (e < 0.0f) ? -e : e;
+
+   if (f > 1.0f - kFromToEpsilon) /* "from" and "to"-vector almost parallel */
+   {
+      TEveVector u, v;       /* temporary storage vectors */
+      TEveVector x;          /* vector most nearly orthogonal to "from" */
+      Float_t    c1, c2, c3; /* coefficients for later use */
+
+      x.fX = (from.fX > 0.0f) ? from.fX : -from.fX;
+      x.fY = (from.fY > 0.0f) ? from.fY : -from.fY;
+      x.fZ = (from.fZ > 0.0f) ? from.fZ : -from.fZ;
+
+      if (x.fX < x.fY)
+      {
+         if (x.fX < x.fZ) {
+            x.fX = 1.0f; x.fY = x.fZ = 0.0f;
+         } else {
+            x.fZ = 1.0f; x.fX = x.fY = 0.0f;
+         }
+      }
+      else
+      {
+         if (x.fY < x.fZ) {
+            x.fY = 1.0f; x.fX = x.fZ = 0.0f;
+         } else {
+            x.fZ = 1.0f; x.fX = x.fY = 0.0f;
+         }
+      }
+
+      u.Sub(x, from);
+      v.Sub(x, to);
+
+      c1 = 2.0f / u.Mag2();
+      c2 = 2.0f / v.Mag2();
+      c3 = c1 * c2  * u.Dot(v);
+
+      for (int i = 0; i < 3; i++) {
+         for (int j = 0; j < 3; j++) {
+            CM(i, j) =  - c1 * u[i] * u[j]
+               - c2 * v[i] * v[j]
+               + c3 * v[i] * u[j];
+         }
+         CM(i, i) += 1.0;
+      }
+   }
+   else  /* the most common case, unless "from"="to", or "from"=-"to" */
+   {
+      TEveVector v = from.Cross(to);
+
+      Float_t h, hvx, hvz, hvxy, hvxz, hvyz;
+      h   = 1.0f/(1.0f + e);
+      hvx = h * v.fX;
+      hvz = h * v.fZ;
+      hvxy = hvx * v.fY;
+      hvxz = hvx * v.fZ;
+      hvyz = hvz * v.fY;
+
+      CM(0, 0) = e + hvx * v.fX;
+      CM(0, 1) = hvxy - v.fZ;
+      CM(0, 2) = hvxz + v.fY;
+
+      CM(1, 0) = hvxy + v.fZ;
+      CM(1, 1) = e + h * v.fY * v.fY;
+      CM(1, 2) = hvyz - v.fX;
+
+      CM(2, 0) = hvxz - v.fY;
+      CM(2, 1) = hvyz + v.fX;
+      CM(2, 2) = e + hvz * v.fZ;
+   }
+}
+
 /******************************************************************************/
 
 // OrtoNorm3 and Invert are near the bottom.
@@ -713,10 +813,34 @@ void TEveTrans::RotateIP(TVector3& v) const
 }
 
 //______________________________________________________________________________
-TVector3 TEveTrans::Rotate(const TVector3& v) const
+void TEveTrans::RotateIP(Double_t* v) const
+{
+   // Rotate vector in-place. Translation is NOT applied.
+
+   Double_t t[3] = { v[0], v[1], v[2] };
+
+   v[0] = fM[F00]*t[0] + fM[F01]*t[1] + fM[F02]*t[2];
+   v[1] = fM[F10]*t[0] + fM[F11]*t[1] + fM[F12]*t[2];
+   v[2] = fM[F20]*t[0] + fM[F21]*t[1] + fM[F22]*t[2];
+}
+
+//______________________________________________________________________________
+void TEveTrans::RotateIP(TEveVector& v) const
 {
    // Rotate vector in-place. Translation is NOT applied.
 
+   Double_t t[3] = { v.fX, v.fY, v.fZ };
+
+   v.Set(fM[F00]*t[0] + fM[F01]*t[1] + fM[F02]*t[2],
+         fM[F10]*t[0] + fM[F11]*t[1] + fM[F12]*t[2],
+         fM[F20]*t[0] + fM[F21]*t[1] + fM[F22]*t[2]);
+}
+
+//______________________________________________________________________________
+TVector3 TEveTrans::Rotate(const TVector3& v) const
+{
+   // Rotate vector and return the rotated vector. Translation is NOT applied.
+
    return TVector3(fM[F00]*v.x() + fM[F01]*v.y() + fM[F02]*v.z(),
                    fM[F10]*v.x() + fM[F11]*v.y() + fM[F12]*v.z(),
                    fM[F20]*v.x() + fM[F21]*v.y() + fM[F22]*v.z());
diff --git a/graf3d/eve/src/TEveUtil.cxx b/graf3d/eve/src/TEveUtil.cxx
index 5e8d25b..0c360e3 100644
--- a/graf3d/eve/src/TEveUtil.cxx
+++ b/graf3d/eve/src/TEveUtil.cxx
@@ -14,7 +14,6 @@
 #include "TEveManager.h"
 
 #include "TError.h"
-#include "TPad.h"
 #include "TGeoManager.h"
 #include "TClass.h"
 #include "TMath.h"
diff --git a/graf3d/eve/src/TEveVSDStructs.cxx b/graf3d/eve/src/TEveVSDStructs.cxx
index 324023e..c7e19ae 100644
--- a/graf3d/eve/src/TEveVSDStructs.cxx
+++ b/graf3d/eve/src/TEveVSDStructs.cxx
@@ -132,7 +132,8 @@ void TEveVector4::Dump() const
 //______________________________________________________________________________
 //
 // Special-point on track:
-//  kDaughter  - daughter creation; fP is momentum of the daughter
+//  kDaughter  - daughter creation; fP is momentum of the daughter, it is subtracted from
+//               momentum of the track
 //  kReference - position/momentum reference
 //  kDecay     - decay point, fP not used
 //  kCluster2D - measurement with large error in one direction (like strip detectors):
diff --git a/graf3d/eve/src/TEveWindow.cxx b/graf3d/eve/src/TEveWindow.cxx
index 9d3675d..51949c5 100644
--- a/graf3d/eve/src/TEveWindow.cxx
+++ b/graf3d/eve/src/TEveWindow.cxx
@@ -505,7 +505,7 @@ void TEveCompositeFrameInMainFrame::MainFrameClosed()
          swapCandidate =  gEve->GetWindowManager()->GetDefaultContainer()->NewSlot();
       }
 
-      if( swapCandidate )
+      if (swapCandidate)
       {
          TEveWindow::SwapWindows(fEveWindow, swapCandidate);
          gEve->GetWindowManager()->WindowDocked(fEveWindow );
diff --git a/graf3d/gl/inc/LinkDef.h b/graf3d/gl/inc/LinkDef.h
index 1020123..2f05098 100644
--- a/graf3d/gl/inc/LinkDef.h
+++ b/graf3d/gl/inc/LinkDef.h
@@ -130,6 +130,7 @@
 #endif
 
 #pragma link C++ class TGLObject+;
+#pragma link C++ class TGLPlot3D+;
 #pragma link C++ class TPointSet3DGL+;
 
 #pragma link C++ class TGLFont;
diff --git a/graf3d/gl/inc/TF2GL.h b/graf3d/gl/inc/TF2GL.h
index 12fa141..6d8edac 100644
--- a/graf3d/gl/inc/TF2GL.h
+++ b/graf3d/gl/inc/TF2GL.h
@@ -12,15 +12,13 @@
 #ifndef ROOT_TF2GL
 #define ROOT_TF2GL
 
-#include <TGLObject.h>
+#include <TGLPlot3D.h>
 
 class TGLRnrCtx;
 class TF2;
 class TH2;
 
-#include "TGLPlotPainter.h"
-
-class TF2GL : public TGLObject
+class TF2GL : public TGLPlot3D
 {
 private:
    TF2GL(const TF2GL&);            // Not implemented
@@ -30,9 +28,6 @@ protected:
    TF2                *fM; // fModel dynamic-casted to TH2
    TH2                *fH; // Visualization histogram.
 
-   TGLPlotPainter     *fPlotPainter;
-   TGLPlotCoordinates  fCoord;
-
 public:
    TF2GL();
    virtual ~TF2GL();
diff --git a/graf3d/gl/inc/TGLAxisPainter.h b/graf3d/gl/inc/TGLAxisPainter.h
index 25677f8..047644f 100644
--- a/graf3d/gl/inc/TGLAxisPainter.h
+++ b/graf3d/gl/inc/TGLAxisPainter.h
@@ -53,6 +53,7 @@ private:
 
 protected:
    TAttAxis        *fAttAxis;    // Model.
+   Bool_t           fUseAxisColors; // Use colors from axes or from GL-rnr-ctx.
    TGLFont::EMode   fFontMode;   // To be put into TAttAxis
    LabVec_t         fLabVec;     // List of Labels position-value pairs
    TMVec_t          fTMVec;      // List of tick-mark position-value pairs
@@ -107,6 +108,9 @@ public:
    void      SetAttAxis(TAttAxis* a) { fAttAxis = a; }
    TAttAxis* GetAttAxis() { return fAttAxis; }
 
+   void   SetUseAxisColors(Bool_t x) { fUseAxisColors = x;    }
+   Bool_t GetUseAxisColors() const   { return fUseAxisColors; }
+
    // Utility.
    void SetLabelFont(TGLRnrCtx &rnrCtx, const char* fontName, Int_t pixelSize = 64, Double_t font3DSize = -1);
    void SetTitleFont(TGLRnrCtx &rnrCtx, const char* fontName, Int_t pixelSize = 64, Double_t font3DSize = -1);
diff --git a/graf3d/gl/inc/TGLBoundingBox.h b/graf3d/gl/inc/TGLBoundingBox.h
index 60661b7..28b07a3 100644
--- a/graf3d/gl/inc/TGLBoundingBox.h
+++ b/graf3d/gl/inc/TGLBoundingBox.h
@@ -86,6 +86,7 @@ public:
    void SetAligned(const TGLVertex3 & lowVertex, const TGLVertex3 & highVertex); // axis aligned
    void SetAligned(UInt_t nbPnts, const Double_t * pnts); // axis aligned
    void MergeAligned(const TGLBoundingBox & other);
+   void ExpandAligned(const TGLVertex3 & point);
 
    // Manipulation
    void Transform(const TGLMatrix & matrix);
@@ -203,10 +204,10 @@ inline const TGLVector3 & TGLBoundingBox::Axis(UInt_t i, Bool_t normalised) cons
 //______________________________________________________________________________
 inline Bool_t TGLBoundingBox::IsEmpty() const
 {
-   // Return kTRUE if box has zero volume - kFALSE otherwise
+   // Return kTRUE if box has zero diagonal - kFALSE otherwise
 
    // TODO: Round errors - should have epsilon test
-   return (Volume() == 0.0);
+   return (Diagonal() == 0.0);
 }
 
 #endif // ROOT_TGLBoundingBox
diff --git a/graf3d/gl/inc/TGLCamera.h b/graf3d/gl/inc/TGLCamera.h
index 84ad2eb..6e59ef8 100644
--- a/graf3d/gl/inc/TGLCamera.h
+++ b/graf3d/gl/inc/TGLCamera.h
@@ -99,8 +99,8 @@ protected:
    TGLRect   fViewport;    //! viewport (GL coords - origin bottom left)
 
    TGLBoundingBox   fInterestBox;          //! the interest box - created in UpdateInterest()
-   mutable Double_t fLargestSeen;          //! largest box volume seen in OfInterest() - used when
-                                           // bootstrapping interest box
+   mutable Double_t fLargestSeen;          //! largest box diagonal seen in OfInterest() - used when
+                                           //! bootstrapping interest box
 
    // Internal cache update - const as the actual camera configuration is unaffected
    void       UpdateCache() const;
diff --git a/graf3d/gl/inc/TGLCameraOverlay.h b/graf3d/gl/inc/TGLCameraOverlay.h
index cbf70af..c58256b 100644
--- a/graf3d/gl/inc/TGLCameraOverlay.h
+++ b/graf3d/gl/inc/TGLCameraOverlay.h
@@ -25,7 +25,7 @@ class TAxis;
 class TGLCameraOverlay : public TGLOverlayElement
 {
 public:
-   enum EMode { kPlaneIntersect, kBar, kAxis };
+   enum EMode { kPlaneIntersect, kBar, kAxis, kGridFront, kGridBack };
 
 private:
    TGLCameraOverlay(const TGLCameraOverlay&);            // Not implemented
@@ -43,12 +43,14 @@ protected:
    TGLAxisPainter *fAxisPainter;
    TAxis          *fAxis;
    Float_t         fAxisExtend;
+   Bool_t          fUseAxisColors;
 
    TGLPlane       fExternalRefPlane;
    Bool_t         fUseExternalRefPlane;
 
    void    RenderPlaneIntersect(TGLRnrCtx& rnrCtx);
-   void    RenderAxis(TGLRnrCtx& rnrCtx);
+   void    RenderAxis(TGLRnrCtx& rnrCtx, Bool_t drawGrid);
+   void    RenderGrid(TGLRnrCtx& rnrCtx);
    void    RenderBar(TGLRnrCtx& rnrCtx);
 
 public:
diff --git a/graf3d/gl/inc/TGLObject.h b/graf3d/gl/inc/TGLObject.h
index 271f22c..8dfca95 100644
--- a/graf3d/gl/inc/TGLObject.h
+++ b/graf3d/gl/inc/TGLObject.h
@@ -13,7 +13,7 @@
 #define ROOT_TGLObject
 
 #include "TGLLogicalShape.h"
-#include <TMap.h>
+#include "TMap.h"
 
 class TClass;
 
diff --git a/graf3d/gl/inc/TGLParametricEquationGL.h b/graf3d/gl/inc/TGLParametricEquationGL.h
index 42c11c4..744f433 100644
--- a/graf3d/gl/inc/TGLParametricEquationGL.h
+++ b/graf3d/gl/inc/TGLParametricEquationGL.h
@@ -12,19 +12,14 @@
 #ifndef ROOT_TGLParametricEquationGL
 #define ROOT_TGLParametricEquationGL
 
-#ifndef ROOT_TGLObject
-#include "TGLObject.h"
-#endif
-#ifndef ROOT_TGLPlotPainter
-#include "TGLPlotPainter.h"
-#endif
+#include "TGLPlot3D.h"
 
 class TGLRnrCtx;
 class TGLParametricEquation;
 class TH2;
 
 
-class TGLParametricEquationGL : public TGLObject
+class TGLParametricEquationGL : public TGLPlot3D
 {
 private:
    TGLParametricEquationGL(const TGLParametricEquationGL&);            // Not implemented
@@ -32,7 +27,6 @@ private:
 
 protected:
    TGLParametricEquation  *fM;
-   TGLPlotPainter         *fPlotPainter;
 
 public:
    TGLParametricEquationGL();
diff --git a/graf3d/gl/inc/TGLPlot3D.h b/graf3d/gl/inc/TGLPlot3D.h
new file mode 100644
index 0000000..f6862d3
--- /dev/null
+++ b/graf3d/gl/inc/TGLPlot3D.h
@@ -0,0 +1,46 @@
+// @(#)root/eve:$Id: TGLPlot3D.h 29909 2009-08-25 19:04:28Z matevz $
+// Author: Matevz Tadel 2007
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#ifndef ROOT_TGLPlot3D
+#define ROOT_TGLPlot3D
+
+#include "TGLObject.h"
+#include "TGLPlotPainter.h"
+
+class TVirtualPad;
+
+class TGLPlot3D : public TGLObject
+{
+private:
+   TGLPlot3D(const TGLPlot3D&);            // Not implemented
+   TGLPlot3D& operator=(const TGLPlot3D&); // Not implemented
+
+protected:
+   TGLPlotPainter     *fPlotPainter;
+   TGLPlotCoordinates  fCoord;
+
+   void SetPainter(TGLPlotPainter* p);
+
+   static TGLPlot3D* InstantiatePlot(TObject* obj);
+
+public:
+   TGLPlot3D();
+   virtual ~TGLPlot3D();
+
+   virtual Bool_t KeepDuringSmartRefresh() const { return kFALSE; }
+
+   static TGLPlot3D* CreatePlot(TObject* obj, const Option_t* opt, TVirtualPad* pad);
+   static TGLPlot3D* CreatePlot(TObject* obj, const Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz);
+
+   ClassDef(TGLPlot3D, 0); // Short description.
+};
+
+#endif
diff --git a/graf3d/gl/inc/TGLRnrCtx.h b/graf3d/gl/inc/TGLRnrCtx.h
index 0e8e932..08d4e51 100644
--- a/graf3d/gl/inc/TGLRnrCtx.h
+++ b/graf3d/gl/inc/TGLRnrCtx.h
@@ -100,6 +100,11 @@ protected:
    Short_t         fViewerStyle;
    Short_t         fSceneStyle;
 
+   Float_t         fViewerWFLineW;
+   Float_t         fSceneWFLineW;
+   Float_t         fViewerOLLineW;
+   Float_t         fSceneOLLineW;
+
    TGLClip        *fViewerClip;
    TGLClip        *fSceneClip;
    TGLClip        *fClip;
@@ -121,6 +126,7 @@ protected:
    TGLSelectBuffer*fSelectBuffer;
 
    lpTGLColorSet_t*fColorSetStack;
+   Float_t         fRenderScale;
 
    UInt_t          fEventKeySym;
 
@@ -171,6 +177,15 @@ public:
    Short_t SceneStyle()  const         { return fSceneStyle; }
    void    SetSceneStyle(Short_t sty)  { fSceneStyle = sty;  }
 
+   Float_t ViewerWFLineW()       const { return fViewerWFLineW; }
+   void    SetViewerWFLineW(Float_t w) { fViewerWFLineW = w;    }
+   Float_t SceneWFLineW()        const { return fSceneWFLineW;  }
+   void    SetSceneWFLineW(Float_t w)  { fSceneWFLineW = w;     }
+   Float_t ViewerOLLineW()       const { return fViewerOLLineW; }
+   void    SetViewerOLLineW(Float_t w) { fViewerOLLineW = w;    }
+   Float_t SceneOLLineW()        const { return fSceneOLLineW;  }
+   void    SetSceneOLLineW(Float_t w)  { fSceneOLLineW = w;     }
+
    TGLClip* ViewerClip()         const { return fViewerClip; }
    void     SetViewerClip(TGLClip *p)  { fViewerClip = p;    }
    TGLClip* SceneClip()          const { return fSceneClip;  }
@@ -218,6 +233,9 @@ public:
 
    void         ColorOrForeground(Color_t col);
 
+   Float_t GetRenderScale()    const { return fRenderScale; }
+   void    SetRenderScale(Float_t s) { fRenderScale = s; }
+
    UInt_t GetEventKeySym()   const { return fEventKeySym; }
    void   SetEventKeySym(UInt_t k) { fEventKeySym = k; }
 
diff --git a/graf3d/gl/inc/TGLScene.h b/graf3d/gl/inc/TGLScene.h
index c283f56..b83d35e 100644
--- a/graf3d/gl/inc/TGLScene.h
+++ b/graf3d/gl/inc/TGLScene.h
@@ -137,6 +137,9 @@ protected:
    Bool_t                    fInSmartRefresh;    //!
    mutable LogicalShapeMap_t fSmartRefreshCache; //!
 
+   // State that requires recreation of display-lists
+   Float_t                   fLastPointSizeScale;
+   Float_t                   fLastLineWidthScale;
 
    // ----------------------------------------------------------------
    // ----------------------------------------------------------------
@@ -203,7 +206,7 @@ public:
    virtual void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx=-1, UChar_t transp=0);
 
    virtual void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col);
-   virtual void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx=-1, UChar_t transp=0);
+   virtual void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp);
 
    // Temporary export for setting selected-state of physical shapes.
    LogicalShapeMap_t& RefLogicalShapes() { return fLogicalShapes; }
diff --git a/graf3d/gl/inc/TGLSceneBase.h b/graf3d/gl/inc/TGLSceneBase.h
index b3dfee5..95e22e9 100644
--- a/graf3d/gl/inc/TGLSceneBase.h
+++ b/graf3d/gl/inc/TGLSceneBase.h
@@ -45,6 +45,8 @@ protected:
    UInt_t             fMinorStamp;  // Counter increased on minimal update.
    Short_t            fLOD;         // Scene-lod.
    Short_t            fStyle;       // Scene-style.
+   Float_t            fWFLineW;     // Scene wire-frame line-width.
+   Float_t            fOLLineW;     // Scene outline line-width.
    TGLClip          * fClip;        // Scene clipping-plane.
    Bool_t             fSelectable;  // Objects in the scene are selectable.
 
diff --git a/graf3d/gl/inc/TGLSceneInfo.h b/graf3d/gl/inc/TGLSceneInfo.h
index 4a4e3f0..3c03d6e 100644
--- a/graf3d/gl/inc/TGLSceneInfo.h
+++ b/graf3d/gl/inc/TGLSceneInfo.h
@@ -37,16 +37,20 @@ private:
 protected:
    TGLViewerBase  * fViewer;
    TGLSceneBase   * fScene;
-   Bool_t           fActive;    // Show fScene in fViewer
+   Bool_t           fActive;      // Show fScene in fViewer
 
-   Short_t          fLOD;       // Optional override of scene lod
-   Short_t          fStyle;     // Optional override of scene style
-   TGLClip        * fClip;      // Optional override of clipping-plane
+   Short_t          fLOD;         // Optional override of scene lod
+   Short_t          fStyle;       // Optional override of scene style
+   Float_t          fWFLineW;     // Optional override of scene wire-frame line-width
+   Float_t          fOLLineW;     // Optional override of scene outline line-width
+   TGLClip        * fClip;        // Optional override of clipping-plane
 
-   Short_t          fLastLOD;   // Last combined viewer/scene lod   (set in scene::lodofy-scene-info).
-   Short_t          fLastStyle; // Last combined viewer/scene style (set in scene::pre-render).
-   TGLClip        * fLastClip;  // Last combined viewer/scene clip  (set in scene::update)
-   TGLCamera      * fLastCamera;// Last camera used.
+   Short_t          fLastLOD;     // Last combined viewer/scene lod   (set in scene::lodify-scene-info).
+   Short_t          fLastStyle;   // Last combined viewer/scene style (set in scene::pre-draw).
+   Float_t          fLastWFLineW; // Last combined viewer/scene wire-frame line-width (set in scene::pre-draw).
+   Float_t          fLastOLLineW; // Last combined viewer/scene outline line-width (set in scene::pre-draw).
+   TGLClip        * fLastClip;    // Last combined viewer/scene clip  (set in scene::update)
+   TGLCamera      * fLastCamera;  // Last camera used.
 
    UInt_t           fSceneStamp;  // Scene's time-stamp on last update.
    UInt_t           fClipStamp;   // Clip's time-stamp on last update.
@@ -109,6 +113,11 @@ public:
    Short_t  Style()        const { return fStyle; }
    void     SetStyle(Short_t st) { fStyle = st;   }
 
+   Float_t  WFLineW()       const { return fWFLineW; }
+   void     SetWFLineW(Float_t w) { fWFLineW = w;    }
+   Float_t  OLLineW()       const { return fOLLineW; }
+   void     SetOLLineW(Float_t w) { fOLLineW = w;    }
+
    TGLClip* Clip()         const { return fClip; }
    void     SetClip(TGLClip *p)  { fClip = p;    }
 
@@ -118,6 +127,11 @@ public:
    Short_t  LastStyle()      const   { return fLastStyle; }
    void     SetLastStyle(Short_t st) { fLastStyle = st;   }
 
+   Float_t  LastWFLineW()       const { return fLastWFLineW; }
+   void     SetLastWFLineW(Float_t w) { fLastWFLineW = w;    }
+   Float_t  LastOLLineW()       const { return fLastOLLineW; }
+   void     SetLastOLLineW(Float_t w) { fLastOLLineW = w;    }
+
    TGLClip* LastClip()         const { return fLastClip; }
    void     SetLastClip(TGLClip *p)  { fLastClip = p;    }
 
diff --git a/graf3d/gl/inc/TGLUtil.h b/graf3d/gl/inc/TGLUtil.h
index 42ade38..9b5c5bf 100644
--- a/graf3d/gl/inc/TGLUtil.h
+++ b/graf3d/gl/inc/TGLUtil.h
@@ -118,6 +118,7 @@ public:
    // Manipulators
    void Fill(Double_t val);
    void Set(Double_t x, Double_t y, Double_t z);
+   void Set(const Double_t* xyz);
    void Set(const TGLVertex3 & other);
    void Shift(TGLVector3 & shift);
    void Shift(Double_t xDelta, Double_t yDelta, Double_t zDelta);
@@ -228,6 +229,14 @@ inline void TGLVertex3::Set(Double_t x, Double_t y, Double_t z)
 }
 
 //______________________________________________________________________________
+inline void TGLVertex3::Set(const Double_t* xyz)
+{
+   fVals[0]=xyz[0];
+   fVals[1]=xyz[1];
+   fVals[2]=xyz[2];
+}
+
+//______________________________________________________________________________
 inline void TGLVertex3::Set(const TGLVertex3 & other)
 {
    fVals[0]=other.fVals[0];
@@ -954,6 +963,11 @@ private:
 
    static UInt_t fgColorLockCount;
 
+   static Float_t fgPointSize;
+   static Float_t fgLineWidth;
+   static Float_t fgPointSizeScale;
+   static Float_t fgLineWidthScale;
+
    TGLUtil(const TGLUtil&);            // Not implemented.
    TGLUtil& operator=(const TGLUtil&); // Not implemented.
 
@@ -997,6 +1011,17 @@ public:
    static void Color3fv(const Float_t* rgb);
    static void Color4fv(const Float_t* rgba);
 
+   static Float_t GetPointSizeScale();
+   static void    SetPointSizeScale(Float_t scale);
+   static Float_t GetLineWidthScale();
+   static void    SetLineWidthScale(Float_t scale);
+
+   static void    PointSize(Float_t point_size);
+   static void    LineWidth(Float_t line_width);
+
+   static Float_t PointSize();
+   static Float_t LineWidth();
+
    static void BeginExtendPickRegion(Float_t scale);
    static void EndExtendPickRegion();
 
@@ -1008,9 +1033,12 @@ public:
                             Bool_t sec_selection=kFALSE);
    static void RenderCrosses(const TAttMarker& marker, Float_t* p, Int_t n,
                              Bool_t sec_selection=kFALSE);
-   static void RenderPolyLine(const TAttLine& al, Float_t* p, Int_t n,
+   static void RenderPolyLine(const TAttLine& aline, Float_t* p, Int_t n,
                               Int_t pick_radius=0, Bool_t selection=kFALSE);
 
+   static void BeginAttLine(const TAttLine& aline, Int_t pick_radius=0, Bool_t selection=kFALSE);
+   static void EndAttLine(Int_t pick_radius=0, Bool_t selection=kFALSE);
+
    // TODO: These draw routines should take LOD hints
    static void SetDrawColors(const Float_t rgba[4]);
    static void DrawSphere(const TGLVertex3 & position, Double_t radius, const Float_t rgba[4]);
diff --git a/graf3d/gl/inc/TGLViewer.h b/graf3d/gl/inc/TGLViewer.h
index 338efbb..f52c05d 100644
--- a/graf3d/gl/inc/TGLViewer.h
+++ b/graf3d/gl/inc/TGLViewer.h
@@ -119,7 +119,9 @@ protected:
 
    TGLRect        fViewport;       //! viewport - drawn area
    TGLColorSet    fDarkColorSet;   //! color-set with dark background
-   TGLColorSet    fLightColorSet;  //! color-set with dark background
+   TGLColorSet    fLightColorSet;  //! color-set with light background
+   Float_t        fPointScale;     //! size scale for points
+   Float_t        fLineScale;      //! width scale for lines
    Int_t          fAxesType;       //! axes type
    Bool_t         fAxesDepthTest;  //! remove guides hidden-lines
    Bool_t         fReferenceOn;    //! reference marker on?
@@ -224,6 +226,12 @@ public:
    static void         UseDefaultColorSetForNewViewers(Bool_t x);
    static Bool_t       IsUsingDefaultColorSetForNewViewers();
 
+   Float_t GetPointScale()    const { return fPointScale; }
+   Float_t GetLineScale()     const { return fLineScale; }
+   void    SetPointScale(Float_t s) { fPointScale = s; }
+   void    SetLineScale (Float_t s) { fLineScale  = s; }
+
+
    TGLLightSet* GetLightSet() const { return fLightSet; }
    TGLClipSet * GetClipSet()  const { return fClipSet; }
    Bool_t GetClipAutoUpdate() const   { return fClipAutoUpdate; }
@@ -263,6 +271,7 @@ public:
    // Request methods post cross thread request via TROOT::ProcessLineFast().
    void RequestDraw(Short_t LOD = TGLRnrCtx::kLODMed); // Cross thread draw request
    virtual void PreRender();
+   virtual void PostRender();
    void DoDraw();
 
    void DrawGuides();
diff --git a/graf3d/gl/inc/TGLViewerBase.h b/graf3d/gl/inc/TGLViewerBase.h
index 01159b1..d285b8f 100644
--- a/graf3d/gl/inc/TGLViewerBase.h
+++ b/graf3d/gl/inc/TGLViewerBase.h
@@ -62,6 +62,8 @@ protected:
    TGLClip           *fClip;        // Viewer clipping-plane.
    Short_t            fLOD;         // Viewer-lod for rendering.
    Short_t            fStyle;       // Viewer-style for rendering.
+   Float_t            fWFLineW;     // Optional override of scene wire-frame line-width
+   Float_t            fOLLineW;     // Optional override of scene outline line-width
 
    Bool_t             fResetSceneInfosOnRender; // Request rebuild of view-specific scene data.
    Bool_t             fChanged;                 // Change requiring redraw is pending.
@@ -103,6 +105,11 @@ public:
    Short_t  Style()        const { return fStyle; }
    void     SetStyle(Short_t st) { fStyle = st;   }
 
+   Float_t  WFLineW()       const { return fWFLineW; }
+   void     SetWFLineW(Float_t w) { fWFLineW = w;    }
+   Float_t  OLLineW()       const { return fOLLineW; }
+   void     SetOLLineW(Float_t w) { fOLLineW = w;    }
+
    // ================================================================
 
    virtual void   ResetSceneInfos();
diff --git a/graf3d/gl/inc/TGLViewerEditor.h b/graf3d/gl/inc/TGLViewerEditor.h
index a88986e..638990e 100644
--- a/graf3d/gl/inc/TGLViewerEditor.h
+++ b/graf3d/gl/inc/TGLViewerEditor.h
@@ -44,6 +44,11 @@ private:
    TGNumberEntry    *fMaxSceneDrawTimeHQ;
    TGNumberEntry    *fMaxSceneDrawTimeLQ;
 
+   TGNumberEntry    *fPointSizeScale;
+   TGNumberEntry    *fLineWidthScale;
+   TGNumberEntry    *fWFLineWidth;
+   TGNumberEntry    *fOLLineWidth;
+
    //"Guides" tab's controls
    TGCheckButton    *fCameraCenterExt;
    TGTextButton     *fCaptureCenter;
@@ -105,6 +110,7 @@ public:
    void DoUpdateScene();
    void DoCameraHome();
    void UpdateMaxDrawTimes();
+   void UpdatePointLineStuff();
    void DoCameraCenterExt();
    void DoCaptureCenter();
    void DoAnnotation();
diff --git a/graf3d/gl/inc/TH2GL.h b/graf3d/gl/inc/TH2GL.h
index 84cb3d8..667a11c 100644
--- a/graf3d/gl/inc/TH2GL.h
+++ b/graf3d/gl/inc/TH2GL.h
@@ -12,7 +12,7 @@
 #ifndef ROOT_TH2GL
 #define ROOT_TH2GL
 
-#include <TGLObject.h>
+#include <TGLPlot3D.h>
 #include <TGLUtil.h>
 #include <TGLAxisPainter.h>
 
@@ -20,9 +20,7 @@ class TGLRnrCtx;
 class TH2;
 class TAxis;
 
-#include "TGLPlotPainter.h"
-
-class TH2GL : public TGLObject
+class TH2GL : public TGLPlot3D
 {
 private:
    TH2GL(const TH2GL&);            // Not implemented
@@ -31,9 +29,6 @@ private:
 protected:
    TH2                *fM; // Model object dynamic-casted to TH2.
 
-   TGLPlotPainter     *fPlotPainter;
-   TGLPlotCoordinates  fCoord;
-
 public:
    TH2GL();
    virtual ~TH2GL();
@@ -42,13 +37,11 @@ public:
    virtual void   SetBBox();
    virtual void   DirectDraw(TGLRnrCtx & rnrCtx) const;
 
-   virtual Bool_t KeepDuringSmartRefresh() const { return kFALSE; }
-
    // To support two-level selection
    // virtual Bool_t SupportsSecondarySelect() const { return kTRUE; }
    // virtual void ProcessSelection(UInt_t* ptr, TGLViewer*, TGLScene*);
 
-   ClassDef(TH2GL, 0); // GL renderer for TH2 and TH3.
+   ClassDef(TH2GL, 0); // GL renderer for TH2.
 }; // endclass TH2GL
 
 #endif
diff --git a/graf3d/gl/inc/TH3GL.h b/graf3d/gl/inc/TH3GL.h
index bc3c181..e424837 100644
--- a/graf3d/gl/inc/TH3GL.h
+++ b/graf3d/gl/inc/TH3GL.h
@@ -11,10 +11,9 @@
 #ifndef ROOT_TH3GL
 #define ROOT_TH3GL
 
-#include "TGLObject.h"
+#include "TGLPlot3D.h"
 #include <TGLUtil.h>
 #include <TGLAxisPainter.h>
-#include "TGLPlotPainter.h"
 
 class TGLRnrCtx;
 class TH3;
@@ -22,7 +21,7 @@ class TAxis;
 
 class TH3;
 
-class TH3GL : public TGLObject
+class TH3GL : public TGLPlot3D
 {
 private:
    TH3GL(const TH3GL&);            // Not implemented
@@ -31,9 +30,6 @@ private:
 protected:
    TH3                *fM;  // Model object dynamic-casted to TH2.
 
-   TGLPlotPainter     *fPlotPainter;
-   TGLPlotCoordinates  fCoord;
-
 public:
    TH3GL();
    virtual ~TH3GL();
diff --git a/graf3d/gl/src/TF2GL.cxx b/graf3d/gl/src/TF2GL.cxx
index 25579f2..32f43cc 100644
--- a/graf3d/gl/src/TF2GL.cxx
+++ b/graf3d/gl/src/TF2GL.cxx
@@ -32,11 +32,9 @@
 ClassImp(TF2GL);
 
 //______________________________________________________________________________
-TF2GL::TF2GL() : TGLObject(), fM(0), fH(0)
+TF2GL::TF2GL() : TGLPlot3D(), fM(0), fH(0)
 {
    // Constructor.
-
-   fDLCache = kFALSE; // Disable display list.
 }
 
 //______________________________________________________________________________
@@ -45,7 +43,6 @@ TF2GL::~TF2GL()
    // Destructor.
 
    delete fH;
-   delete fPlotPainter;
 }
 
 /**************************************************************************/
@@ -58,21 +55,16 @@ Bool_t TF2GL::SetModel(TObject* obj, const Option_t* opt)
    TString option(opt);
    option.ToLower();
 
-   if(SetModelCheckClass(obj, TF2::Class()))
+   if (SetModelCheckClass(obj, TF2::Class()))
    {
       fM = dynamic_cast<TF2*>(obj);
       fH = (TH2*) fM->CreateHistogram();
       fH->GetZaxis()->SetLimits(fH->GetMinimum(), fH->GetMaximum());
 
       if (dynamic_cast<TF3*>(fM))
-         fPlotPainter = new TGLTF3Painter((TF3*)fM, fH, 0, &fCoord);
+         SetPainter( new TGLTF3Painter((TF3*)fM, fH, 0, &fCoord) );
       else
-         fPlotPainter = new TGLSurfacePainter(fH, 0, &fCoord);
-
-      // Coord-system
-      fCoord.SetXLog(gPad->GetLogx());
-      fCoord.SetYLog(gPad->GetLogy());
-      fCoord.SetZLog(gPad->GetLogz());
+         SetPainter( new TGLSurfacePainter(fH, 0, &fCoord) );
 
       if (option.Index("sph") != kNPOS)
          fCoord.SetCoordType(kGLSpherical);
@@ -117,6 +109,7 @@ void TF2GL::DirectDraw(TGLRnrCtx & rnrCtx) const
 
    // Axes
    TGLAxisPainterBox axe_painter;
+   axe_painter.SetUseAxisColors(kFALSE);
    axe_painter.SetFontMode(TGLFont::kPixmap);
    axe_painter.PlotStandard(rnrCtx, fH, fBoundingBox);
 }
diff --git a/graf3d/gl/src/TGLAnnotation.cxx b/graf3d/gl/src/TGLAnnotation.cxx
index 0a5bbbc..8380619 100644
--- a/graf3d/gl/src/TGLAnnotation.cxx
+++ b/graf3d/gl/src/TGLAnnotation.cxx
@@ -213,7 +213,7 @@ void TGLAnnotation::Render(TGLRnrCtx& rnrCtx)
       glEnable(GL_POLYGON_OFFSET_FILL);
       glPolygonOffset(1, 1);
 
-      glLineWidth(1);
+      TGLUtil::LineWidth(1);
 
       // get size of bg area
       Float_t ascent, descent, line_height;
@@ -365,7 +365,7 @@ void TGLAnnotation::Render(TGLRnrCtx& rnrCtx)
 
    // line
    //
-   glLineWidth(2);
+   TGLUtil::LineWidth(2);
    TColor::Pixel2RGB(fActive ?fBackHighColor : fBackColor, r, g, b);
    TGLUtil::Color4f(r, g, b, fAlpha);
    glBegin(GL_LINES);
diff --git a/graf3d/gl/src/TGLAxis.cxx b/graf3d/gl/src/TGLAxis.cxx
index 9381ba5..373e33d 100644
--- a/graf3d/gl/src/TGLAxis.cxx
+++ b/graf3d/gl/src/TGLAxis.cxx
@@ -12,6 +12,7 @@
 #include "TROOT.h"
 
 #include "TGLIncludes.h"
+#include "TGLUtil.h"
 #include "TGLAxis.h"
 #include "TGLText.h"
 #include "TColor.h"
@@ -171,7 +172,7 @@ void TGLAxis::PaintGLAxisBody()
    col = gROOT->GetColor(GetLineColor());
    col->GetRGB(red, green, blue);
    glColor3d(red, green, blue);
-   glLineWidth(GetLineWidth());
+   TGLUtil::LineWidth(GetLineWidth());
    glBegin(GL_LINES);
    glVertex3d(0., 0., 0.);
    glVertex3d(fAxisLength, 0., 0.);
diff --git a/graf3d/gl/src/TGLAxisPainter.cxx b/graf3d/gl/src/TGLAxisPainter.cxx
index cc17c2e..1c57d0c 100644
--- a/graf3d/gl/src/TGLAxisPainter.cxx
+++ b/graf3d/gl/src/TGLAxisPainter.cxx
@@ -41,7 +41,7 @@ TGLAxisPainter::TGLAxisPainter():
    fMaxDigits(5),
    fDecimals(0),
 
-   fAttAxis(0),
+   fAttAxis(0), fUseAxisColors(kTRUE),
 
    fFontMode(TGLFont::kTexture),
    fDir(1, 0, 0),
@@ -265,7 +265,8 @@ void TGLAxisPainter::RnrLabels() const
 {
    // Render label reading prepared list ov value-pos pairs.
 
-   TGLUtil::Color(fAttAxis->GetLabelColor());
+   if (fUseAxisColors)
+      TGLUtil::Color(fAttAxis->GetLabelColor());
 
    glPushMatrix();
 
@@ -311,7 +312,9 @@ void TGLAxisPainter::RnrTitle(const char* txt, TGLVector3 &pos , TGLFont::ETextA
 {
    // Draw title at given position.
 
-   TGLUtil::Color(fAttAxis->GetTitleColor());
+   if (fUseAxisColors)
+      TGLUtil::Color(fAttAxis->GetTitleColor());
+
    const char* title = (fExp) ? Form("%s [10^%d]", fExp, txt) : txt;
    fTitleFont.PreRender();
    RnrText(title, pos, align, fTitleFont);
@@ -323,7 +326,9 @@ void TGLAxisPainter::RnrLines() const
 {
    // Render axis main line and tickmarks.
 
-   TGLUtil::Color(fAttAxis->GetAxisColor());
+   if (fUseAxisColors)
+      TGLUtil::Color(fAttAxis->GetAxisColor());
+
    glBegin(GL_LINES);
 
    // Main line.
@@ -463,6 +468,9 @@ void TGLAxisPainter::PaintAxis(TGLRnrCtx &rnrCtx, TAxis* ax)
    //______________________________________________________________________________
    // Draw.
 
+   if (!fUseAxisColors)
+      TGLUtil::Color(rnrCtx.ColorSet().Markup());
+
    glDisable(GL_LIGHTING);
    RnrLines();
    RnrLabels();
diff --git a/graf3d/gl/src/TGLBoundingBox.cxx b/graf3d/gl/src/TGLBoundingBox.cxx
index a240695..76f3080 100644
--- a/graf3d/gl/src/TGLBoundingBox.cxx
+++ b/graf3d/gl/src/TGLBoundingBox.cxx
@@ -261,6 +261,21 @@ void TGLBoundingBox::MergeAligned(const TGLBoundingBox & other)
 }
 
 //______________________________________________________________________________
+void TGLBoundingBox::ExpandAligned(const TGLVertex3 & point)
+{
+   // Expand current bbox so that it includes the point.
+   // This make the bbox axis-aligned.
+
+   TGLVertex3 low (MinAAVertex());
+   TGLVertex3 high(MaxAAVertex());
+
+   low .Minimum(point);
+   high.Maximum(point);
+
+   SetAligned(low, high);
+}
+
+//______________________________________________________________________________
 void TGLBoundingBox::Scale(Double_t factor)
 {
    // Isotropically scale bounding box along it's LOCAL axes, preserving center
@@ -724,6 +739,7 @@ Double_t TGLBoundingBox::Max(UInt_t index) const
    return max;
 }
 
+//______________________________________________________________________________
 TGLVertex3 TGLBoundingBox::MinAAVertex() const
 {
    // Find minimum vertex values.
@@ -731,6 +747,7 @@ TGLVertex3 TGLBoundingBox::MinAAVertex() const
    return TGLVertex3(Min(0), Min(1), Min(2));
 }
 
+//______________________________________________________________________________
 TGLVertex3 TGLBoundingBox::MaxAAVertex() const
 {
    // Find maximum vertex values.
@@ -745,8 +762,8 @@ void TGLBoundingBox::Dump() const
    for (UInt_t i = 0; i<8; i++) {
       std::cout << "[" << i << "] (" << fVertex[i].X() << "," << fVertex[i].Y() << "," << fVertex[i].Z() << ")" << std::endl;
    }
-   std::cout << "Center ";
-   Center().Dump();
-   std::cout << " Volume " << Volume() << std::endl;
+   std::cout << "Center:  ";   Center().Dump();
+   std::cout << "Extents: ";   Extents().Dump();
+   std::cout << "Volume:  " << Volume() << std::endl;
 }
 
diff --git a/graf3d/gl/src/TGLCamera.cxx b/graf3d/gl/src/TGLCamera.cxx
index f76ed2b..3644942 100644
--- a/graf3d/gl/src/TGLCamera.cxx
+++ b/graf3d/gl/src/TGLCamera.cxx
@@ -570,7 +570,7 @@ Bool_t TGLCamera::OfInterest(const TGLBoundingBox & box, Bool_t ignoreSize) cons
    // interest box, made from a properly setup camera frustum - catch
    // 22.
    //
-   // To overcome this we track the largest box volume seen so far and
+   // To overcome this we track the largest box diagonal seen so far and
    // regard anything over 0.001 of this as 'of interest'. This enables
    // us to get a roughly populated scene with largest objects, setup
    // the camera, and do first draw.  We then do a
@@ -579,9 +579,9 @@ Bool_t TGLCamera::OfInterest(const TGLBoundingBox & box, Bool_t ignoreSize) cons
    // finally setup camera properly.
 
    if (fInterestBox.IsEmpty()) {
-      if (box.Volume() >= fLargestSeen * 0.001) {
-         if (box.Volume() > fLargestSeen) {
-            fLargestSeen = box.Volume();
+      if (box.Diagonal() >= fLargestSeen * 0.001) {
+         if (box.Diagonal() > fLargestSeen) {
+            fLargestSeen = box.Diagonal();
          }
          interest = kTRUE;
       }
@@ -673,7 +673,8 @@ void TGLCamera::ResetInterest()
    // Clear out the existing interest box
    fInterestBox.SetEmpty();
 
-   // We also reset the bootstrapping variable - see TGLCamera::OfInterest comments
+   // We also reset the bootstrapping variable - see
+   // TGLCamera::OfInterest comments.
    fLargestSeen = 0.0;
 }
 
diff --git a/graf3d/gl/src/TGLCameraOverlay.cxx b/graf3d/gl/src/TGLCameraOverlay.cxx
index d4dbe2a..91a1e58 100644
--- a/graf3d/gl/src/TGLCameraOverlay.cxx
+++ b/graf3d/gl/src/TGLCameraOverlay.cxx
@@ -20,6 +20,7 @@
 
 #include "TMath.h"
 #include "TAxis.h"
+#include "THLimitsFinder.h"
 
 //______________________________________________________________________________
 // A GL overlay element which displays camera furstum.
@@ -40,6 +41,7 @@ TGLCameraOverlay::TGLCameraOverlay(Bool_t showOrtho, Bool_t showPersp) :
    fAxisPainter(0),
    fAxis(0),
    fAxisExtend(0.9),
+   fUseAxisColors(kFALSE),
 
    fExternalRefPlane(),
    fUseExternalRefPlane(kFALSE)
@@ -110,7 +112,6 @@ void TGLCameraOverlay::RenderPlaneIntersect(TGLRnrCtx& rnrCtx)
       font.BBox(txt, bb[0], bb[1], bb[2], bb[3], bb[4], bb[5]);
       Float_t off = 1.5*bb[4];
       off /= vp.Height() ;
-      TGLUtil::Color(kGray);
       font.RenderBitmap(txt, 1 -off, 1-off, 0,TGLFont::kRight);
 
       // render cross
@@ -140,79 +141,200 @@ void TGLCameraOverlay::RenderPlaneIntersect(TGLRnrCtx& rnrCtx)
 }
 
 //______________________________________________________________________________
-void TGLCameraOverlay::RenderAxis(TGLRnrCtx& rnrCtx)
+void TGLCameraOverlay::RenderAxis(TGLRnrCtx& rnrCtx, Bool_t grid)
 {
-   // Draw axis on four edges.
+   // Draw axis on four edges and a transparent grid.
 
-   // All four axis has to have same font.
-   // Size of font calculated relative to viewport diagonal
    fAxisPainter->SetAttAxis(fAxis);
+   fAxisPainter->SetUseAxisColors(fUseAxisColors);
+
+   Color_t lineColor = fUseAxisColors ? fAxis->GetAxisColor() : rnrCtx.ColorSet().Foreground().GetColorIndex();
+
+   // font size calculated relative to viewport diagonal
    GLint   vp[4]; glGetIntegerv(GL_VIEWPORT, vp);
    Float_t rl = 0.5 *((vp[2]-vp[0]) + (vp[3]-vp[1]));
-   Int_t fsize = (Int_t)(fAxis->GetLabelSize()*rl);
+   Int_t fsizePx = (Int_t)(fAxis->GetLabelSize()*rl);
+   // tick length
    Float_t tlY = 0.015*rl/(vp[2]-vp[0]);
    Float_t tlX = 0.015*rl/(vp[3]-vp[1]);
+   // corner vectors
+   TGLVector3 xdir = rnrCtx.RefCamera().GetCamBase().GetBaseVec(2); xdir.Normalise(); // left
+   TGLVector3 ydir = rnrCtx.RefCamera().GetCamBase().GetBaseVec(3); ydir.Normalise(); // up
+   TGLVector3 vy1 = ydir * fFrustum[1];
+   TGLVector3 vy2 = ydir * fFrustum[3];
+   TGLVector3 vx1 = xdir * fFrustum[0];
+   TGLVector3 vx2 = xdir * fFrustum[2];
+   // range
+   Double_t rngY = fFrustum[3] - fFrustum[1];
+   Double_t rngX = fFrustum[2] - fFrustum[0];
+   Double_t off = TMath::Sqrt((rngX*rngY)+(rngX*rngY)) * 0.03;
+   Double_t minX = fFrustum[0] + off;
+   Double_t maxX = fFrustum[2] - off ;
+   Double_t minY = fFrustum[1] + off;
+   Double_t maxY = fFrustum[3] - off;
+   // grid lines
+   Char_t alpha = 70; //primary
+   Char_t alpha2 = 80; //seconndary
+   Int_t secSteps = fAxis->GetNdivisions() % 100;
+   GLushort stipple =  0x5555; // 33333 more rare
 
-
-   TGLVector3 xdir = rnrCtx.RefCamera().GetCamBase().GetBaseVec(2); // left
-   TGLVector3 ydir = rnrCtx.RefCamera().GetCamBase().GetBaseVec(3); // up
-   xdir.Normalise();
-   ydir.Normalise();
-   Float_t tms = 0;
    // horizontal X
    //
+   fAxisPainter->SetLabelPixelFontSize(fsizePx);
+   fAxis->SetTickLength(tlX);
+   fAxisPainter->RefDir() = xdir;
+   fAxis->SetLimits(minX, maxX);
+   fAxisPainter->RefTMOff(0) = ydir*rngY;
+
+   // bottom
+   glPushMatrix();
+   glTranslated(vy1.X(), vy1.Y(), vy1.Z());
+   fAxisPainter->SetLabelAlign(TGLFont::kCenterDown);
+   fAxisPainter->PaintAxis(rnrCtx, fAxis);
+   glPopMatrix();
+
+   // top
+   glPushMatrix();
+   glTranslated(vy2.X(), vy2.Y(), vy2.Z());
+   fAxisPainter->SetLabelAlign(TGLFont::kCenterUp);
+   fAxisPainter->RefTMOff(0).Negate();
+   fAxisPainter->RnrLabels();
+   fAxisPainter->RnrLines();
+   glPopMatrix();
+
+   if (grid)
    {
-      fAxisPainter->SetLabelPixelFontSize(fsize);
-      fAxis->SetTickLength(tlX);
-      fAxisPainter->RefDir() = xdir;
-      Float_t axisXOff = (fFrustum[2] - fFrustum[0]) * (1 - fAxisExtend);
-      fAxis->SetLimits(fFrustum[0] + axisXOff, fFrustum[2] - axisXOff);
-      fAxis->SetRangeUser(fFrustum[0] + axisXOff, fFrustum[2] - axisXOff);
-      tms = fFrustum[3] - fFrustum[1];
-      fAxisPainter->RefTMOff(0) = ydir*tms;
-
-      // bottom
-      glPushMatrix();
-      glTranslated(ydir.X()*fFrustum[1], ydir.Y()*fFrustum[1], ydir.Z()*fFrustum[1]);
-      fAxisPainter->SetLabelAlign(TGLFont::kCenterDown);
-      fAxisPainter->PaintAxis(rnrCtx, fAxis);
-      glPopMatrix();
+      TGLAxisPainter::LabVec_t& labs = fAxisPainter->RefLabVec();
+      TGLVector3 tmp;
+      // draw label vertical lines
+      TGLUtil::ColorTransparency(lineColor, alpha);
+      glBegin(GL_LINES);
+      for ( TGLAxisPainter::LabVec_t::iterator i = labs.begin(); i != labs.end(); i++)
+      {
+         tmp = vy1 + xdir * (i->first);
+         glVertex3dv(tmp.Arr());
+         tmp = vy2 + xdir * (i->first);
+         glVertex3dv(tmp.Arr());
+      }
+      glEnd();
 
-      // top
-      glPushMatrix();
-      glTranslated(ydir.X()*fFrustum[3], ydir.Y()*fFrustum[3], ydir.Z()*fFrustum[3]);
-      fAxisPainter->SetLabelAlign(TGLFont::kCenterUp);
-      fAxisPainter->RefTMOff(0).Negate();
-      fAxisPainter->RnrLabels();
-      fAxisPainter->RnrLines();
-      glPopMatrix();
-   }
+      // secondary tick mark lines
+      if (labs.size() > 1)
+      {
+         TGLUtil::ColorTransparency(lineColor, alpha2);
+         glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT);
+         glEnable(GL_LINE_STIPPLE);
+         glLineStipple(1, stipple);
+
+         glBegin(GL_LINES);
+         Int_t ondiv;
+         Double_t omin, omax, bw1;
+         Double_t val =0;
+         THLimitsFinder::Optimize(labs[0].second, labs[1].second, secSteps, omin, omax, ondiv, bw1);
+         val =  labs[0].second;
+         while(val < fFrustum[2])
+         {
+            for(Int_t k=0; k<ondiv; k++)
+            {
+               val += bw1;
+               tmp = vy1 + xdir * val;
+               glVertex3dv(tmp.Arr());
+               tmp = vy2 + xdir * val;
+               glVertex3dv(tmp.Arr());
+            }
+         }
+         val = labs[0].second - bw1;
+         while(val > fFrustum[0])
+         {
+            tmp = vy1 + xdir * val;
+            glVertex3dv(tmp.Arr());
+            tmp = vy2 + xdir * val;
+            glVertex3dv(tmp.Arr());
+            val -= bw1;
+         }
+         glEnd();
+         glPopAttrib();
+      }
+   } // draw grid
 
    //
-   // vertical Y
+   // vertical Y axis
+   //
+
+   fAxis->SetTickLength(tlY);
+   fAxisPainter->RefDir() = ydir;
+   fAxis->SetLimits(minY, maxY);
+   fAxisPainter->RefTMOff(0) = xdir*rngX;
+   // left
+   glPushMatrix();
+   glTranslated(vx1.X(), vx1.Y(), vx1.Z());
+   fAxisPainter->SetLabelAlign(TGLFont::kLeft);
+   fAxisPainter->PaintAxis(rnrCtx, fAxis);
+   glPopMatrix();
+   // right
+   glPushMatrix();
+   glTranslated(vx2.X(), vx2.Y(), vx2.Z());
+   fAxisPainter->SetLabelAlign(TGLFont::kRight);
+   fAxisPainter->RefTMOff(0).Negate();
+   fAxisPainter->RnrLabels();
+   fAxisPainter->RnrLines();
+   glPopMatrix();
+
+   if (grid)
    {
-      fAxis->SetTickLength(tlY);
-      fAxisPainter->RefDir() = ydir;
-      Float_t axisYOff = (fFrustum[3] - fFrustum[1]) * (1 - fAxisExtend);
-      fAxis->SetLimits(fFrustum[1] + axisYOff, fFrustum[3] - axisYOff);
-      tms = fFrustum[2] - fFrustum[0];
-      fAxisPainter->RefTMOff(0) = xdir*tms;
-
-      // left
-      glPushMatrix();
-      glTranslated(xdir.X()*fFrustum[0], xdir.Y()*fFrustum[0], xdir.Z()*fFrustum[0]);
-      fAxisPainter->SetLabelAlign(TGLFont::kLeft);
-      fAxisPainter->PaintAxis(rnrCtx, fAxis);
-      glPopMatrix();
-      // right
-      glPushMatrix();
-      glTranslated(xdir.X()*fFrustum[2], xdir.Y()*fFrustum[2], xdir.Z()*fFrustum[2]);
-      fAxisPainter->SetLabelAlign(TGLFont::kRight);
-      fAxisPainter->RefTMOff(0).Negate();
-      fAxisPainter->RnrLabels();
-      fAxisPainter->RnrLines();
-      glPopMatrix();
-   }
+      TGLAxisPainter::LabVec_t& labs = fAxisPainter->RefLabVec();
+      TGLVector3 tmp;
+      // draw label horizontal lines
+      TGLUtil::ColorTransparency(lineColor, alpha);
+      glBegin(GL_LINES);
+      for ( TGLAxisPainter::LabVec_t::iterator i = labs.begin(); i != labs.end(); i++)
+      {
+         tmp = vx1 + ydir *(i->first);
+         glVertex3dv(tmp.Arr());
+         tmp = vx2 + ydir *(i->first);
+         glVertex3dv(tmp.Arr());
+      }
+      glEnd();
+
+      // secondary tick mark lines
+      if (labs.size() > 1)
+      {
+         TGLUtil::ColorTransparency(lineColor, alpha2);
+         glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT);
+         glEnable(GL_LINE_STIPPLE);
+         glLineStipple(1, stipple);
+
+         glBegin(GL_LINES);
+         Int_t ondiv;
+         Double_t omin, omax, bw1;
+         Double_t val =0;
+         THLimitsFinder::Optimize(labs[0].second, labs[1].second, secSteps, omin, omax, ondiv, bw1);
+         val =  labs[0].second;
+         while(val < fFrustum[3])
+         {
+            for(Int_t k=0; k<ondiv; k++)
+            {
+               val += bw1;
+               tmp = vx1 + ydir *val;
+               glVertex3dv(tmp.Arr());
+               tmp = vx2 + ydir * val;
+               glVertex3dv(tmp.Arr());
+            }
+         }
+
+         val = labs[0].second - bw1;
+         while(val > fFrustum[1])
+         {
+            tmp = vx1 + ydir *val;
+            glVertex3dv(tmp.Arr());
+            tmp = vx2 + ydir * val;
+            glVertex3dv(tmp.Arr());
+            val -= bw1;
+         }
+         glEnd();
+         glPopAttrib();
+      }
+   } // draw grid
 }
 
 //______________________________________________________________________________
@@ -244,8 +366,6 @@ void TGLCameraOverlay::RenderBar(TGLRnrCtx&  rnrCtx)
    xdir.Normalise();
    ydir.Normalise();
 
-   TGLUtil::Color(rnrCtx.ColorSet().Foreground());
-
    const char* txt = Form("%.*f", (exp < 0) ? -exp : 0, red);
    Float_t bb[6];
    TGLFont font;
@@ -262,7 +382,7 @@ void TGLCameraOverlay::RenderBar(TGLRnrCtx&  rnrCtx)
    glPopMatrix();
 
    glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT);
-   glLineWidth(2.);
+   TGLUtil::LineWidth(2.);
    glPushMatrix();
    Float_t xt = fFrustum[2] - 1.1*barsize;
    Float_t yt = fFrustum[3] - 2.1*mH;
@@ -310,7 +430,6 @@ void TGLCameraOverlay::Render(TGLRnrCtx& rnrCtx)
         (cam.IsOrthographic() && ! fShowOrthographic))
       return;
 
-   TGLCapabilitySwitch lights_off(GL_LIGHTING, kFALSE);
 
    // Frustum size.
    TGLCamera &camera = rnrCtx.RefCamera();
@@ -319,14 +438,48 @@ void TGLCameraOverlay::Render(TGLRnrCtx& rnrCtx)
    Float_t t =  camera.FrustumPlane(TGLCamera::kTop).D();
    Float_t b = -camera.FrustumPlane(TGLCamera::kBottom).D();
 
-   fFrustum[0]=l;
-   fFrustum[1]=b;
-   fFrustum[2]=r;
-   fFrustum[3]=t;
+   fFrustum[0] = l;
+   fFrustum[1] = b;
+   fFrustum[2] = r;
+   fFrustum[3] = t;
+
+   glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT);
+   glEnable(GL_BLEND);
+   glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+
+   TGLCapabilitySwitch lights_off(GL_LIGHTING, kFALSE);
+   Float_t old_depth_range[2];
+   glGetFloatv(GL_DEPTH_RANGE, old_depth_range);
+
+   TGLUtil::Color(rnrCtx.ColorSet().Foreground());
 
    if (cam.IsOrthographic())
-      (fOrthographicMode == kBar) ? RenderBar(rnrCtx) :  RenderAxis(rnrCtx);
+   {
+      switch (fOrthographicMode)
+      {
+         case kBar:
+            RenderBar(rnrCtx);
+            break;
+         case kAxis:
+            RenderAxis(rnrCtx, kFALSE);
+            break;
+         case kGridFront:
+            glDepthRange(0, 0.1);
+            RenderAxis(rnrCtx, kTRUE);
+            break;
+         case kGridBack:
+            glDepthRange(1, 0.9);
+            RenderAxis(rnrCtx, kTRUE);
+            break;
+         default:
+            break;
+      };
+   }
    else
+   {
       RenderPlaneIntersect(rnrCtx);
-}
+   }
 
+   glDepthRange(old_depth_range[0], old_depth_range[1]);
+   glPopAttrib();
+}
diff --git a/graf3d/gl/src/TGLClip.cxx b/graf3d/gl/src/TGLClip.cxx
index 7a96ac8..13e926b 100644
--- a/graf3d/gl/src/TGLClip.cxx
+++ b/graf3d/gl/src/TGLClip.cxx
@@ -175,6 +175,9 @@ void TGLClipPlane::Setup(const TGLBoundingBox & bbox)
    Double_t extents = bbox.Extents().Mag();
    TGLClipPlaneLogical* cpl = (TGLClipPlaneLogical*) GetLogical();
    cpl->Resize(extents);
+   if (!fValid) {
+      SetTransform(TGLMatrix(bbox.Center(), BoundingBox().GetNearPlane().Norm()));
+   }
    IncTimeStamp();
    fValid = kTRUE;
 }
diff --git a/graf3d/gl/src/TGLManip.cxx b/graf3d/gl/src/TGLManip.cxx
index 0002ab5..6da4ad3 100644
--- a/graf3d/gl/src/TGLManip.cxx
+++ b/graf3d/gl/src/TGLManip.cxx
@@ -167,7 +167,7 @@ void TGLManip::CalcDrawScale(const TGLBoundingBox& box,
       } else {
          axis[i] = box.Axis(i, kFALSE)*-0.51;
          if (axis[i].Mag() < base*10.0) {
-            axis[i] *= base*10.0/axis[i].Mag();
+            axis[i] = box.Axis(i, kTRUE)*base*-10.0;
          }
       }
    }
diff --git a/graf3d/gl/src/TGLOrthoCamera.cxx b/graf3d/gl/src/TGLOrthoCamera.cxx
index 1a1e514..c538751 100644
--- a/graf3d/gl/src/TGLOrthoCamera.cxx
+++ b/graf3d/gl/src/TGLOrthoCamera.cxx
@@ -281,12 +281,20 @@ void TGLOrthoCamera::Apply(const TGLBoundingBox & /*box*/,
 
 //______________________________________________________________________________
 void TGLOrthoCamera::Configure(Double_t zoom, Double_t dolly, Double_t center[3],
-                                     Double_t hRotate, Double_t vRotate)
+                               Double_t hRotate, Double_t vRotate)
 {
    // Configure the camera state.
+   //   zoom    - set directly (default = 0.78);
+   //   dolly   - additional move along the camera forward direction;
+   //   center  - new camera center (can be 0 for no change);
+   //   hRotate - additional "up/down" rotation in radians;
+   //   vRotate - additional "left/right" rotation in radians.
 
    fZoom = zoom;
-   SetCenterVec(center[0], center[1], center[2]);
+
+   if (center)
+      SetCenterVec(center[0], center[1], center[2]);
+
    fCamTrans.MoveLF(1, dolly);
    RotateRad(hRotate, vRotate);
 
diff --git a/graf3d/gl/src/TGLOverlayButton.cxx b/graf3d/gl/src/TGLOverlayButton.cxx
index 4da4983..665945c 100644
--- a/graf3d/gl/src/TGLOverlayButton.cxx
+++ b/graf3d/gl/src/TGLOverlayButton.cxx
@@ -115,7 +115,7 @@ void TGLOverlayButton::Render(TGLRnrCtx& rnrCtx)
    // First the border, same color as text
    TColor::Pixel2RGB(fTextColor, r, g, b);
    (fActiveID == 1) ? TGLUtil::Color4f(r, g, b, fHighAlpha):TGLUtil::Color4f(r, g, b, fNormAlpha);
-   glLineWidth(1);
+   TGLUtil::LineWidth(1);
    glBegin(GL_LINE_LOOP);
    glVertex2f(0.0, 0.0);
    glVertex2f(0.0, fHeight);
diff --git a/graf3d/gl/src/TGLParametricEquationGL.cxx b/graf3d/gl/src/TGLParametricEquationGL.cxx
index a543aab..ed64be2 100644
--- a/graf3d/gl/src/TGLParametricEquationGL.cxx
+++ b/graf3d/gl/src/TGLParametricEquationGL.cxx
@@ -28,19 +28,15 @@
 ClassImp(TGLParametricEquationGL);
 
 //______________________________________________________________________________
-TGLParametricEquationGL::TGLParametricEquationGL() : TGLObject(), fM(0)
+TGLParametricEquationGL::TGLParametricEquationGL() : TGLPlot3D(), fM(0)
 {
    // Constructor.
-
-   fDLCache = kFALSE; // Disable display list.
 }
 
 //______________________________________________________________________________
 TGLParametricEquationGL::~TGLParametricEquationGL()
 {
    // Destructor.
-
-   delete fPlotPainter;
 }
 
 //______________________________________________________________________________
@@ -48,10 +44,10 @@ Bool_t TGLParametricEquationGL::SetModel(TObject* obj, const Option_t* opt)
 {
    // Set model object.
 
-   if(SetModelCheckClass(obj, TGLParametricEquation::Class()))
+   if (SetModelCheckClass(obj, TGLParametricEquation::Class()))
    {
       fM = dynamic_cast<TGLParametricEquation*>(obj);
-      fPlotPainter = new TGLParametricPlot(fM, 0);
+      SetPainter( new TGLParametricPlot(fM, 0) );
       TString option(opt);
       fPlotPainter->AddOption(option);
       fPlotPainter->InitGeometry();
diff --git a/graf3d/gl/src/TGLPerspectiveCamera.cxx b/graf3d/gl/src/TGLPerspectiveCamera.cxx
index b582caf..42ff238 100644
--- a/graf3d/gl/src/TGLPerspectiveCamera.cxx
+++ b/graf3d/gl/src/TGLPerspectiveCamera.cxx
@@ -253,7 +253,13 @@ void TGLPerspectiveCamera::Apply(const TGLBoundingBox & sceneBox,
 void TGLPerspectiveCamera::Configure(Double_t fov, Double_t dolly, Double_t center[3],
                                      Double_t hRotate, Double_t vRotate)
 {
-   // Configure the camera state
+   // Configure the camera state.
+   //   fov     - set directly field-of-view in degrees (default = 30);
+   //   dolly   - additional move along the camera forward direction;
+   //   center  - new camera center (can be 0 for no change);
+   //   hRotate - additional "up/down" rotation in radians;
+   //   vRotate - additional "left/right" rotation in radians.
+
    fFOV = fov;
 
    // Don't generally constrain external configuration
@@ -266,7 +272,9 @@ void TGLPerspectiveCamera::Configure(Double_t fov, Double_t dolly, Double_t cent
       fFOV = 0.1;
    }
 
-   SetCenterVec(center[0], center[1], center[2]);
+   if (center)
+      SetCenterVec(center[0], center[1], center[2]);
+
    fCamTrans.MoveLF(1, dolly);
    RotateRad(hRotate, vRotate);
 
diff --git a/graf3d/gl/src/TGLPlot3D.cxx b/graf3d/gl/src/TGLPlot3D.cxx
new file mode 100644
index 0000000..63a67dd
--- /dev/null
+++ b/graf3d/gl/src/TGLPlot3D.cxx
@@ -0,0 +1,122 @@
+// @(#)root/eve:$Id: TGLPlot3D.cxx 29909 2009-08-25 19:04:28Z matevz $
+// Author: Matevz Tadel 2007
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#include "TGLPlot3D.h"
+
+#include "TH3.h"
+#include "TH3GL.h"
+#include "TH2.h"
+#include "TH2GL.h"
+#include "TF2.h"
+#include "TF2GL.h"
+#include "TGLParametric.h"
+#include "TGLParametricEquationGL.h"
+
+#include "TVirtualPad.h"
+
+//______________________________________________________________________________
+// Description of TGLPlot3D
+//
+
+ClassImp(TGLPlot3D);
+
+//______________________________________________________________________________
+TGLPlot3D::TGLPlot3D() : TGLObject(), fPlotPainter(0)
+{
+   // Constructor.
+
+   fDLCache = kFALSE; // Disable display list.
+}
+
+//______________________________________________________________________________
+TGLPlot3D::~TGLPlot3D()
+{
+   // Destructor.
+
+   delete fPlotPainter;
+}
+
+//______________________________________________________________________________
+void TGLPlot3D::SetPainter(TGLPlotPainter* p)
+{
+   // Set painter object and destroy the old one.
+
+   delete fPlotPainter;
+   fPlotPainter = p;
+}
+
+//==============================================================================
+
+//______________________________________________________________________________
+TGLPlot3D* TGLPlot3D::InstantiatePlot(TObject* obj)
+{
+   // Instantiate the correct plot-painter for given object.
+   // Protected method.
+
+   if (obj->InheritsFrom(TH3::Class()))
+   {
+      return new TH3GL();
+   }
+   else if (obj->InheritsFrom(TH2::Class()))
+   {
+      return new TH2GL();
+   }
+   else if (obj->InheritsFrom(TF2::Class()))
+   {
+      return new TF2GL();
+   }
+   else if (obj->InheritsFrom(TGLParametricEquation::Class()))
+   {
+      return new TGLParametricEquationGL();
+   }
+
+   return 0;
+}
+
+//______________________________________________________________________________
+TGLPlot3D* TGLPlot3D::CreatePlot(TObject* obj, const Option_t* opt, TVirtualPad* pad)
+{
+   // Create GL plot for specified object and options.
+   // Which axes are logarithmic is determined from a pad.
+
+   TGLPlot3D* log = InstantiatePlot(obj);
+
+   if (log)
+   {
+      log->fCoord.SetXLog(pad->GetLogx());
+      log->fCoord.SetYLog(pad->GetLogy());
+      log->fCoord.SetZLog(pad->GetLogz());
+      log->SetModel(obj, opt);
+      log->SetBBox();
+   }
+
+   return log;
+}
+
+//______________________________________________________________________________
+TGLPlot3D* TGLPlot3D::CreatePlot(TObject* obj, const Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz)
+{
+   // Create GL plot for specified object and options.
+   // Which axes are logarithmic is determined from explicit arguments.
+
+   TGLPlot3D* log = InstantiatePlot(obj);
+
+   if (log)
+   {
+      log->fCoord.SetXLog(logx);
+      log->fCoord.SetYLog(logy);
+      log->fCoord.SetZLog(logz);
+      log->SetModel(obj, opt);
+      log->SetBBox();
+   }
+
+   return log;
+}
diff --git a/graf3d/gl/src/TGLPolyLine.cxx b/graf3d/gl/src/TGLPolyLine.cxx
index f17b7df..58b2053 100644
--- a/graf3d/gl/src/TGLPolyLine.cxx
+++ b/graf3d/gl/src/TGLPolyLine.cxx
@@ -13,6 +13,7 @@
 #include "TGLPolyLine.h"
 #include "TGLRnrCtx.h"
 #include "TGLIncludes.h"
+#include "TGLUtil.h"
 
 #include "TBuffer3D.h"
 #include "TBuffer3DTypes.h"
@@ -57,7 +58,7 @@ void TGLPolyLine::DirectDraw(TGLRnrCtx & rnrCtx) const
    Double_t oldWidth = 1.;
    glGetDoublev(GL_LINE_WIDTH, &oldWidth);
 
-   glLineWidth(fLineWidth);
+   TGLUtil::LineWidth(fLineWidth);
 
    glBegin(GL_LINE_STRIP);
 
diff --git a/graf3d/gl/src/TGLPolyMarker.cxx b/graf3d/gl/src/TGLPolyMarker.cxx
index 5c1e80f..2663c36 100644
--- a/graf3d/gl/src/TGLPolyMarker.cxx
+++ b/graf3d/gl/src/TGLPolyMarker.cxx
@@ -14,6 +14,7 @@
 #include "TGLPolyMarker.h"
 #include "TGLRnrCtx.h"
 #include "TGLIncludes.h"
+#include "TGLUtil.h"
 
 #include "TBuffer3D.h"
 #include "TBuffer3DTypes.h"
@@ -103,7 +104,7 @@ void TGLPolyMarker::DirectDraw(TGLRnrCtx & rnrCtx) const
    case 6:
       pixelSize += 1;
    case 1: case 9: case 10: case 11: default:
-      glPointSize(pixelSize);
+      TGLUtil::PointSize(pixelSize);
       glBegin(GL_POINTS);
       for (UInt_t i = 0; i < size; i += 3)
          glVertex3dv(vertices + i);
diff --git a/graf3d/gl/src/TGLRnrCtx.cxx b/graf3d/gl/src/TGLRnrCtx.cxx
index d1a2979..f633653 100644
--- a/graf3d/gl/src/TGLRnrCtx.cxx
+++ b/graf3d/gl/src/TGLRnrCtx.cxx
@@ -64,6 +64,11 @@ TGLRnrCtx::TGLRnrCtx(TGLViewerBase* viewer) :
    fViewerStyle  (kStyleUndef),
    fSceneStyle   (kStyleUndef),
 
+   fViewerWFLineW (0),
+   fSceneWFLineW  (0),
+   fViewerOLLineW (0),
+   fSceneOLLineW  (0),
+
    fViewerClip   (0),
    fSceneClip    (0),
    fClip         (0),
@@ -81,6 +86,7 @@ TGLRnrCtx::TGLRnrCtx(TGLViewerBase* viewer) :
    fSelectBuffer (0),
 
    fColorSetStack(0),
+   fRenderScale  (1),
 
    fDLCaptureOpen (kFALSE),
    fGLCtxIdentity (0),
diff --git a/graf3d/gl/src/TGLScene.cxx b/graf3d/gl/src/TGLScene.cxx
index de114c3..8e87682 100644
--- a/graf3d/gl/src/TGLScene.cxx
+++ b/graf3d/gl/src/TGLScene.cxx
@@ -277,7 +277,9 @@ ClassImp(TGLScene);
 TGLScene::TGLScene() :
    TGLSceneBase(),
    fGLCtxIdentity(0),
-   fInSmartRefresh(kFALSE)
+   fInSmartRefresh(kFALSE),
+   fLastPointSizeScale (0),
+   fLastLineWidthScale (0)
 {}
 
 //______________________________________________________________________________
@@ -578,6 +580,21 @@ void TGLScene::PreDraw(TGLRnrCtx& rnrCtx)
       fGLCtxIdentity = cid;
       fGLCtxIdentity->AddClientRef();
    }
+   else
+   {
+      if (fLastPointSizeScale != TGLUtil::GetPointSizeScale() ||
+          fLastLineWidthScale != TGLUtil::GetLineWidthScale())
+      {
+         // Clear logical's DLs
+         LogicalShapeMapIt_t lit = fLogicalShapes.begin();
+         while (lit != fLogicalShapes.end()) {
+            lit->second->DLCacheClear();
+            ++lit;
+         }
+      }
+   }
+   fLastPointSizeScale = TGLUtil::GetPointSizeScale();
+   fLastLineWidthScale = TGLUtil::GetLineWidthScale();
 
    sinfo->PreDraw();
 
@@ -717,6 +734,7 @@ void TGLScene::RenderAllPasses(TGLRnrCtx&           rnrCtx,
       else if (pass == TGLRnrCtx::kPassOutlineLine)
       {
          // Second pass - outline (wireframe)
+         TGLUtil::LineWidth(rnrCtx.SceneOLLineW());
          glDisable(GL_POLYGON_OFFSET_FILL);
          glDisable(GL_LIGHTING);
 
@@ -728,6 +746,10 @@ void TGLScene::RenderAllPasses(TGLRnrCtx&           rnrCtx,
          // However this means clipped back edges not shown - so do inside and out....
          glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
       }
+      else if (pass == TGLRnrCtx::kPassWireFrame)
+      {
+         TGLUtil::LineWidth(rnrCtx.SceneWFLineW());
+      }
 
       // If no clip object no plane sets to extract/pass
       if ( ! sinfo->ShouldClip())
diff --git a/graf3d/gl/src/TGLSceneBase.cxx b/graf3d/gl/src/TGLSceneBase.cxx
index e3b5afd..879844d 100644
--- a/graf3d/gl/src/TGLSceneBase.cxx
+++ b/graf3d/gl/src/TGLSceneBase.cxx
@@ -57,6 +57,8 @@ TGLSceneBase::TGLSceneBase() :
    fMinorStamp       (1),
    fLOD              (TGLRnrCtx::kLODHigh),
    fStyle            (TGLRnrCtx::kStyleUndef),
+   fWFLineW          (0),
+   fOLLineW          (0),
    fClip             (0),
    fSelectable       (kTRUE),
    fBoundingBox      (),
@@ -378,6 +380,21 @@ void TGLSceneBase::PreDraw(TGLRnrCtx & rnrCtx)
    else                                         style = rnrCtx.ViewerStyle();
    rnrCtx.SetSceneStyle(style);
    sInfo.SetLastStyle(style);
+
+   // Wireframe line width.
+   Float_t wf_linew;
+   if (sInfo.WFLineW() != 0) wf_linew = sInfo.WFLineW();
+   else if  (fWFLineW  != 0) wf_linew = fWFLineW;
+   else                      wf_linew = rnrCtx.ViewerWFLineW();
+   rnrCtx.SetSceneWFLineW(wf_linew);
+   sInfo.SetLastWFLineW(wf_linew);
+   // Outline line width.
+   Float_t ol_linew;
+   if (sInfo.OLLineW() != 0) ol_linew = sInfo.OLLineW();
+   else if  (fOLLineW  != 0) ol_linew = fOLLineW;
+   else                      ol_linew = rnrCtx.ViewerOLLineW();
+   rnrCtx.SetSceneOLLineW(ol_linew);
+   sInfo.SetLastOLLineW(ol_linew);
 }
 
 //______________________________________________________________________________
@@ -390,10 +407,12 @@ void TGLSceneBase::PreRender(TGLRnrCtx & rnrCtx)
 
    TGLSceneInfo& sInfo = * rnrCtx.GetSceneInfo();
 
-   rnrCtx.SetClip      (sInfo.LastClip());
-   rnrCtx.SetCamera    (sInfo.LastCamera());
-   rnrCtx.SetCombiLOD  (sInfo.LastLOD());
-   rnrCtx.SetSceneStyle(sInfo.LastStyle());
+   rnrCtx.SetClip         (sInfo.LastClip());
+   rnrCtx.SetCamera       (sInfo.LastCamera());
+   rnrCtx.SetCombiLOD     (sInfo.LastLOD());
+   rnrCtx.SetSceneStyle   (sInfo.LastStyle());
+   rnrCtx.SetSceneWFLineW (sInfo.LastWFLineW());
+   rnrCtx.SetSceneOLLineW (sInfo.LastOLLineW());
 
    // !!!
    // eventually handle matrix stack.
diff --git a/graf3d/gl/src/TGLSceneInfo.cxx b/graf3d/gl/src/TGLSceneInfo.cxx
index 3c1e31f..00fa130 100644
--- a/graf3d/gl/src/TGLSceneInfo.cxx
+++ b/graf3d/gl/src/TGLSceneInfo.cxx
@@ -39,12 +39,16 @@ TGLSceneInfo::TGLSceneInfo(TGLViewerBase* view, TGLSceneBase* scene) :
    fScene     (scene),
    fActive    (kTRUE),
 
-   fLOD   (TGLRnrCtx::kLODUndef),
-   fStyle (TGLRnrCtx::kStyleUndef),
-   fClip  (0),
+   fLOD     (TGLRnrCtx::kLODUndef),
+   fStyle   (TGLRnrCtx::kStyleUndef),
+   fWFLineW (0),
+   fOLLineW (0),
+   fClip    (0),
 
    fLastLOD   (TGLRnrCtx::kLODUndef),
    fLastStyle (TGLRnrCtx::kStyleUndef),
+   fLastWFLineW (0),
+   fLastOLLineW (0),
    fLastClip  (0),
    fLastCamera(0),
 
diff --git a/graf3d/gl/src/TGLScenePad.cxx b/graf3d/gl/src/TGLScenePad.cxx
index 5be4719..83bb7e4 100644
--- a/graf3d/gl/src/TGLScenePad.cxx
+++ b/graf3d/gl/src/TGLScenePad.cxx
@@ -31,15 +31,7 @@
 #include "TList.h"
 #include "TMath.h"
 
-// Preliminary support for GL plot painters
-#include "TH3.h"
-#include "TH3GL.h"
-#include "TH2.h"
-#include "TH2GL.h"
-#include "TF2.h"
-#include "TF2GL.h"
-#include "TGLParametric.h"
-#include "TGLParametricEquationGL.h"
+#include "TGLPlot3D.h"
 
 
 //______________________________________________________________________________
@@ -86,6 +78,7 @@ void TGLScenePad::AddHistoPhysical(TGLLogicalShape* log)
    Double_t lm = TMath::Min(lw, lh);
 
    const TGLBoundingBox& bb = log->BoundingBox();
+
    // Timur always packs histos in a square: let's just take x-diff.
    Double_t size  = TMath::Sqrt(3) * (bb.XMax() - bb.XMin());
    Double_t scale = lm / size;
@@ -153,14 +146,9 @@ void TGLScenePad::ObjectPaint(TObject* obj, Option_t* opt)
    // Special handling of 2D/3D histograms to activate Timur's
    // histo-painters.
 
-   if (obj->InheritsFrom(TH3::Class()))
+   TGLPlot3D* log = TGLPlot3D::CreatePlot(obj, opt, gPad);
+   if (log)
    {
-      // TH3 in principle inherits from TAtt3D, but it gets painted
-      // via the histo-painters - which we need to bypass.
-      // printf("histo 3d\n");
-      TGLObject* log = new TH3GL();
-      log->SetModel(obj, opt);
-      log->SetBBox();
       AdoptLogical(*log);
       AddHistoPhysical(log);
    }
@@ -170,33 +158,6 @@ void TGLScenePad::ObjectPaint(TObject* obj, Option_t* opt)
       //printf("normal-painting %s / %s\n", obj->GetName(), obj->ClassName());
       obj->Paint(opt);
    }
-   else if (obj->InheritsFrom(TH2::Class()))
-   {
-      // printf("histo 2d\n");
-      TGLObject* log = new TH2GL();
-      log->SetModel(obj, opt);
-      log->SetBBox();
-      AdoptLogical(*log);
-      AddHistoPhysical(log);
-   }
-   else if (obj->InheritsFrom(TF2::Class()))
-   {
-      // printf("func 2d\n");
-      TGLObject* log = new TF2GL();
-      log->SetModel(obj, opt);
-      log->SetBBox();
-      AdoptLogical(*log);
-      AddHistoPhysical(log);
-   }
-   else if (obj->InheritsFrom(TGLParametricEquation::Class()))
-   {
-      // printf("parametric\n");
-      TGLObject* log = new TGLParametricEquationGL();
-      log->SetModel(obj, opt);
-      log->SetBBox();
-      AdoptLogical(*log);
-      AddHistoPhysical(log);
-   }
    else if (obj->InheritsFrom(TVirtualPad::Class()))
    {
       SubPadPaint(dynamic_cast<TVirtualPad*>(obj));
diff --git a/graf3d/gl/src/TGLUtil.cxx b/graf3d/gl/src/TGLUtil.cxx
index aa1c82d..c699e5c 100644
--- a/graf3d/gl/src/TGLUtil.cxx
+++ b/graf3d/gl/src/TGLUtil.cxx
@@ -1316,7 +1316,7 @@ void TGLColorSet::StdLightBackground()
    fBackground .SetColor(255, 255, 255);
    fForeground .SetColor(0,   0,   0);
    fOutline    .SetColor(0,   0,   0);
-   fMarkup     .SetColor(100, 100, 100);
+   fMarkup     .SetColor(55,  55,  55);
 
    fSelection[0].SetColor(0,   0,   0);
    fSelection[1].SetColor(200, 100, 100);
@@ -1342,6 +1342,11 @@ UInt_t TGLUtil::fgDefaultDrawQuality = 10;
 UInt_t TGLUtil::fgDrawQuality        = fgDefaultDrawQuality;
 UInt_t TGLUtil::fgColorLockCount     = 0;
 
+Float_t TGLUtil::fgPointSize      = 1.0f;
+Float_t TGLUtil::fgLineWidth      = 1.0f;
+Float_t TGLUtil::fgPointSizeScale = 1.0f;
+Float_t TGLUtil::fgLineWidthScale = 1.0f;
+
 #ifndef CALLBACK
 #define CALLBACK
 #endif
@@ -1574,28 +1579,28 @@ void TGLUtil::ColorTransparency(Color_t color_index, Char_t transparency)
 //______________________________________________________________________________
 void TGLUtil::Color3ub(UChar_t r, UChar_t g, UChar_t b)
 {
-   // Wrapper for glColor3f.
+   // Wrapper for glColor3ub.
    if (fgColorLockCount == 0) glColor3ub(r, g, b);
 }
 
 //______________________________________________________________________________
 void TGLUtil::Color4ub(UChar_t r, UChar_t g, UChar_t b, UChar_t a)
 {
-   // Wrapper for glColor4f.
+   // Wrapper for glColor4ub.
    if (fgColorLockCount == 0) glColor4ub(r, g, b, a);
 }
 
 //______________________________________________________________________________
 void TGLUtil::Color3ubv(const UChar_t* rgb)
 {
-   // Wrapper for glColor3fv.
+   // Wrapper for glColor3ubv.
    if (fgColorLockCount == 0) glColor3ubv(rgb);
 }
 
 //______________________________________________________________________________
 void TGLUtil::Color4ubv(const UChar_t* rgba)
 {
-   // Wrapper for glColor4fv.
+   // Wrapper for glColor4ubv.
    if (fgColorLockCount == 0) glColor4ubv(rgba);
 }
 
@@ -1628,6 +1633,78 @@ void TGLUtil::Color4fv(const Float_t* rgba)
 }
 
 /******************************************************************************/
+// Control for scaling of point-size and line-width.
+/******************************************************************************/
+
+//______________________________________________________________________________
+Float_t TGLUtil::GetPointSizeScale()
+{
+   // Get global point-size scale.
+
+   return fgPointSizeScale;
+}
+
+//______________________________________________________________________________
+void TGLUtil::SetPointSizeScale(Float_t scale)
+{
+   // Set global point-size scale.
+
+   fgPointSizeScale = scale;
+}
+
+//______________________________________________________________________________
+Float_t TGLUtil::GetLineWidthScale()
+{
+   // Returns global line-width scale.
+
+   return fgLineWidthScale;
+}
+
+//______________________________________________________________________________
+void TGLUtil::SetLineWidthScale(Float_t scale)
+{
+   // Set global line-width scale.
+
+   fgLineWidthScale = scale;
+}
+
+//______________________________________________________________________________
+void TGLUtil::PointSize(Float_t point_size)
+{
+   // Set the point-size, taking the global scaling into account.
+   // Wrapper for glPointSize.
+
+   fgPointSize = point_size * fgPointSizeScale;
+   glPointSize(fgPointSize);
+}
+
+//______________________________________________________________________________
+void TGLUtil::LineWidth(Float_t line_width)
+{
+   // Set the line-width, taking the global scaling into account.
+   // Wrapper for glLineWidth.
+
+   fgLineWidth = line_width * fgLineWidthScale;
+   glLineWidth(fgLineWidth);
+}
+
+//______________________________________________________________________________
+Float_t TGLUtil::PointSize()
+{
+   // Get the point-size, taking the global scaling into account.
+
+   return fgPointSize;
+}
+
+//______________________________________________________________________________
+Float_t TGLUtil::LineWidth()
+{
+   // Get the line-width, taking the global scaling into account.
+
+   return fgLineWidth;
+}
+
+/******************************************************************************/
 // Rendering of polymarkers and lines from logical-shapes.
 /******************************************************************************/
 
@@ -1705,12 +1782,12 @@ void TGLUtil::RenderPoints(const TAttMarker& marker, Float_t* op, Int_t n,
       else if (style == 6) size = 2;
       else if (style == 7) size = 3;
    }
-   glPointSize(size);
+   TGLUtil::PointSize(size);
 
    // During selection extend picking region for large point-sizes.
-   Bool_t changePM = selection && size > pick_radius;
+   Bool_t changePM = selection && PointSize() > pick_radius;
    if (changePM)
-      BeginExtendPickRegion((Float_t) pick_radius / size);
+      BeginExtendPickRegion((Float_t) pick_radius / PointSize());
 
    Float_t* p = op;
    if (sec_selection)
@@ -1760,7 +1837,7 @@ void TGLUtil::RenderCrosses(const TAttMarker& marker, Float_t* op, Int_t n,
    {
       glEnable(GL_BLEND);
       glEnable(GL_LINE_SMOOTH);
-      glLineWidth(2);
+      LineWidth(2);
    }
    else
    {
@@ -1799,18 +1876,35 @@ void TGLUtil::RenderCrosses(const TAttMarker& marker, Float_t* op, Int_t n,
 
 //______________________________________________________________________________
 void TGLUtil::RenderPolyLine(const TAttLine& aline, Float_t* p, Int_t n,
-                                 Int_t pick_radius, Bool_t selection)
+                             Int_t pick_radius, Bool_t selection)
 {
    // Render poly-line as specified by the p-array.
 
    if (n == 0) return;
 
+   BeginAttLine(aline, pick_radius, selection);
+
+   Float_t* tp = p;
+   glBegin(GL_LINE_STRIP);
+   for (Int_t i=0; i<n; ++i, tp+=3)
+      glVertex3fv(tp);
+   glEnd();
+
+   EndAttLine(pick_radius, selection);
+}
+
+//______________________________________________________________________________
+void TGLUtil::BeginAttLine(const TAttLine& aline, Int_t pick_radius, Bool_t selection)
+{
+   // Setup drawing parrameters according to passed TAttLine.
+
    glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT);
 
    glDisable(GL_LIGHTING);
    TGLUtil::Color(aline.GetLineColor());
-   glLineWidth(aline.GetLineWidth());
-   if (aline.GetLineStyle() > 1) {
+   TGLUtil::LineWidth(aline.GetLineWidth());
+   if (aline.GetLineStyle() > 1)
+   {
       Int_t    fac = 1;
       UShort_t pat = 0xffff;
       switch (aline.GetLineStyle()) {
@@ -1830,20 +1924,19 @@ void TGLUtil::RenderPolyLine(const TAttLine& aline, Float_t* p, Int_t n,
    }
 
    // During selection extend picking region for large line-widths.
-   Bool_t changePM = selection && aline.GetLineWidth() > pick_radius;
-   if (changePM)
-      BeginExtendPickRegion((Float_t) pick_radius / aline.GetLineWidth());
+   if (selection && TGLUtil::LineWidth() > pick_radius)
+      BeginExtendPickRegion((Float_t) pick_radius / TGLUtil::LineWidth());
+}
 
-   Float_t* tp = p;
-   glBegin(GL_LINE_STRIP);
-   for (Int_t i=0; i<n; ++i, tp+=3)
-      glVertex3fv(tp);
-   glEnd();
+//______________________________________________________________________________
+void TGLUtil::EndAttLine(Int_t pick_radius, Bool_t selection)
+{
+   // Restore previous line drawing state.
 
-   if (changePM)
-      EndExtendPickRegion();
+   if (selection && TGLUtil::LineWidth() > pick_radius)
+     EndExtendPickRegion();
 
-   glPopAttrib();
+   glPopAttrib(); 
 }
 
 /******************************************************************************/
diff --git a/graf3d/gl/src/TGLViewer.cxx b/graf3d/gl/src/TGLViewer.cxx
index d100526..be2c696 100644
--- a/graf3d/gl/src/TGLViewer.cxx
+++ b/graf3d/gl/src/TGLViewer.cxx
@@ -119,6 +119,7 @@ TGLViewer::TGLViewer(TVirtualPad * pad, Int_t x, Int_t y,
    fRedrawTimer(0),
    fMaxSceneDrawTimeHQ(5000),
    fMaxSceneDrawTimeLQ(100),
+   fPointScale (1), fLineScale(1),
    fAxesType(TGLUtil::kAxesNone),
    fAxesDepthTest(kTRUE),
    fReferenceOn(kFALSE),
@@ -175,6 +176,7 @@ TGLViewer::TGLViewer(TVirtualPad * pad) :
    fRedrawTimer(0),
    fMaxSceneDrawTimeHQ(5000),
    fMaxSceneDrawTimeLQ(100),
+   fPointScale (1), fLineScale(1),
    fAxesType(TGLUtil::kAxesNone),
    fAxesDepthTest(kTRUE),
    fReferenceOn(kFALSE),
@@ -464,6 +466,9 @@ void TGLViewer::PreRender()
       fGLCtxId->DeleteGLResources();
    }
 
+   TGLUtil::SetPointSizeScale(fPointScale * fRnrCtx->GetRenderScale());
+   TGLUtil::SetLineWidthScale(fLineScale  * fRnrCtx->GetRenderScale());
+
    TGLViewerBase::PreRender();
 
    // Setup lighting
@@ -476,6 +481,18 @@ void TGLViewer::PreRender()
 }
 
 //______________________________________________________________________________
+void TGLViewer::PostRender()
+{
+   // Restore state set in PreRender().
+   // Called after every render.
+
+   TGLUtil::SetPointSizeScale(1);
+   TGLUtil::SetLineWidthScale(1);
+
+   TGLViewerBase::PostRender();
+}
+
+//______________________________________________________________________________
 void TGLViewer::DoDraw()
 {
    // Draw out the the current viewer/scene
@@ -528,11 +545,12 @@ void TGLViewer::DoDraw()
    {
       RenderNonSelected();
       DrawGuides();
+      RenderOverlay();
+
       glClear(GL_DEPTH_BUFFER_BIT);
       RenderSelected();
 
       glClear(GL_DEPTH_BUFFER_BIT);
-      RenderOverlay();
       DrawDebugInfo();
    }
 
@@ -1232,8 +1250,9 @@ TGLCamera& TGLViewer::RefCamera(ECameraType cameraType)
 void TGLViewer::SetCurrentCamera(ECameraType cameraType)
 {
    // Set current active camera - 'cameraType' one of:
-   // kCameraPerspX, kCameraPerspY, kCameraPerspZ
-   // kCameraOrthoXOY, kCameraOrthoXOZ, kCameraOrthoZOY
+   //   kCameraPerspX,    kCameraPerspY,    kCameraPerspZ,
+   //   kCameraOrthoXOY,  kCameraOrthoXOZ,  kCameraOrthoZOY,
+   //   kCameraOrthoXnOY, kCameraOrthoXnOZ, kCameraOrthoZnOY
 
    if (IsLocked()) {
       Error("TGLViewer::SetCurrentCamera", "expected kUnlocked, found %s", LockName(CurrentLock()));
diff --git a/graf3d/gl/src/TGLViewerBase.cxx b/graf3d/gl/src/TGLViewerBase.cxx
index 607faa4..1f0f446 100644
--- a/graf3d/gl/src/TGLViewerBase.cxx
+++ b/graf3d/gl/src/TGLViewerBase.cxx
@@ -52,6 +52,8 @@ TGLViewerBase::TGLViewerBase() :
    fClip      (0),
    fLOD       (TGLRnrCtx::kLODHigh),
    fStyle     (TGLRnrCtx::kFill),
+   fWFLineW   (1),
+   fOLLineW   (1),
 
    fResetSceneInfosOnRender (kFALSE),
    fChanged                 (kFALSE)
@@ -278,8 +280,8 @@ void TGLViewerBase::PreRender()
    if (cid == 0)
    {
       // Assume derived class set it up for us.
-      // This happens due to very complex and involved implementation
-      // of gl-in-pad that uses gGLManager.
+      // This happens due to complex implementation
+      // of gl-in-pad using gGLManager.
       // In principle we should throw an exception:
       // throw std::runtime_error("Can not resolve GL context.");
    }
@@ -293,10 +295,12 @@ void TGLViewerBase::PreRender()
       }
    }
 
-   fRnrCtx->SetCamera      (fCamera);
-   fRnrCtx->SetViewerLOD   (fLOD);
-   fRnrCtx->SetViewerStyle (fStyle);
-   fRnrCtx->SetViewerClip  (fClip);
+   fRnrCtx->SetCamera        (fCamera);
+   fRnrCtx->SetViewerLOD     (fLOD);
+   fRnrCtx->SetViewerStyle   (fStyle);
+   fRnrCtx->SetViewerWFLineW (fWFLineW);
+   fRnrCtx->SetViewerOLLineW (fOLLineW);
+   fRnrCtx->SetViewerClip    (fClip);
 
    if (fResetSceneInfosOnRender)
    {
diff --git a/graf3d/gl/src/TGLViewerEditor.cxx b/graf3d/gl/src/TGLViewerEditor.cxx
index b256c81..83c593d 100644
--- a/graf3d/gl/src/TGLViewerEditor.cxx
+++ b/graf3d/gl/src/TGLViewerEditor.cxx
@@ -40,6 +40,11 @@ TGLViewerEditor::TGLViewerEditor(const TGWindow *p,  Int_t width, Int_t height,
    fCameraHome(0),
    fMaxSceneDrawTimeHQ(0),
    fMaxSceneDrawTimeLQ(0),
+   fPointSizeScale(0),
+   fLineWidthScale(0),
+   fWFLineWidth(0),
+   fOLLineWidth(0),
+
    fCameraCenterExt(0),
    fCaptureCenter(0),
    fCameraCenterX(0),
@@ -91,6 +96,11 @@ void TGLViewerEditor::ConnectSignals2Slots()
    fCameraHome->Connect("Pressed()", "TGLViewerEditor", this, "DoCameraHome()");
    fMaxSceneDrawTimeHQ->Connect("ValueSet(Long_t)", "TGLViewerEditor", this, "UpdateMaxDrawTimes()");
    fMaxSceneDrawTimeLQ->Connect("ValueSet(Long_t)", "TGLViewerEditor", this, "UpdateMaxDrawTimes()");
+   fPointSizeScale->Connect("ValueSet(Long_t)", "TGLViewerEditor", this, "UpdatePointLineStuff()");
+   fLineWidthScale->Connect("ValueSet(Long_t)", "TGLViewerEditor", this, "UpdatePointLineStuff()");
+   fWFLineWidth->Connect("ValueSet(Long_t)", "TGLViewerEditor", this, "UpdatePointLineStuff()");
+   fOLLineWidth->Connect("ValueSet(Long_t)", "TGLViewerEditor", this, "UpdatePointLineStuff()");
+
    fCameraCenterExt->Connect("Clicked()", "TGLViewerEditor", this, "DoCameraCenterExt()");
    fCaptureCenter->Connect("Clicked()", "TGLViewerEditor", this, "DoCaptureCenter()");
    fDrawCameraCenter->Connect("Clicked()", "TGLViewerEditor", this, "DoDrawCameraCenter()");
@@ -149,6 +159,10 @@ void TGLViewerEditor::SetModel(TObject* obj)
    fResetCameraOnDoubleClick->SetState(fViewer->GetResetCameraOnDoubleClick() ? kButtonDown : kButtonUp);
    fMaxSceneDrawTimeHQ->SetNumber(fViewer->GetMaxSceneDrawTimeHQ());
    fMaxSceneDrawTimeLQ->SetNumber(fViewer->GetMaxSceneDrawTimeLQ());
+   fPointSizeScale->SetNumber(fViewer->GetPointScale());
+   fLineWidthScale->SetNumber(fViewer->GetLineScale ());
+   fWFLineWidth->SetNumber(fViewer->WFLineW());
+   fOLLineWidth->SetNumber(fViewer->OLLineW());
    //camera look at
    TGLCamera & cam = fViewer->CurrentCamera();
    fCameraCenterExt->SetDown(cam.GetExternalCenter());
@@ -228,6 +242,18 @@ void TGLViewerEditor::UpdateMaxDrawTimes()
 }
 
 //______________________________________________________________________________
+void TGLViewerEditor::UpdatePointLineStuff()
+{
+   // Slot for point-sizes and line-widths.
+
+   fViewer->SetPointScale(fPointSizeScale->GetNumber());
+   fViewer->SetLineScale (fLineWidthScale->GetNumber());
+   fViewer->SetWFLineW(fWFLineWidth->GetNumber());
+   fViewer->SetOLLineW(fOLLineWidth->GetNumber());
+   ViewerRedraw();
+}
+
+//______________________________________________________________________________
 void TGLViewerEditor::DoCameraOverlay()
 {
    // Update viewer with GUI state.
@@ -372,7 +398,7 @@ void TGLViewerEditor::CreateStyleTab()
    af->AddFrame(fCameraHome, new TGLayoutHints(kLHintsLeft | kLHintsExpandX, 1, 1, 1, 3));
    fMaxSceneDrawTimeHQ = MakeLabeledNEntry(af, "Max HQ draw time:", 120, 6, TGNumberFormat::kNESInteger);
    fMaxSceneDrawTimeHQ->SetLimits(TGNumberFormat::kNELLimitMin, 0, 1e6);
-   fMaxSceneDrawTimeHQ->GetNumberEntry()->SetToolTipText("Maximum time spent in scene drawing\nin high-quality mode.");
+   fMaxSceneDrawTimeHQ->GetNumberEntry()->SetToolTipText("Maximum time spent in scene drawing\nin high-quality mode [ms].");
    fMaxSceneDrawTimeLQ = MakeLabeledNEntry(af, "Max LQ draw time:", 120, 6, TGNumberFormat::kNESInteger);
    fMaxSceneDrawTimeLQ->SetLimits(TGNumberFormat::kNELLimitMin, 0, 1e6);
    fMaxSceneDrawTimeLQ->GetNumberEntry()->SetToolTipText("Maximum time spent in scene drawing\nin low-quality mode (during rotation etc).");
@@ -388,6 +414,16 @@ void TGLViewerEditor::CreateStyleTab()
    fLightSet = new TGLLightSetSubEditor(this);
    fLightSet->Connect("Changed()", "TGLViewerEditor", this, "ViewerRedraw()");
    AddFrame(fLightSet, new TGLayoutHints(kLHintsTop | kLHintsExpandX, 2, 0, 0, 0));
+
+   // Point-sizes / line-widths.
+   fPointSizeScale = MakeLabeledNEntry(af, "Point-size scale:", 120, 6, TGNumberFormat::kNESRealOne);
+   fPointSizeScale->SetLimits(TGNumberFormat::kNELLimitMinMax, 0.1, 16);
+   fLineWidthScale = MakeLabeledNEntry(af, "Line-width scale:", 120, 6, TGNumberFormat::kNESRealOne);
+   fLineWidthScale->SetLimits(TGNumberFormat::kNELLimitMinMax, 0.1, 16);
+   fWFLineWidth = MakeLabeledNEntry(af, "Wireframe line-width:", 120, 6, TGNumberFormat::kNESRealOne);
+   fWFLineWidth->SetLimits(TGNumberFormat::kNELLimitMinMax, 0.1, 16);
+   fOLLineWidth = MakeLabeledNEntry(af, "Outline line-width:", 120, 6, TGNumberFormat::kNESRealOne);
+   fOLLineWidth->SetLimits(TGNumberFormat::kNELLimitMinMax, 0.1, 16);
 }
 
 //______________________________________________________________________________
@@ -445,6 +481,8 @@ void TGLViewerEditor::CreateGuidesTab()
    fCamMode->AddEntry("Plane", TGLCameraOverlay::kPlaneIntersect);
    fCamMode->AddEntry("Bar", TGLCameraOverlay::kBar);
    fCamMode->AddEntry("Axis", TGLCameraOverlay::kAxis);
+   fCamMode->AddEntry("Grid Front", TGLCameraOverlay::kGridFront);
+   fCamMode->AddEntry("Grid Back", TGLCameraOverlay::kGridBack);
    TGListBox* lb = fCamMode->GetListBox();
    lb->Resize(lb->GetWidth(), 5*18);
    fCamMode->Resize(90, 20);
diff --git a/graf3d/gl/src/TH2GL.cxx b/graf3d/gl/src/TH2GL.cxx
index 5ab7818..96455cf 100644
--- a/graf3d/gl/src/TH2GL.cxx
+++ b/graf3d/gl/src/TH2GL.cxx
@@ -36,19 +36,15 @@ ClassImp(TH2GL);
 
 //______________________________________________________________________________
 TH2GL::TH2GL() :
-TGLObject(), fM(0), fPlotPainter(0)
+   TGLPlot3D(), fM(0)
 {
    // Constructor.
-
-   fDLCache = kFALSE; // Disable display list.
 }
 
 //______________________________________________________________________________
 TH2GL::~TH2GL()
 {
    // Destructor.
-
-   delete fPlotPainter;
 }
 
 //______________________________________________________________________________
@@ -65,14 +61,9 @@ Bool_t TH2GL::SetModel(TObject* obj, const Option_t* opt)
 
       // Plot type
       if (option.Index("surf") != kNPOS)
-         fPlotPainter = new TGLSurfacePainter(fM, 0, &fCoord);
+         SetPainter( new TGLSurfacePainter(fM, 0, &fCoord) );
       else
-         fPlotPainter = new TGLLegoPainter(fM, 0, &fCoord);
-
-      // Coord-system
-      fCoord.SetXLog(gPad->GetLogx());
-      fCoord.SetYLog(gPad->GetLogy());
-      fCoord.SetZLog(gPad->GetLogz());
+         SetPainter( new TGLLegoPainter(fM, 0, &fCoord) );
 
       if (option.Index("sph") != kNPOS)
          fCoord.SetCoordType(kGLSpherical);
@@ -116,6 +107,7 @@ void TH2GL::DirectDraw(TGLRnrCtx & rnrCtx) const
 
    // Axes
    TGLAxisPainterBox axe_painter;
+   axe_painter.SetUseAxisColors(kFALSE);
    axe_painter.SetFontMode(TGLFont::kPixmap);
    axe_painter.PlotStandard(rnrCtx, fM, fBoundingBox);
 }
diff --git a/graf3d/gl/src/TH3GL.cxx b/graf3d/gl/src/TH3GL.cxx
index 471473d..0a3e578 100644
--- a/graf3d/gl/src/TH3GL.cxx
+++ b/graf3d/gl/src/TH3GL.cxx
@@ -33,19 +33,15 @@ ClassImp(TH3GL);
 
 //______________________________________________________________________________
 TH3GL::TH3GL() :
-   TGLObject(), fM(0), fPlotPainter(0)
+   TGLPlot3D(), fM(0)
 {
    // Constructor.
-
-   fDLCache = kFALSE; // Disable display list.
 }
 
 //______________________________________________________________________________
 TH3GL::~TH3GL()
 {
    // Destructor.
-
-   delete fPlotPainter;
 }
 
 /******************************************************************************/
@@ -58,12 +54,13 @@ Bool_t TH3GL::SetModel(TObject* obj, const Option_t* opt)
    TString option(opt);
    option.ToLower();
 
-   if (SetModelCheckClass(obj, TH3::Class())) {
+   if (SetModelCheckClass(obj, TH3::Class()))
+   {
       fM = dynamic_cast<TH3*>(obj);
       if (option.Index("iso") != kNPOS)
-         fPlotPainter = new TGLIsoPainter(fM, 0, &fCoord);
+         SetPainter( new TGLIsoPainter(fM, 0, &fCoord) );
       else if (option.Index("box") != kNPOS)
-         fPlotPainter = new TGLBoxPainter(fM, 0, &fCoord);
+         SetPainter( new TGLBoxPainter(fM, 0, &fCoord) );
 
       fPlotPainter->AddOption(option);
       fPlotPainter->InitGeometry();
@@ -102,6 +99,7 @@ void TH3GL::DirectDraw(TGLRnrCtx & rnrCtx) const
 
    // Axes
    TGLAxisPainterBox axe_painter;
+   axe_painter.SetUseAxisColors(kFALSE);
    axe_painter.SetFontMode(TGLFont::kPixmap);
    axe_painter.PlotStandard(rnrCtx, fM, fBoundingBox);
 }
diff --git a/gui/gui/src/TGListBox.cxx b/gui/gui/src/TGListBox.cxx
index 3543df4..d0ad63e 100644
--- a/gui/gui/src/TGListBox.cxx
+++ b/gui/gui/src/TGListBox.cxx
@@ -520,7 +520,8 @@ void TGLBContainer::AddEntry(TGLBEntry *lbe, TGLayoutHints *lhints)
    // Add listbox entry with hints to container. To show entry call
    // MapSubwindows() and Layout().
 
-   lbe->SetBackgroundColor(fgWhitePixel);
+   // DEPRECATED: the color should always be set in the TGLBEntry ctor
+   //lbe->SetBackgroundColor(fgWhitePixel);
 
    TGLBFrameElement *nw = new TGLBFrameElement(lbe, lhints ? lhints : fgDefaultHints);
    fList->Add(nw);
@@ -534,7 +535,8 @@ void TGLBContainer::InsertEntry(TGLBEntry *lbe, TGLayoutHints *lhints, Int_t aft
    // then add entry at head of list. To show entry call MapSubwindows() and
    // Layout().
 
-   lbe->SetBackgroundColor(fgWhitePixel);
+   // DEPRECATED: the color should always be set in the TGLBEntry ctor
+   //lbe->SetBackgroundColor(fgWhitePixel);
 
    TGLBEntry      *e;
    TGFrameElement *el, *nw;
@@ -569,7 +571,8 @@ void TGLBContainer::AddEntrySort(TGLBEntry *lbe, TGLayoutHints *lhints)
    // Insert listbox entry before the list box entry with a higher id.
    // To show entry call MapSubwindows() and Layout().
 
-   lbe->SetBackgroundColor(fgWhitePixel);
+   // DEPRECATED: the color should always be set in the TGLBEntry ctor
+   //lbe->SetBackgroundColor(fgWhitePixel);
 
    TGLBEntry      *e;
    TGFrameElement *el, *nw;
@@ -692,7 +695,7 @@ TGLBEntry *TGLBContainer::Select(Int_t id, Bool_t sel)
    TGLBEntry      *f;
    TGFrameElement *el;
 
-   if (fLastActive) {
+   if (!fMultiSelect && fLastActive) {
       fLastActive->Activate(kFALSE);
       fLastActive = 0;
    }
@@ -763,7 +766,7 @@ void TGLBContainer::GetSelectedEntries(TList *selected)
 //______________________________________________________________________________
 void TGLBContainer::SetMultipleSelections(Bool_t multi)
 {
-   // Enables and disables multible selections of entries.
+   // Enables and disables multiple selections of entries.
 
    TGFrameElement *el;
 
diff --git a/gui/gui/src/TGPack.cxx b/gui/gui/src/TGPack.cxx
index 3e1b493..3763b1f 100644
--- a/gui/gui/src/TGPack.cxx
+++ b/gui/gui/src/TGPack.cxx
@@ -301,11 +301,10 @@ void TGPack::RemoveFrameInternal(TGFrame* f)
       delete splitter;
    }
    f->UnmapWindow();
-   TGCompositeFrame::RemoveFrame(f);
-
 
-   fNVisible --;
    fWeightSum -= el->fWeight;
+   fNVisible --;
+   TGCompositeFrame::RemoveFrame(f);
 
    CheckSplitterVisibility();
    ResizeExistingFrames();
diff --git a/gui/gui/src/TRootEmbeddedCanvas.cxx b/gui/gui/src/TRootEmbeddedCanvas.cxx
index e39d4e1..c2e8db1 100644
--- a/gui/gui/src/TRootEmbeddedCanvas.cxx
+++ b/gui/gui/src/TRootEmbeddedCanvas.cxx
@@ -195,8 +195,12 @@ Bool_t TRootEmbeddedCanvas::HandleContainerButton(Event_t *event)
 
    if (event->fType == kButtonPress) {
       fButton = button;
-      if (button == kButton1)
-         fCanvas->HandleInput(kButton1Down, x, y);
+      if (button == kButton1) {
+         if (event->fState & kKeyShiftMask)
+            fCanvas->HandleInput(EEventType(7), x, y);
+         else
+            fCanvas->HandleInput(kButton1Down, x, y);
+      }
       if (button == kButton2)
          fCanvas->HandleInput(kButton2Down, x, y);
       if (button == kButton3) {
@@ -211,7 +215,11 @@ Bool_t TRootEmbeddedCanvas::HandleContainerButton(Event_t *event)
          fCanvas->HandleInput(kButton2Up, x, y);
       if (button == kButton3)
          fCanvas->HandleInput(kButton3Up, x, y);
-
+      if (button == kButton4)
+         fCanvas->HandleInput(EEventType(5), x, y);//hack
+      if (button == kButton5)
+         fCanvas->HandleInput(EEventType(6), x, y);//hack
+      
       fButton = 0;
    }
 
@@ -284,8 +292,14 @@ Bool_t TRootEmbeddedCanvas::HandleContainerMotion(Event_t *event)
 
    if (fButton == 0)
       fCanvas->HandleInput(kMouseMotion, x, y);
-   if (fButton == kButton1)
-      fCanvas->HandleInput(kButton1Motion, x, y);
+   if (fButton == kButton1) {
+      if (event->fState & kKeyShiftMask)
+         fCanvas->HandleInput(EEventType(8), x, y);
+      else
+         fCanvas->HandleInput(kButton1Motion, x, y);
+   }
+   if (fButton == kButton2)
+      fCanvas->HandleInput(kButton2Motion, x, y);
 
    return kTRUE;
 }
diff --git a/tutorials/eve/cms_calo.C b/tutorials/eve/cms_calo.C
index 402d66b..378a726 100644
--- a/tutorials/eve/cms_calo.C
+++ b/tutorials/eve/cms_calo.C
@@ -20,19 +20,16 @@ void cms_calo(Bool_t hdata = kTRUE)
    TH2F* ecalHist = (TH2F*)hf->Get("ecalLego");
    TH2F* hcalHist = (TH2F*)hf->Get("hcalLego");
 
-   // palette
-   gStyle->SetPalette(1, 0);
-
-   // different calorimeter presentations
+   // fill data
    TEveCaloData* data = 0;
    if (hdata)
    {
       TEveCaloDataHist* hd = new TEveCaloDataHist();
-      Int_t s;
-      s = hd->AddHistogram(ecalHist);
-      hd->RefSliceInfo(s).Setup("ECAL", 0.3, kRed);
-      s = hd->AddHistogram(hcalHist);
-      hd->RefSliceInfo(s).Setup("HCAL", 0.1, kYellow);
+      Int_t slice;
+      slice = hd->AddHistogram(ecalHist);
+      hd->RefSliceInfo(slice).Setup("ECAL", 0.3, kRed);
+      slice = hd->AddHistogram(hcalHist);
+      hd->RefSliceInfo(slice).Setup("HCAL", 0.1, kBlue);
       data = hd;
    }
    else
@@ -45,61 +42,66 @@ void cms_calo(Bool_t hdata = kTRUE)
    data->GetPhiBins()->SetTitleFont(120);
    data->GetPhiBins()->SetTitle("f");
 
-   TEveCalo3D* calo3d = MakeCalo3D(data);
-   MakeCalo2D(calo3d);
-   MakeCaloLego(data);
+   // different calorimeter presentations
+   TEveViewer* v = (TEveViewer*)gEve->GetViewers()->FirstChild();
+   TEveScene* s = (TEveScene*)gEve->GetScenes()->FirstChild();
+   MakeCaloLego(data, v, s);
+
+   TEveViewer* v3D = gEve->SpawnNewViewer("3D Viewer");
+   TEveScene*  s3D = gEve->SpawnNewScene("3D scene");
+   v3D->AddScene(s3D);
+   TEveCalo3D* calo3d = MakeCalo3D(data, v3D, s3D);
+
+   TEveViewer* vP = gEve->SpawnNewViewer("2D Viewer");
+   TEveScene*  sP = gEve->SpawnNewScene("Projected Event");
+   vP->AddScene(sP);
+   MakeCalo2D(calo3d, vP, sP);
+
    gEve->Redraw3D(1);
 }
 
 //______________________________________________________________________________
-TEveCalo3D* MakeCalo3D(TEveCaloData* data)
+TEveCalo3D* MakeCalo3D(TEveCaloData* data, TEveViewer *v, TEveScene *s )
 {
-
    // 3D towers
+
    TEveCalo3D* calo3d = new TEveCalo3D(data);
    calo3d->SetBarrelRadius(129);
    calo3d->SetEndCapPos(300);
-   gEve->AddElement(calo3d);
+   s->AddElement(calo3d);
 
    return calo3d;
 }
 
 //______________________________________________________________________________
-void MakeCalo2D(TEveCalo3D* calo3d)
+void MakeCalo2D(TEveCalo3D* calo3d, TEveViewer *ev, TEveScene *s)
 {
-   TEveViewer* v1 = gEve->SpawnNewViewer("2D Viewer");
-   TEveScene*  s1 = gEve->SpawnNewScene("Projected Event");
-   v1->AddScene(s1);
-   TGLViewer* v = v1->GetGLViewer();
+   // projected calorimeter
+
+   TGLViewer* v = ev->GetGLViewer();
    v->SetCurrentCamera(TGLViewer::kCameraOrthoXOY);
    v->SetGuideState(TGLUtil::kAxesOrigin, kTRUE, kFALSE, 0);
    v->ColorSet().Background().SetColor(kBlue + 4);
 
-   // projected calorimeter
    TEveProjectionManager* mng = new TEveProjectionManager();
    mng->SetProjection(TEveProjection::kPT_RhoZ);
-   gEve->AddElement(mng, s1);
-   gEve->AddToListTree(mng, kTRUE);
 
    TEveProjectionAxes* axes = new TEveProjectionAxes(mng);
    axes->SetTitle("TEveProjections demo");
-   s1->AddElement(axes);
-   gEve->AddToListTree(axes, kTRUE);
-   gEve->AddToListTree(mng, kTRUE);
-
+   s->AddElement(axes);
+   //  s->AddElement(calo3D);
    TEveCalo2D* c2d = (TEveCalo2D*) mng->ImportElements(calo3d);
-   c2d->SetValueIsColor(kFALSE);
+   s->AddElement(c2d);
 }
 
 //______________________________________________________________________________
-void MakeCaloLego(TEveCaloData* data)
+void MakeCaloLego(TEveCaloData* data, TEveViewer* v2, TEveScene* s2)
 {
-   TEveViewer* v2 = gEve->SpawnNewViewer("Lego Viewer");
+   // eta-phi histogram
+
    TGLViewer*  v  = v2->GetGLViewer();
-   v->SetCurrentCamera(TGLViewer::kCameraPerspXOY);
+   v->SetCurrentCamera(TGLViewer::kCameraOrthoXOY);
    v->SetEventHandler(new TEveLegoEventHandler("Lego", v->GetGLWidget(), v));
-   TEveScene*  s2 = gEve->SpawnNewScene("Lego");
-   v2->AddScene(s2);
 
    // lego
    TEveCaloLego* lego = new TEveCaloLego(data);
@@ -108,25 +110,25 @@ void MakeCaloLego(TEveCaloData* data)
    lego->SetName("TwoHistLego");
    lego->SetPixelsPerBin(8);
    gEve->AddElement(lego, s2);
-   gEve->AddToListTree(lego, kTRUE);
 
    lego->InitMainTrans();
    Float_t sc = TMath::TwoPi();
    lego->RefMainTrans().SetScale(sc, sc, sc);
-   // overlay lego1
-   TEveCaloLegoOverlay* overlay = new TEveCaloLegoOverlay();
-   overlay->SetShowPlane(kTRUE);
 
-   overlay->SetHeaderTxt(Form("Max Et %3.1f", data->GetMaxVal(kTRUE)));
+   // add overlay lego draws scales in 2D
+   TEveCaloLegoOverlay* overlay = new TEveCaloLegoOverlay();
+   // overlay->SetHeaderTxt(Form("Max Et %3.1f", data->GetMaxVal(kTRUE)));
    overlay->GetAttAxis()->SetLabelSize(0.02);
+   overlay->SetShowPlane(kTRUE);
    v->AddOverlayElement(overlay);
    overlay->SetCaloLego(lego);
-   gEve->AddElement(overlay, s2);
 }
 
 //______________________________________________________________________________
 TEveCaloDataVec* MakeVecData(TH2* h1, TH2* h2)
 {
+   // Example how to fill data when bins can be iregular.
+
   TEveCaloDataVec* data = new TEveCaloDataVec(2);
 
   data->RefSliceInfo(0).Setup("ECAL", 0.3, kRed);
diff --git a/tutorials/eve/hierarchical_scene.C b/tutorials/eve/hierarchical_scene.C
new file mode 100644
index 0000000..67b8c78
--- /dev/null
+++ b/tutorials/eve/hierarchical_scene.C
@@ -0,0 +1,38 @@
+const Int_t Ns = 7;
+
+void add_blobs(TEveElement* p, Float_t rad, Float_t height, Float_t size,
+	       Int_t level)
+{
+  if (level <= 0) return;
+
+  for (Int_t i = 0; i < Ns; ++i)
+  {
+    TEveGeoShape* x = new TEveGeoShape("SS");
+    x->SetShape(new TGeoSphere(0, size));
+    Double_t phi = TMath::TwoPi() * i / Ns;
+    x->RefMainTrans().SetPos(rad*TMath::Cos(phi),
+			     rad*TMath::Sin(phi),
+			     height);
+    x->SetMainColor(TColor::GetColorPalette(gRandom->Integer(TColor::GetNumberOfColors())));
+    p->AddElement(x);
+
+    add_blobs(x, 0.8 * rad, 0.8 * height, 0.8 * size, level - 1);
+  }
+}
+
+void hierarchical_scene()
+{
+  TEveManager::Create();
+
+  TColor::SetPalette(1, 0);
+  gRandom = new TRandom3(0);
+
+  TEveScene *s = gEve->SpawnNewScene("Hierachical Scene", "OoogaDooga");
+  s->SetHierarchical(kTRUE);
+
+  gEve->GetDefaultViewer()->AddScene(s);
+
+  add_blobs(s, 6, 4, 0.5, 4);
+
+  gEve->Redraw3D(kTRUE);
+}
diff --git a/tutorials/eve/lineset_test.C b/tutorials/eve/lineset_test.C
index 7e4f3e6..cb65809 100644
--- a/tutorials/eve/lineset_test.C
+++ b/tutorials/eve/lineset_test.C
@@ -31,3 +31,32 @@ TEveStraightLineSet* lineset_test(Int_t nlines = 40, Int_t nmarkers = 4)
 
    return ls;
 }
+
+TEveStraightLineSet* lineset_test_2d(Int_t nlines = 40, Int_t nmarkers = 4) 
+{
+   TEveManager::Create();
+
+   TRandom r(0);
+   Float_t s = 100;
+
+   TEveStraightLineSet* ls = new TEveStraightLineSet();
+
+   for(Int_t i = 0; i<nlines; i++)
+   {
+      ls->AddLine( r.Uniform(-s,s), r.Uniform(-s,s), 0,
+                   r.Uniform(-s,s), r.Uniform(-s,s), 0);
+      // add random number of markers
+      Int_t nm = Int_t(nmarkers* r.Rndm());
+      for(Int_t m = 0; m < nm; m++) {
+         ls->AddMarker(i, r.Rndm());
+      }
+   }
+
+   ls->SetMarkerSize(1.5);
+   ls->SetMarkerStyle(4);
+
+   gEve->AddElement(ls);
+   gEve->Redraw3D();
+
+   return ls;
+}
diff --git a/tutorials/eve/quad_test.C b/tutorials/eve/quad_test.C
index 950e520..f3d9793 100644
--- a/tutorials/eve/quad_test.C
+++ b/tutorials/eve/quad_test.C
@@ -34,6 +34,12 @@ TEveQuadSet* quad_test(Float_t x=0, Float_t y=0, Float_t z=0,
    t.RotateLF(1, 3, 0.5*TMath::Pi());
    t.SetPos(x, y, z);
 
+   TGLViewer* v = gEve->GetDefaultGLViewer();
+   v->SetCurrentCamera(TGLViewer::kCameraOrthoZOY);
+   TGLCameraOverlay* co = v->GetCameraOverlay();
+   co->SetShowOrthographic(kTRUE);
+   co->SetOrthographicMode(TGLCameraOverlay::kGridFront);
+
    if (register)
    {
       gEve->AddElement(q);
diff --git a/tutorials/eve/test_glplot.C b/tutorials/eve/test_glplot.C
new file mode 100644
index 0000000..fcedd44
--- /dev/null
+++ b/tutorials/eve/test_glplot.C
@@ -0,0 +1,39 @@
+// Preliminary demo for showing Timur's GL plots in EVE.
+// Author: Matevz Tadel, July 2009
+
+// The main purpose of this test is to demonstrate the problems with
+// rendering of sevaral GL plots or with rendering of GL plots with
+// other scene objects - the usage of depth buffer destroys
+// depth-buffer coherence.
+
+void test_glplot()
+{
+   TEveManager::Create();
+   gEve->GetDefaultGLViewer()->SetCurrentCamera(TGLViewer::kCameraPerspXOY);
+
+   TF2 *f2 = new TF2("f2","x**2 + y**2 - x**3 -8*x*y**4", -1., 1.2, -1.5, 1.5);
+   f2->SetFillColor(45);
+   x = new TEvePlot3D("EvePlot - TF2");
+   x->SetLogZ(kTRUE);
+   x->SetPlot(f2,"glsurf4");
+   gEve->AddElement(x);
+
+
+   TH3F *h31 = new TH3F("h31", "h31", 10, -1, 1, 10, -1, 1, 10, -1, 1);
+   h31->FillRandom("gaus");
+   h31->SetFillColor(2);
+   x = new TEvePlot3D("EvePlot - TH3F");
+   x->SetPlot(h31, "glbox");
+   // This is useless now - the scale of plots can not be known.
+   // One Timur fixes them all to be in a unit-box, the following line
+   // should give resonable effects.
+   // x->RefMainTrans().MoveLF(2, -3);
+   // Until then, be a bit more brutal - set so that they fit together.
+   // This is completely different when log-scale is not used for the first plot.
+   x->RefMainTrans().MoveLF(2, -5);
+   x->RefMainTrans().Scale(1.8, 1.8, 1.8);
+
+   gEve->AddElement(x);
+
+   gEve->Redraw3D(kTRUE);
+}
diff --git a/tutorials/eve/track.C b/tutorials/eve/track.C
index 251e798..9997e9d 100644
--- a/tutorials/eve/track.C
+++ b/tutorials/eve/track.C
@@ -14,6 +14,10 @@
 #include "TEveViewer.h"
 #include "TEvePointSet.h"
 
+#include <iostream>
+
+TEveTrackPropagator* g_prop = 0;
+
 class GappedField : public TEveMagField
 {
 public:
@@ -29,6 +33,87 @@ public:
    }
 };
 
+//==============================================================================
+
+class CmsMagField: public TEveMagField
+{
+   bool m_magnetIsOn;
+   bool m_reverse;
+   bool m_simpleModel;
+
+public:
+   CmsMagField():
+      m_magnetIsOn(true),
+      m_reverse(false),
+      m_simpleModel(true){}
+
+   virtual ~CmsMagField(){}
+   virtual Float_t    GetMaxFieldMag() const { return m_magnetIsOn ? 3.8 : 0.0; }
+   void               setMagnetState( bool state )
+   {
+      if (state != m_magnetIsOn)
+      {
+         if ( state )
+            std::cout << "Magnet state is changed to ON" << std::endl;
+         else
+            std::cout << "Magnet state is changed to OFF" << std::endl;
+      }
+      m_magnetIsOn = state;
+   }
+
+   bool               isMagnetOn() const { return m_magnetIsOn;}
+   void               setReverseState( bool state ){ m_reverse = state; }
+   bool               isReverse() const { return m_reverse;}
+   void               setSimpleModel( bool simpleModel ){ m_simpleModel = simpleModel; }
+   bool               isSimpleModel() const { return m_simpleModel;}
+
+   using   TEveMagField::GetField;
+
+   virtual TEveVector GetField(Float_t x, Float_t y, Float_t z) const
+   {
+      double R = sqrt(x*x+y*y);
+      double field = m_reverse?-GetMaxFieldMag():GetMaxFieldMag();
+      //barrel
+      if ( TMath::Abs(z)<724 )
+      {
+         //inside solenoid
+         if ( R < 300) return TEveVector(0,0,field);
+         // outside solinoid
+         if ( m_simpleModel ||
+              ( R>461.0 && R<490.5 ) ||
+              ( R>534.5 && R<597.5 ) ||
+              ( R>637.0 && R<700.0 ) )
+            return TEveVector(0,0,-field/3.8*1.2);
+ 
+      } else {
+         // endcaps
+         if (m_simpleModel)
+         {
+            if ( R < 50 ) return TEveVector(0,0,field);
+            if ( z > 0 )
+               return TEveVector(x/R*field/3.8*2.0, y/R*field/3.8*2.0, 0);
+            else
+               return TEveVector(-x/R*field/3.8*2.0, -y/R*field/3.8*2.0, 0);
+         }
+         // proper model
+         if ( ( TMath::Abs(z)>724 && TMath::Abs(z)<786  ) ||
+              ( TMath::Abs(z)>850 && TMath::Abs(z)<910  ) ||
+              ( TMath::Abs(z)>975 && TMath::Abs(z)<1003 ) )
+         {
+            if ( z > 0 )
+               return TEveVector(x/R*field/3.8*2.0, y/R*field/3.8*2.0, 0);
+            else
+               return TEveVector(-x/R*field/3.8*2.0, -y/R*field/3.8*2.0, 0);
+         }
+      }
+      return TEveVector(0,0,0);
+   }
+};
+
+
+//==============================================================================
+//==============================================================================
+
 //______________________________________________________________________________
 TEveTrack* make_track(TEveTrackPropagator* prop, Int_t sign)
 {
@@ -40,7 +125,6 @@ TEveTrack* make_track(TEveTrackPropagator* prop, Int_t sign)
   rc->fP.Set(0.767095, -2.400006, -0.313103);
   rc->fSign = sign;
 
-
   TEveTrack* track = new TEveTrack(rc, prop);
   track->SetName(Form("Charge %d", sign));
   // daughter 0
@@ -56,7 +140,7 @@ TEveTrack* make_track(TEveTrackPropagator* prop, Int_t sign)
 }
 
 
-void track(Int_t bCase = 3, Bool_t isRungeKutta = kTRUE)
+void track(Int_t bCase = 5, Bool_t isRungeKutta = kTRUE)
 {
 #if defined (__CINT__)
    Error("track.C", "Must be run in compiled mode!");
@@ -67,7 +151,7 @@ void track(Int_t bCase = 3, Bool_t isRungeKutta = kTRUE)
    TEveManager::Create();
 
    TEveTrackList *list = new TEveTrackList();
-   TEveTrackPropagator* prop = list->GetPropagator();
+   TEveTrackPropagator* prop = g_prop = list->GetPropagator();
    prop->SetFitDaughters(kFALSE);
    prop->SetMaxZ(1000);
 
@@ -101,6 +185,7 @@ void track(Int_t bCase = 3, Bool_t isRungeKutta = kTRUE)
          track = make_track(prop, 1);
          break;
       }
+
       case 2:
       {
          // variable B field, sign change at  R = 200 cm
@@ -109,6 +194,7 @@ void track(Int_t bCase = 3, Bool_t isRungeKutta = kTRUE)
          track = make_track(prop, 1);
          break;
       }
+
       case 3:
       {
          // gapped field
@@ -128,6 +214,74 @@ void track(Int_t bCase = 3, Bool_t isRungeKutta = kTRUE)
          marker->SetPoint(1, 0., 0., 600.f);
          marker->SetMarkerColor(3);
          gEve->AddElement(marker);
+         break;
+      }
+
+      case 4:
+      {
+         CmsMagField* mf = new CmsMagField;
+         mf->setReverseState(true);
+
+         prop->SetMagFieldObj(mf);
+         prop->SetMaxR(1000);
+         prop->SetMaxZ(1000);
+	 prop->SetRnrDaughters(kTRUE);
+	 prop->SetRnrDecay(kTRUE);
+	 prop->RefPMAtt().SetMarkerStyle(4);
+         list->SetElementName(Form("%s, CMS field", list->GetElementName()));
+
+      
+         TEveRecTrack *rc = new TEveRecTrack();
+         rc->fV.Set(0.027667, 0.007919, 0.895964);
+         rc->fP.Set(3.903134, 2.252232, -3.731366);
+         rc->fSign = -1;
+         track = new TEveTrack(rc, prop);
+
+         track->AddPathMark(TEvePathMark(TEvePathMark::kDaughter, TEveVector(3.576755e+00, 2.080579e+00, -2.507230e+00)));
+         track->AddPathMark(TEvePathMark(TEvePathMark::kDaughter, TEveVector(8.440379e+01, 6.548286e+01, -8.788129e+01)));
+         track->AddPathMark(TEvePathMark(TEvePathMark::kDaughter, TEveVector(1.841321e+02, 3.915693e+02, -3.843072e+02)));
+         track->AddPathMark(TEvePathMark(TEvePathMark::kDaughter, TEveVector(1.946167e+02, 4.793932e+02, -4.615060e+02)));
+         track->AddPathMark(TEvePathMark(TEvePathMark::kDecay,    TEveVector(2.249656e+02, 5.835767e+02, -5.565275e+02)));
+
+	 track->SetRnrPoints(kTRUE);
+	 track->SetMarkerStyle(4);
+
+         break;
+      }
+
+      case 5:
+      {
+         CmsMagField* mf = new CmsMagField;
+         mf->setReverseState(true);
+         mf->setSimpleModel(false);
+
+         prop->SetMagFieldObj(mf);
+         prop->SetMaxR(1000);
+         prop->SetMaxZ(1000);
+	 prop->SetRnrReferences(kTRUE);
+	 prop->SetRnrDaughters(kTRUE);
+	 prop->SetRnrDecay(kTRUE);
+	 prop->RefPMAtt().SetMarkerStyle(4);
+         list->SetElementName(Form("%s, CMS field", list->GetElementName()));
+      
+         TEveRecTrack *rc = new TEveRecTrack();
+         rc->fV.Set(-16.426592, 16.403185, -19.782692);
+         rc->fP.Set(3.631100, 3.643450, 0.682254);
+         rc->fSign = -1;
+         track = new TEveTrack(rc, prop);
+
+         track->AddPathMark(TEvePathMark(TEvePathMark::kReference, TEveVector(-1.642659e+01, 1.640318e+01, -1.978269e+01), TEveVector(3.631100, 3.643450, 0.682254)));
+         track->AddPathMark(TEvePathMark(TEvePathMark::kReference, TEveVector(-1.859987e+00, 3.172243e+01, -1.697866e+01), TEveVector(3.456056, 3.809894, 0.682254)));
+         track->AddPathMark(TEvePathMark(TEvePathMark::kReference, TEveVector(4.847579e+01, 9.871711e+01, -5.835719e+00), TEveVector(2.711614, 4.409945, 0.687656)));
+         track->AddPathMark(TEvePathMark(TEvePathMark::kDaughter, TEveVector(1.342045e+02, 4.203950e+02, 3.846268e+01)));
+         track->AddPathMark(TEvePathMark(TEvePathMark::kDaughter, TEveVector(1.483827e+02, 5.124750e+02, 5.064311e+01)));
+         track->AddPathMark(TEvePathMark(TEvePathMark::kDaughter, TEveVector(1.674676e+02, 6.167731e+02, 6.517403e+01)));
+         track->AddPathMark(TEvePathMark(TEvePathMark::kDecay,    TEveVector(1.884976e+02, 7.202000e+02, 7.919290e+01)));
+
+	 track->SetRnrPoints(kTRUE);
+	 track->SetMarkerStyle(4);
+
+         break;
       }
    };
        
@@ -138,8 +292,9 @@ void track(Int_t bCase = 3, Bool_t isRungeKutta = kTRUE)
 
    track->SetLineColor(list->GetLineColor());
  
-   gEve->AddElement(track, list);
    gEve->AddElement(list);
+   list->AddElement(track);
+
    track->MakeTrack();
 
    TEveViewer* v = gEve->GetDefaultViewer();
